
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bkpdir: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">bkpdir/archive.go (75.5%)</option>
				
				<option value="file1">bkpdir/backup.go (49.1%)</option>
				
				<option value="file2">bkpdir/comparison.go (90.2%)</option>
				
				<option value="file3">bkpdir/config.go (92.7%)</option>
				
				<option value="file4">bkpdir/errors.go (95.8%)</option>
				
				<option value="file5">bkpdir/exclude.go (92.5%)</option>
				
				<option value="file6">bkpdir/formatter.go (89.9%)</option>
				
				<option value="file7">bkpdir/git.go (93.5%)</option>
				
				<option value="file8">bkpdir/internal/testutil/context.go (94.6%)</option>
				
				<option value="file9">bkpdir/internal/testutil/corruption.go (76.0%)</option>
				
				<option value="file10">bkpdir/internal/testutil/diskspace.go (93.4%)</option>
				
				<option value="file11">bkpdir/internal/testutil/errorinjection.go (90.4%)</option>
				
				<option value="file12">bkpdir/internal/testutil/permissions.go (72.5%)</option>
				
				<option value="file13">bkpdir/internal/testutil/scenario_helpers.go (0.0%)</option>
				
				<option value="file14">bkpdir/internal/testutil/scenarios.go (87.5%)</option>
				
				<option value="file15">bkpdir/main.go (44.9%)</option>
				
				<option value="file16">bkpdir/tools/coverage.go (0.0%)</option>
				
				<option value="file17">bkpdir/verify.go (72.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// This file is part of bkpdir
//
// Package main provides archive creation and management for BkpDir.
// It handles full and incremental archive creation, naming, and verification.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License
package main

import (
        "archive/zip"
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// ArchiveNameConfig holds configuration for generating archive names.
type ArchiveNameConfig struct {
        Prefix             string
        Timestamp          string
        GitBranch          string
        GitHash            string
        GitIsClean         bool
        ShowGitDirtyStatus bool
        Note               string
        IsGit              bool
        IsIncremental      bool
        BaseName           string
}

// Archive represents a directory archive with metadata including name, path,
// creation time, Git information, and verification status. It supports both
// full and incremental archives.
type Archive struct {
        Name               string
        Path               string
        CreationTime       time.Time
        IsIncremental      bool
        GitBranch          string
        GitHash            string
        Note               string
        BaseArchive        string // for incremental
        VerificationStatus *VerificationStatus
}

// ArchiveVerificationConfig holds configuration for archive verification
type ArchiveVerificationConfig struct {
        Path   string
        Config *Config
}

// ArchiveCreationConfig holds configuration for archive creation
type ArchiveCreationConfig struct {
        Context     context.Context
        CWD         string
        Path        string
        Files       []string
        Config      *Config
        Verify      bool
        ResourceMgr *ResourceManager
}

// ARCH-001: Archive naming convention implementation
// IMMUTABLE-REF: Archive Naming Convention
// TEST-REF: TestGenerateArchiveName
// DECISION-REF: DEC-001
// GenerateArchiveName creates an archive name according to the spec.
// It handles both full and incremental archive naming based on the provided configuration.
func GenerateArchiveName(cfg ArchiveNameConfig) string <span class="cov8" title="1">{
        if cfg.IsIncremental &amp;&amp; cfg.BaseName != "" </span><span class="cov8" title="1">{
                return generateIncrementalArchiveName(cfg)
        }</span>
        <span class="cov8" title="1">return generateFullArchiveNameFromConfig(cfg)</span>
}

// ARCH-003: Incremental archive naming implementation
// IMMUTABLE-REF: Archive Naming Convention
// TEST-REF: TestGenerateArchiveName
// DECISION-REF: DEC-001
// generateIncrementalArchiveName generates name for incremental archives
func generateIncrementalArchiveName(cfg ArchiveNameConfig) string <span class="cov8" title="1">{
        baseName := strings.TrimSuffix(cfg.BaseName, ".zip")
        name := baseName + "_update=" + cfg.Timestamp
        if cfg.IsGit &amp;&amp; cfg.GitBranch != "" &amp;&amp; cfg.GitHash != "" </span><span class="cov8" title="1">{
                name += "=" + cfg.GitBranch + "=" + cfg.GitHash
                if !cfg.GitIsClean &amp;&amp; cfg.ShowGitDirtyStatus </span><span class="cov0" title="0">{
                        name += "-dirty"
                }</span>
        }
        <span class="cov8" title="1">if cfg.Note != "" </span><span class="cov8" title="1">{
                name += "=" + cfg.Note
        }</span>
        <span class="cov8" title="1">return name + ".zip"</span>
}

// ARCH-001: Full archive naming implementation
// IMMUTABLE-REF: Archive Naming Convention
// TEST-REF: TestGenerateArchiveName
// DECISION-REF: DEC-001
// generateFullArchiveNameFromConfig generates name for full archives from config
func generateFullArchiveNameFromConfig(cfg ArchiveNameConfig) string <span class="cov8" title="1">{
        var name string
        if cfg.Prefix != "" </span><span class="cov8" title="1">{
                name = cfg.Prefix + "-" + cfg.Timestamp
        }</span> else<span class="cov8" title="1"> {
                name = cfg.Timestamp
        }</span>

        <span class="cov8" title="1">if cfg.IsGit &amp;&amp; cfg.GitBranch != "" &amp;&amp; cfg.GitHash != "" </span><span class="cov8" title="1">{
                name += "=" + cfg.GitBranch + "=" + cfg.GitHash
                if !cfg.GitIsClean &amp;&amp; cfg.ShowGitDirtyStatus </span><span class="cov0" title="0">{
                        name += "-dirty"
                }</span>
        }

        <span class="cov8" title="1">if cfg.Note != "" </span><span class="cov8" title="1">{
                name += "=" + cfg.Note
        }</span>

        <span class="cov8" title="1">return name + ".zip"</span>
}

// ARCH-001: Archive naming with Git integration
// GIT-001: Git information extraction for naming
// GIT-003: Git status detection for naming
// IMMUTABLE-REF: Archive Naming Convention, Git Integration Requirements
// TEST-REF: TestGenerateArchiveName
// DECISION-REF: DEC-001
// generateFullArchiveName generates the name for a full archive.
func generateFullArchiveName(cfg *Config, cwd, note string) (string, error) <span class="cov8" title="1">{
        isGit := IsGitRepository(cwd)
        gitBranch, gitHash, gitIsClean := "", "", false
        if isGit &amp;&amp; cfg.IncludeGitInfo </span><span class="cov0" title="0">{
                gitBranch, gitHash, gitIsClean = GetGitInfoWithStatus(cwd)
        }</span>

        <span class="cov8" title="1">timestamp := time.Now().Format("2006-01-02-15-04")
        prefix := ""
        if cfg.UseCurrentDirName </span><span class="cov8" title="1">{
                prefix = filepath.Base(cwd)
        }</span>

        <span class="cov8" title="1">nameCfg := ArchiveNameConfig{
                Prefix:             prefix,
                Timestamp:          timestamp,
                GitBranch:          gitBranch,
                GitHash:            gitHash,
                GitIsClean:         gitIsClean,
                ShowGitDirtyStatus: cfg.ShowGitDirtyStatus,
                Note:               note,
                IsGit:              isGit &amp;&amp; cfg.IncludeGitInfo,
                IsIncremental:      false,
        }

        return GenerateArchiveName(nameCfg), nil</span>
}

// ARCH-002: Archive listing implementation
// IMMUTABLE-REF: Commands - List Archives
// TEST-REF: TestListArchives
// DECISION-REF: DEC-001
// ListArchives lists all archives in the archive directory for the current source.
// It returns a slice of Archive structs containing metadata for each archive found.
func ListArchives(archiveDir string) ([]Archive, error) <span class="cov8" title="1">{
        if err := os.MkdirAll(archiveDir, 0o755); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to create archive directory: %w", err)
        }</span>

        <span class="cov8" title="1">var archives []Archive
        dirEntries, err := os.ReadDir(archiveDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, entry := range dirEntries </span><span class="cov8" title="1">{
                if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".zip") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">archive, err := createArchiveFromEntry(archiveDir, entry)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span> // Skip entries we can't process
                }
                <span class="cov8" title="1">archives = append(archives, archive)</span>
        }
        <span class="cov8" title="1">return archives, nil</span>
}

// ARCH-002: Archive metadata extraction
// IMMUTABLE-REF: Archive Naming Convention
// TEST-REF: TestListArchives
// DECISION-REF: DEC-001
// createArchiveFromEntry creates an Archive from a directory entry.
func createArchiveFromEntry(archiveDir string, entry os.DirEntry) (Archive, error) <span class="cov8" title="1">{
        archivePath := filepath.Join(archiveDir, entry.Name())
        fileInfo, err := entry.Info()
        if err != nil </span><span class="cov0" title="0">{
                return Archive{}, err
        }</span>

        <span class="cov8" title="1">archive := Archive{
                Name:          entry.Name(),
                Path:          archivePath,
                IsIncremental: strings.Contains(entry.Name(), "_update="),
                CreationTime:  fileInfo.ModTime(),
        }

        // Load verification status if available
        status, err := LoadVerificationStatus(&amp;archive)
        if err == nil &amp;&amp; status != nil </span><span class="cov0" title="0">{
                archive.VerificationStatus = status
        }</span>

        <span class="cov8" title="1">return archive, nil</span>
}

// ARCH-002: Archive creation with context
// IMMUTABLE-REF: Commands - Create Archive
// TEST-REF: TestCreateFullArchive
// DECISION-REF: DEC-001
// CreateArchiveWithContext creates a new archive with the given configuration and note.
// It supports both dry-run mode and verification of the created archive.
func CreateArchiveWithContext(ctx context.Context, cfg *Config, note string, dryRun bool, verify bool) error <span class="cov0" title="0">{
        return CreateFullArchiveWithContext(ctx, cfg, note, dryRun, verify)
}</span>

// ARCH-002: File collection for archiving
// IMMUTABLE-REF: Directory Operations, File Exclusion Requirements
// TEST-REF: TestCreateFullArchive
// DECISION-REF: DEC-001
// collectFilesToArchive walks the directory and collects files to archive
func collectFilesToArchive(ctx context.Context, cwd string, excludePatterns []string) ([]string, error) <span class="cov8" title="1">{
        var files []string
        err := filepath.Walk(cwd, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err := checkContextCancellation(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">rel, err := filepath.Rel(cwd, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if rel == "." || info.IsDir() || ShouldExcludeFile(rel, excludePatterns) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">files = append(files, rel)
                return nil</span>
        })
        <span class="cov8" title="1">return files, err</span>
}

// checkContextCancellation checks if the context has been cancelled.
func checkContextCancellation(ctx context.Context) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-ctx.Done():<span class="cov0" title="0">
                return ctx.Err()</span>
        default:<span class="cov8" title="1">
                return nil</span>
        }
}

// CreateFullArchiveWithContext creates a full archive with context support
func CreateFullArchiveWithContext(ctx context.Context, cfg *Config, note string, dryRun bool, verify bool) error <span class="cov8" title="1">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to get current directory", cfg.StatusDirectoryNotFound, err)
        }</span>

        <span class="cov8" title="1">if err := checkContextCancellation(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := ValidateDirectoryPath(cwd, cfg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">rm := NewResourceManager()
        defer rm.CleanupWithPanicRecovery()

        archiveDir, err := prepareArchiveDirectory(cfg, cwd, dryRun)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">files, err := collectFilesToArchive(ctx, cwd, cfg.ExcludePatterns)
        if err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to scan directory", 1, err)
        }</span>

        <span class="cov8" title="1">archiveName, err := generateFullArchiveName(cfg, cwd, note)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">archivePath := filepath.Join(archiveDir, archiveName)

        if dryRun </span><span class="cov8" title="1">{
                printDryRunInfo(files, archivePath, cfg)
                return nil
        }</span>

        <span class="cov8" title="1">return createAndVerifyArchive(ArchiveCreationConfig{
                Context:     ctx,
                CWD:         cwd,
                Path:        archivePath,
                Files:       files,
                Config:      cfg,
                Verify:      verify,
                ResourceMgr: rm,
        })</span>
}

// prepareArchiveDirectory prepares the archive directory.
func prepareArchiveDirectory(cfg *Config, cwd string, dryRun bool) (string, error) <span class="cov8" title="1">{
        archiveDir := cfg.ArchiveDirPath
        if cfg.UseCurrentDirName </span><span class="cov8" title="1">{
                archiveDir = filepath.Join(archiveDir, filepath.Base(cwd))
        }</span>
        <span class="cov8" title="1">if !dryRun </span><span class="cov8" title="1">{
                if err := SafeMkdirAll(archiveDir, 0755, cfg); err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov8" title="1">return archiveDir, nil</span>
}

// printDryRunInfo prints information about what would be archived.
func printDryRunInfo(files []string, archivePath string, cfg *Config) <span class="cov8" title="1">{
        formatter := NewOutputFormatter(cfg)
        formatter.PrintDryRunFilesHeader()
        for _, f := range files </span><span class="cov8" title="1">{
                formatter.PrintDryRunFileEntry(f)
        }</span>
        <span class="cov8" title="1">formatter.PrintDryRunArchive(archivePath)</span>
}

// createAndVerifyArchive creates and verifies an archive.
func createAndVerifyArchive(cfg ArchiveCreationConfig) error <span class="cov8" title="1">{
        tempFile := cfg.Path + ".tmp"
        cfg.ResourceMgr.AddTempFile(tempFile)

        if err := createZipArchiveWithContext(cfg.Context, cfg.CWD, tempFile, cfg.Files); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause(
                        "Failed to create archive",
                        cfg.Config.StatusDiskFull,
                        err,
                )
        }</span>

        <span class="cov8" title="1">if err := os.Rename(tempFile, cfg.Path); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause(
                        "Failed to finalize archive",
                        cfg.Config.StatusDiskFull,
                        err,
                )
        }</span>

        <span class="cov8" title="1">cfg.ResourceMgr.RemoveResource(&amp;TempFile{Path: tempFile})

        if cfg.Verify </span><span class="cov0" title="0">{
                verifyCfg := ArchiveVerificationConfig{
                        Path:   cfg.Path,
                        Config: cfg.Config,
                }
                return verifyArchive(verifyCfg)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// verifyArchive verifies an archive.
func verifyArchive(cfg ArchiveVerificationConfig) error <span class="cov0" title="0">{
        status, err := VerifyArchive(cfg.Path)
        if err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause(
                        "Archive verification failed",
                        cfg.Config.StatusConfigError,
                        err,
                )
        }</span>
        <span class="cov0" title="0">if !status.IsVerified </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause(
                        "Archive verification failed",
                        cfg.Config.StatusConfigError,
                        fmt.Errorf("verification errors: %v", status.Errors),
                )
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// CreateFullArchive creates a full archive without context (backward compatibility)
func CreateFullArchive(cfg *Config, note string, dryRun bool, verify bool) error <span class="cov8" title="1">{
        return CreateFullArchiveWithContext(context.Background(), cfg, note, dryRun, verify)
}</span>

// CreateFullArchiveWithCleanup creates a full archive with enhanced resource cleanup
func CreateFullArchiveWithCleanup(cfg *Config, note string, dryRun bool, verify bool) error <span class="cov0" title="0">{
        return CreateFullArchiveWithContext(context.Background(), cfg, note, dryRun, verify)
}</span>

// IncrementalArchiveConfig holds configuration for creating incremental archives
type IncrementalArchiveConfig struct {
        Config  *Config
        Note    string
        DryRun  bool
        Verify  bool
        Context context.Context
}

// CreateIncrementalArchive creates an incremental archive without context (backward compatibility)
func CreateIncrementalArchive(cfg *Config, note string, dryRun bool, verify bool) error <span class="cov8" title="1">{
        config := IncrementalArchiveConfig{
                Config:  cfg,
                Note:    note,
                DryRun:  dryRun,
                Verify:  verify,
                Context: context.Background(),
        }
        return createIncrementalArchive(config)
}</span>

// createIncrementalArchive is the core implementation for incremental archive creation
func createIncrementalArchive(config IncrementalArchiveConfig) error <span class="cov8" title="1">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">archiveDir, err := prepareArchiveDirectory(config.Config, cwd, config.DryRun)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">latestFullArchive, err := findLatestFullArchive(archiveDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">modifiedFiles, err := collectModifiedFiles(cwd, latestFullArchive, config.Config.ExcludePatterns)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(modifiedFiles) == 0 </span><span class="cov8" title="1">{
                formatter := NewOutputFormatter(config.Config)
                formatter.PrintNoFilesModified()
                return nil
        }</span>

        <span class="cov8" title="1">archivePath, err := prepareIncrementalArchive(
                cwd, latestFullArchive, config.Config, config.Note)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if config.DryRun </span><span class="cov0" title="0">{
                printDryRunInfo(modifiedFiles, archivePath, config.Config)
                return nil
        }</span>

        <span class="cov8" title="1">return createAndVerifyIncrementalArchive(ArchiveCreationConfig{
                Context: config.Context,
                CWD:     cwd,
                Path:    archivePath,
                Files:   modifiedFiles,
                Config:  config.Config,
                Verify:  config.Verify,
        })</span>
}

// collectModifiedFiles collects files modified since the last full archive
func collectModifiedFiles(cwd string, latestFullArchive *Archive, excludePatterns []string) ([]string, error) <span class="cov8" title="1">{
        latestFullInfo, err := os.Stat(latestFullArchive.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">latestFullTime := latestFullInfo.ModTime()

        var modifiedFiles []string
        err = filepath.Walk(cwd, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">rel, err := filepath.Rel(cwd, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if rel == "." </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">if ShouldExcludeFile(rel, excludePatterns) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">if info.ModTime().After(latestFullTime) </span><span class="cov8" title="1">{
                        modifiedFiles = append(modifiedFiles, rel)
                }</span>
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return modifiedFiles, err</span>
}

// prepareIncrementalArchive prepares the archive name and path
func prepareIncrementalArchive(
        cwd string, latestFullArchive *Archive, cfg *Config, note string) (string, error) <span class="cov8" title="1">{
        isGit := IsGitRepository(cwd)
        gitBranch, gitHash, gitIsClean := "", "", false
        if isGit &amp;&amp; cfg.IncludeGitInfo </span><span class="cov0" title="0">{
                gitBranch, gitHash, gitIsClean = GetGitInfoWithStatus(cwd)
        }</span>

        <span class="cov8" title="1">timestamp := time.Now().Format("2006-01-02-15-04")
        nameCfg := ArchiveNameConfig{
                Prefix:             "",
                Timestamp:          timestamp,
                GitBranch:          gitBranch,
                GitHash:            gitHash,
                GitIsClean:         gitIsClean,
                ShowGitDirtyStatus: cfg.ShowGitDirtyStatus,
                Note:               note,
                IsGit:              isGit &amp;&amp; cfg.IncludeGitInfo,
                IsIncremental:      true,
                BaseName:           latestFullArchive.Name,
        }
        archiveName := GenerateArchiveName(nameCfg)
        archivePath := filepath.Join(cfg.ArchiveDirPath, archiveName)
        return archivePath, nil</span>
}

// createAndVerifyIncrementalArchive creates and verifies an incremental archive
func createAndVerifyIncrementalArchive(cfg ArchiveCreationConfig) error <span class="cov8" title="1">{
        if err := createZipArchiveWithContext(cfg.Context, cfg.CWD, cfg.Path, cfg.Files); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause(
                        "Failed to create archive",
                        cfg.Config.StatusDiskFull,
                        err,
                )
        }</span>

        <span class="cov8" title="1">if cfg.Verify || cfg.Config.Verification.VerifyOnCreate </span><span class="cov0" title="0">{
                verifyCfg := ArchiveVerificationConfig{
                        Path:   cfg.Path,
                        Config: cfg.Config,
                }
                if err := verifyArchive(verifyCfg); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">formatter := NewOutputFormatter(cfg.Config)
        formatter.PrintIncrementalCreated(cfg.Path)
        return nil</span>
}

// CreateIncrementalArchiveWithContext creates an incremental archive with context support
func CreateIncrementalArchiveWithContext(
        ctx context.Context, cfg *Config, note string, dryRun bool, verify bool) error <span class="cov8" title="1">{
        config := IncrementalArchiveConfig{
                Config:  cfg,
                Note:    note,
                DryRun:  dryRun,
                Verify:  verify,
                Context: ctx,
        }
        return createIncrementalArchive(config)
}</span>

// createZipArchiveWithContext creates a ZIP archive with context cancellation support
func createZipArchiveWithContext(ctx context.Context, sourceDir, archivePath string, files []string) error <span class="cov8" title="1">{
        if err := checkContextCancellation(ctx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">f, err := os.Create(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        zipw := zip.NewWriter(f)
        defer zipw.Close()

        return addFilesToZip(ctx, sourceDir, files, zipw)</span>
}

// addFilesToZip adds files to a zip archive
func addFilesToZip(ctx context.Context, sourceDir string, files []string, zipw *zip.Writer) error <span class="cov8" title="1">{
        for _, rel := range files </span><span class="cov8" title="1">{
                if err := checkContextCancellation(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := addFileToZip(sourceDir, rel, zipw); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// addFileToZip adds a single file to a zip archive
func addFileToZip(sourceDir, rel string, zipw *zip.Writer) error <span class="cov8" title="1">{
        abs := filepath.Join(sourceDir, rel)
        info, err := os.Lstat(abs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">hdr, err := zip.FileInfoHeader(info)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">hdr.Name = rel
        hdr.Method = zip.Deflate
        w, err := zipw.CreateHeader(hdr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                rf, err := os.Open(abs)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">_, err = io.Copy(w, rf)
                rf.Close()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// findLatestFullArchive finds the most recent full archive in the archive directory.
func findLatestFullArchive(archiveDir string) (*Archive, error) <span class="cov8" title="1">{
        archives, err := ListArchives(archiveDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(archives) == 0 </span><span class="cov0" title="0">{
                return nil, NewArchiveError("No archives found", 1)
        }</span>

        // Find the most recent full archive
        <span class="cov8" title="1">var latestFullArchive *Archive
        for i := len(archives) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if !archives[i].IsIncremental </span><span class="cov8" title="1">{
                        latestFullArchive = &amp;archives[i]
                        break</span>
                }
        }
        <span class="cov8" title="1">if latestFullArchive == nil </span><span class="cov0" title="0">{
                return nil, NewArchiveError("No full archive found", 1)
        }</span>

        // Get the modification time of the latest full archive
        <span class="cov8" title="1">latestFullInfo, err := os.Stat(latestFullArchive.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewArchiveErrorWithCause(
                        "Failed to stat latest full archive",
                        1,
                        err,
                )
        }</span>
        <span class="cov8" title="1">latestFullArchive.CreationTime = latestFullInfo.ModTime()

        return latestFullArchive, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// This file is part of bkpdir
//
// Package main provides file backup functionality for BkpDir.
// It handles individual file backup creation, comparison, and management.
package main

import (
        "context"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "time"
)

// BackupInfo represents information about a file backup
type BackupInfo struct {
        Name         string
        Path         string
        CreationTime time.Time
        Size         int64
}

// Backup represents a single file backup with metadata
type Backup struct {
        Name         string
        Path         string
        CreationTime time.Time
        SourceFile   string
        Note         string
}

// BackupOptions holds parameters for backup creation functions
type BackupOptions struct {
        Context   context.Context
        Config    *Config
        Formatter *OutputFormatter
        FilePath  string
        Note      string
        DryRun    bool
}

// FILE-002: Structured error handling for backup operations
// IMMUTABLE-REF: Error Handling Requirements
// TEST-REF: TestCreateFileBackup
// DECISION-REF: DEC-004
// BackupError represents a structured error with status code for backup operations
type BackupError struct {
        Message    string
        StatusCode int
        Operation  string
        Path       string
        Err        error
}

func (e *BackupError) Error() string <span class="cov0" title="0">{
        if e.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s: %v", e.Message, e.Err)
        }</span>
        <span class="cov0" title="0">return e.Message</span>
}

func (e *BackupError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// FILE-002: Backup error creation
// IMMUTABLE-REF: Error Handling Requirements
// TEST-REF: TestCreateFileBackup
// DECISION-REF: DEC-004
// NewBackupError creates a new structured backup error
func NewBackupError(message string, statusCode int, operation, path string) *BackupError <span class="cov0" title="0">{
        return &amp;BackupError{
                Message:    message,
                StatusCode: statusCode,
                Operation:  operation,
                Path:       path,
        }
}</span>

// FILE-002: Backup error creation with cause
// IMMUTABLE-REF: Error Handling Requirements
// TEST-REF: TestCreateFileBackup
// DECISION-REF: DEC-004
// NewBackupErrorWithCause creates a new structured backup error with underlying cause
func NewBackupErrorWithCause(message string, statusCode int, operation, path string, err error) *BackupError <span class="cov0" title="0">{
        return &amp;BackupError{
                Message:    message,
                StatusCode: statusCode,
                Operation:  operation,
                Path:       path,
                Err:        err,
        }
}</span>

// FILE-002: File backup creation implementation
// IMMUTABLE-REF: Commands - Create File Backup, File Backup Operations
// TEST-REF: TestCreateFileBackup
// DECISION-REF: DEC-002
// CreateFileBackup creates a backup of a single file
func CreateFileBackup(cfg *Config, filePath string, note string, dryRun bool) error <span class="cov8" title="1">{
        opts := BackupOptions{
                Context:   context.Background(),
                Config:    cfg,
                Formatter: nil,
                FilePath:  filePath,
                Note:      note,
                DryRun:    dryRun,
        }
        return createFileBackupInternal(opts)
}</span>

// FILE-002: Core backup logic implementation
// IMMUTABLE-REF: File Backup Operations, Atomic Operations
// TEST-REF: TestCreateFileBackup
// DECISION-REF: DEC-002
// createFileBackupInternal handles the core backup logic
func createFileBackupInternal(opts BackupOptions) error <span class="cov8" title="1">{
        // Validate file
        if err := validateFileForBackup(opts.FilePath, opts.Config); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Generate backup path
        <span class="cov8" title="1">backupPath, err := generateBackupPath(opts.Config, opts.FilePath, opts.Note)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if opts.DryRun </span><span class="cov0" title="0">{
                return handleDryRunBackup(opts.Formatter, backupPath)
        }</span>

        <span class="cov8" title="1">return performBackupOperation(opts, backupPath)</span>
}

// FILE-001: Backup path generation implementation
// IMMUTABLE-REF: File Backup Naming Convention
// TEST-REF: TestGenerateBackupName
// DECISION-REF: DEC-002
// generateBackupPath creates the full backup path including note
func generateBackupPath(cfg *Config, filePath, note string) (string, error) <span class="cov8" title="1">{
        backupPath, err := determineBackupPath(cfg, filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if note != "" </span><span class="cov8" title="1">{
                backupPath += "=" + note
        }</span>

        <span class="cov8" title="1">return backupPath, nil</span>
}

// CFG-003: Dry run output formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestCreateFileBackup
// DECISION-REF: DEC-003
// handleDryRunBackup handles dry run mode output
func handleDryRunBackup(formatter *OutputFormatter, backupPath string) error <span class="cov0" title="0">{
        if formatter != nil </span><span class="cov0" title="0">{
                formatter.PrintDryRunBackup(backupPath)
        }</span> else<span class="cov0" title="0"> {
                // Fallback for legacy code paths
                cfg := DefaultConfig()
                fallbackFormatter := NewOutputFormatter(cfg)
                fallbackFormatter.PrintBackupWouldCreate(backupPath)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// FILE-002: Backup operation coordination
// IMMUTABLE-REF: File Backup Operations, Atomic Operations
// TEST-REF: TestCreateFileBackup
// DECISION-REF: DEC-002
// performBackupOperation performs the actual backup operation
func performBackupOperation(opts BackupOptions, backupPath string) error <span class="cov8" title="1">{
        backupDir := filepath.Dir(backupPath)
        baseFilename := filepath.Base(opts.FilePath)

        // Check for identical backup
        if err := checkAndHandleIdenticalBackup(opts, backupDir, baseFilename); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create backup directory
        <span class="cov8" title="1">if err := SafeMkdirAll(backupDir, 0755, opts.Config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return executeBackupWithCleanup(opts, backupPath)</span>
}

// FILE-003: Identical file backup detection
// IMMUTABLE-REF: File Backup Operations, Identical File Detection
// TEST-REF: TestCheckForIdenticalFileBackup
// DECISION-REF: DEC-002
// checkAndHandleIdenticalBackup checks if file is identical to existing backup
func checkAndHandleIdenticalBackup(opts BackupOptions, backupDir, baseFilename string) error <span class="cov8" title="1">{
        identical, existingBackup, err := CheckForIdenticalFileBackup(opts.FilePath, backupDir, baseFilename)
        if err == nil &amp;&amp; identical </span><span class="cov0" title="0">{
                if opts.Formatter != nil </span><span class="cov0" title="0">{
                        opts.Formatter.PrintIdenticalBackup(existingBackup)
                }</span> else<span class="cov0" title="0"> {
                        // Fallback for legacy code paths
                        cfg := DefaultConfig()
                        fallbackFormatter := NewOutputFormatter(cfg)
                        fallbackFormatter.PrintBackupIdentical(existingBackup)
                }</span>
                <span class="cov0" title="0">os.Exit(opts.Config.StatusFileIsIdenticalToExistingBackup)</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// FILE-002: Atomic backup execution with cleanup
// IMMUTABLE-REF: File Backup Operations, Atomic Operations, Resource Cleanup
// TEST-REF: TestCreateFileBackupWithCleanup
// DECISION-REF: DEC-002
// executeBackupWithCleanup performs backup with resource cleanup
func executeBackupWithCleanup(opts BackupOptions, backupPath string) error <span class="cov8" title="1">{
        // Create resource manager for cleanup
        rm := NewResourceManager()
        defer rm.CleanupWithPanicRecovery()

        // Create temporary file for atomic operation
        tempFile := backupPath + ".tmp"
        rm.AddTempFile(tempFile)

        // Copy file to backup location
        if err := copyFile(opts.FilePath, tempFile); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to create backup", opts.Config.StatusDiskFull, err)
        }</span>

        // Atomic rename
        <span class="cov8" title="1">if err := os.Rename(tempFile, backupPath); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to finalize backup", opts.Config.StatusDiskFull, err)
        }</span>

        // Remove from cleanup list since operation succeeded
        <span class="cov8" title="1">rm.RemoveResource(&amp;TempFile{Path: tempFile})

        // Create formatter for output (fallback since this function doesn't have direct access to opts.Formatter)
        formatter := NewOutputFormatter(opts.Config)
        formatter.PrintBackupCreated(backupPath)
        return nil</span>
}

// CreateFileBackupEnhanced creates a backup with enhanced error handling and formatting
func CreateFileBackupEnhanced(opts BackupOptions) error <span class="cov0" title="0">{
        return createFileBackupInternal(opts)
}</span>

// CheckForIdenticalFileBackup checks if the file is identical to the most recent backup
func CheckForIdenticalFileBackup(filePath, backupDir, baseFilename string) (bool, string, error) <span class="cov8" title="1">{
        // Find most recent backup for this file
        backups, err := ListFileBackups(backupDir, baseFilename)
        if err != nil || len(backups) == 0 </span><span class="cov8" title="1">{
                return false, "", err
        }</span>

        // Get the most recent backup
        <span class="cov8" title="1">mostRecent := backups[0]

        // Compare file sizes first (quick check)
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        <span class="cov8" title="1">backupInfo, err := os.Stat(mostRecent.Path)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        <span class="cov8" title="1">if fileInfo.Size() != backupInfo.Size() </span><span class="cov0" title="0">{
                return false, "", nil
        }</span>

        // Compare file contents
        <span class="cov8" title="1">identical, err := compareFiles(filePath, mostRecent.Path)
        if err != nil </span><span class="cov8" title="1">{
                return false, "", err
        }</span>

        <span class="cov8" title="1">return identical, mostRecent.Path, nil</span>
}

// ListFileBackups lists all backups for a specific file
func ListFileBackups(backupDir, baseFilename string) ([]BackupInfo, error) <span class="cov8" title="1">{
        var backups []BackupInfo

        if _, err := os.Stat(backupDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return backups, nil
        }</span>

        <span class="cov8" title="1">entries, err := os.ReadDir(backupDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">prefix := baseFilename + "-"
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">name := entry.Name()
                if !strings.HasPrefix(name, prefix) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">info, err := entry.Info()
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">backupPath := filepath.Join(backupDir, name)
                backup := BackupInfo{
                        Name:         name,
                        Path:         backupPath,
                        CreationTime: info.ModTime(),
                        Size:         info.Size(),
                }

                backups = append(backups, backup)</span>
        }

        // Sort by creation time (most recent first)
        <span class="cov8" title="1">for i := 0; i &lt; len(backups)-1; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; len(backups); j++ </span><span class="cov8" title="1">{
                        if backups[i].CreationTime.Before(backups[j].CreationTime) </span><span class="cov8" title="1">{
                                backups[i], backups[j] = backups[j], backups[i]
                        }</span>
                }
        }

        <span class="cov8" title="1">return backups, nil</span>
}

// ListFileBackupsEnhanced lists backups with enhanced formatting
func ListFileBackupsEnhanced(cfg *Config, formatter *OutputFormatter, filePath string) error <span class="cov0" title="0">{
        baseFilename := filepath.Base(filePath)

        backupDir := cfg.BackupDirPath
        if cfg.UseCurrentDirNameForFiles </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return NewArchiveErrorWithCause("Failed to get current directory", cfg.StatusDirectoryNotFound, err)
                }</span>

                // Maintain directory structure in backup path
                <span class="cov0" title="0">relPath, err := filepath.Rel(cwd, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        // If we can't get relative path, use absolute path structure
                        relPath = strings.TrimPrefix(filePath, "/")
                }</span>

                <span class="cov0" title="0">backupDir = filepath.Join(backupDir, filepath.Dir(relPath))</span>
        }

        <span class="cov0" title="0">backups, err := ListFileBackups(backupDir, baseFilename)
        if err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to list backups", 1, err)
        }</span>

        <span class="cov0" title="0">if len(backups) == 0 </span><span class="cov0" title="0">{
                formatter.PrintNoBackupsFound(baseFilename, backupDir)
                return nil
        }</span>

        <span class="cov0" title="0">for _, backup := range backups </span><span class="cov0" title="0">{
                creationTime := backup.CreationTime.Format("2006-01-02 15:04:05")
                output := formatter.FormatListBackupWithExtraction(backup.Path, creationTime)
                fmt.Print(output)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error <span class="cov8" title="1">{
        sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer sourceFile.Close()

        destFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer destFile.Close()

        _, err = io.Copy(destFile, sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Copy file permissions
        <span class="cov8" title="1">sourceInfo, err := os.Stat(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return os.Chmod(dst, sourceInfo.Mode())</span>
}

// compareFiles compares two files byte by byte with simplified logic
func compareFiles(file1, file2 string) (bool, error) <span class="cov8" title="1">{
        f1, err := os.Open(file1)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer f1.Close()

        f2, err := os.Open(file2)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>
        <span class="cov8" title="1">defer f2.Close()

        return compareFileContents(f1, f2)</span>
}

// compareFileContents compares the contents of two open files
func compareFileContents(f1, f2 *os.File) (bool, error) <span class="cov8" title="1">{
        buf1 := make([]byte, 4096)
        buf2 := make([]byte, 4096)

        for </span><span class="cov8" title="1">{
                n1, err1 := f1.Read(buf1)
                n2, err2 := f2.Read(buf2)

                if n1 != n2 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                // Handle end of file cases
                <span class="cov8" title="1">if err1 != nil || err2 != nil </span><span class="cov8" title="1">{
                        return handleFileComparisonErrors(err1, err2)
                }</span>

                // Compare buffer contents
                <span class="cov8" title="1">if !compareBuffers(buf1[:n1], buf2[:n2]) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
        }
}

// handleFileComparisonErrors handles EOF and other errors during file comparison
func handleFileComparisonErrors(err1, err2 error) (bool, error) <span class="cov8" title="1">{
        if err1 == io.EOF &amp;&amp; err2 == io.EOF </span><span class="cov8" title="1">{
                return true, nil
        }</span>
        <span class="cov0" title="0">if err1 != nil </span><span class="cov0" title="0">{
                return false, err1
        }</span>
        <span class="cov0" title="0">return false, err2</span>
}

// compareBuffers compares two byte slices
func compareBuffers(buf1, buf2 []byte) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(buf1); i++ </span><span class="cov8" title="1">{
                if buf1[i] != buf2[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// validateFileForBackup checks if the file exists and is a regular file
func validateFileForBackup(filePath string, cfg *Config) error <span class="cov8" title="1">{
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return NewArchiveError("File not found", cfg.StatusFileNotFound)
                }</span>
                <span class="cov0" title="0">return NewArchiveErrorWithCause("Failed to access file", cfg.StatusPermissionDenied, err)</span>
        }

        <span class="cov8" title="1">if !fileInfo.Mode().IsRegular() </span><span class="cov8" title="1">{
                return NewArchiveError("Path is not a regular file", cfg.StatusInvalidFileType)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// determineBackupPath determines the backup directory and filename
func determineBackupPath(cfg *Config, filePath string) (string, error) <span class="cov8" title="1">{
        backupDir := cfg.BackupDirPath
        if cfg.UseCurrentDirNameForFiles </span><span class="cov0" title="0">{
                cwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        return "", NewArchiveErrorWithCause("Failed to get current directory", cfg.StatusDirectoryNotFound, err)
                }</span>

                // Maintain directory structure in backup path
                <span class="cov0" title="0">relPath, err := filepath.Rel(cwd, filePath)
                if err != nil </span><span class="cov0" title="0">{
                        // If we can't get relative path, use absolute path structure
                        relPath = strings.TrimPrefix(filePath, "/")
                }</span>

                <span class="cov0" title="0">backupDir = filepath.Join(backupDir, filepath.Dir(relPath))</span>
        }

        // Generate backup filename
        <span class="cov8" title="1">baseFilename := filepath.Base(filePath)
        timestamp := time.Now().Format("2006-01-02-15-04")
        backupFilename := fmt.Sprintf("%s-%s", baseFilename, timestamp)

        return filepath.Join(backupDir, backupFilename), nil</span>
}

// CreateFileBackupWithContext creates a backup with context support for cancellation
func CreateFileBackupWithContext(ctx context.Context, cfg *Config, filePath string, note string, dryRun bool) error <span class="cov8" title="1">{
        opts := BackupOptions{
                Context:   ctx,
                Config:    cfg,
                Formatter: nil,
                FilePath:  filePath,
                Note:      note,
                DryRun:    dryRun,
        }
        return createFileBackupWithContextInternal(opts)
}</span>

// createFileBackupWithContextInternal handles context-aware backup creation
func createFileBackupWithContextInternal(opts BackupOptions) error <span class="cov8" title="1">{
        // Check for cancellation
        if err := opts.Context.Err(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // Validate file
        <span class="cov8" title="1">if err := validateFileForBackup(opts.FilePath, opts.Config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Generate backup path
        <span class="cov8" title="1">backupPath, err := generateBackupPath(opts.Config, opts.FilePath, opts.Note)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if opts.DryRun </span><span class="cov0" title="0">{
                return handleDryRunBackup(opts.Formatter, backupPath)
        }</span>

        <span class="cov8" title="1">return performContextAwareBackup(opts, backupPath)</span>
}

// performContextAwareBackup performs backup with context cancellation support
func performContextAwareBackup(opts BackupOptions, backupPath string) error <span class="cov8" title="1">{
        backupDir := filepath.Dir(backupPath)
        baseFilename := filepath.Base(opts.FilePath)

        // Check for identical backup
        if err := checkAndHandleIdenticalBackup(opts, backupDir, baseFilename); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Create backup directory
        <span class="cov8" title="1">if err := SafeMkdirAll(backupDir, 0755, opts.Config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return executeContextAwareBackup(opts, backupPath)</span>
}

// executeContextAwareBackup performs the backup with context support
func executeContextAwareBackup(opts BackupOptions, backupPath string) error <span class="cov8" title="1">{
        // Create resource manager for cleanup
        rm := NewResourceManager()
        defer rm.CleanupWithPanicRecovery()

        // Create temporary file for atomic operation
        tempFile := backupPath + ".tmp"
        rm.AddTempFile(tempFile)

        // Copy file to backup location with context
        if err := CopyFileWithContext(opts.Context, opts.FilePath, tempFile); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to create backup", opts.Config.StatusDiskFull, err)
        }</span>

        // Atomic rename
        <span class="cov8" title="1">if err := os.Rename(tempFile, backupPath); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to finalize backup", opts.Config.StatusDiskFull, err)
        }</span>

        // Remove from cleanup list since operation succeeded
        <span class="cov8" title="1">rm.RemoveResource(&amp;TempFile{Path: tempFile})

        // Create formatter for output (fallback since this function doesn't have direct access to opts.Formatter)
        formatter := NewOutputFormatter(opts.Config)
        formatter.PrintBackupCreated(backupPath)
        return nil</span>
}

// CreateFileBackupWithContextAndCleanup creates a backup with context and enhanced cleanup
func CreateFileBackupWithContextAndCleanup(ctx context.Context, cfg *Config, filePath string,
        note string, dryRun bool) error <span class="cov0" title="0">{
        return CreateFileBackupWithContext(ctx, cfg, filePath, note, dryRun)
}</span>

// CopyFileWithContext copies a file with context support for cancellation
func CopyFileWithContext(ctx context.Context, src, dst string) error <span class="cov8" title="1">{
        // Check for cancellation
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sourceFile, err := os.Open(src)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer sourceFile.Close()

        destFile, err := os.Create(dst)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer destFile.Close()

        return copyWithContextChecks(ctx, sourceFile, destFile)</span>
}

// copyWithContextChecks performs the copy operation with periodic context checks
func copyWithContextChecks(ctx context.Context, src, dst *os.File) error <span class="cov8" title="1">{
        buf := make([]byte, 32*1024) // 32KB buffer
        for </span><span class="cov8" title="1">{
                // Check for cancellation
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">n, err := src.Read(buf)
                if n &gt; 0 </span><span class="cov8" title="1">{
                        if _, writeErr := dst.Write(buf[:n]); writeErr != nil </span><span class="cov0" title="0">{
                                return writeErr
                        }</span>
                }

                <span class="cov8" title="1">if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Copy file permissions
        <span class="cov8" title="1">sourceInfo, err := src.Stat()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return dst.Chmod(sourceInfo.Mode())</span>
}

// CopyFile creates exact copy with permissions preserved
func CopyFile(src, dst string) error <span class="cov0" title="0">{
        return CopyFileWithContext(context.Background(), src, dst)
}</span>

// GenerateBackupName generates backup filename with timestamp and note
func GenerateBackupName(sourcePath, timestamp, note string) string <span class="cov8" title="1">{
        baseFilename := filepath.Base(sourcePath)
        backupName := fmt.Sprintf("%s-%s", baseFilename, timestamp)

        if note != "" </span><span class="cov8" title="1">{
                backupName += "=" + note
        }</span>

        <span class="cov8" title="1">return backupName</span>
}

// CreateFileBackupWithCleanup creates a backup with enhanced resource cleanup
func CreateFileBackupWithCleanup(cfg *Config, filePath string, note string, dryRun bool) error <span class="cov0" title="0">{
        return CreateFileBackupWithContext(context.Background(), cfg, filePath, note, dryRun)
}</span>

// CompareFilesWithContext compares two files with context support for cancellation
func CompareFilesWithContext(ctx context.Context, file1, file2 string) (bool, error) <span class="cov0" title="0">{
        // Check for cancellation
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">f1, err := os.Open(file1)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer f1.Close()

        f2, err := os.Open(file2)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">defer f2.Close()

        return compareFileContentsWithContext(ctx, f1, f2)</span>
}

// compareFileContentsWithContext compares the contents of two open files with context
func compareFileContentsWithContext(ctx context.Context, f1, f2 *os.File) (bool, error) <span class="cov0" title="0">{
        buf1 := make([]byte, 4096)
        buf2 := make([]byte, 4096)

        for </span><span class="cov0" title="0">{
                // Check for cancellation
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">n1, err1 := f1.Read(buf1)
                n2, err2 := f2.Read(buf2)

                if n1 != n2 </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                // Handle end of file cases
                <span class="cov0" title="0">if err1 != nil || err2 != nil </span><span class="cov0" title="0">{
                        return handleFileComparisonErrors(err1, err2)
                }</span>

                // Compare buffer contents
                <span class="cov0" title="0">if !compareBuffers(buf1[:n1], buf2[:n2]) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }
}

// ListFileBackupsWithContext lists all backups for a specific file with context support
func ListFileBackupsWithContext(ctx context.Context, backupDir, sourceFile string) ([]*Backup, error) <span class="cov0" title="0">{
        // Check for cancellation
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var backups []*Backup
        baseFilename := filepath.Base(sourceFile)

        if _, err := os.Stat(backupDir); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return backups, nil
        }</span>

        <span class="cov0" title="0">entries, err := os.ReadDir(backupDir)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">backups, err = processBackupEntries(ctx, entries, backupDir, baseFilename, sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Sort by creation time (most recent first)
        <span class="cov0" title="0">sortBackupsByCreationTime(backups)

        return backups, nil</span>
}

// processBackupEntries processes directory entries to create backup objects
func processBackupEntries(
        ctx context.Context,
        entries []os.DirEntry,
        backupDir, baseFilename, sourceFile string,
) ([]*Backup, error) <span class="cov0" title="0">{
        var backups []*Backup
        prefix := baseFilename + "-"

        for _, entry := range entries </span><span class="cov0" title="0">{
                // Check for cancellation
                if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if entry.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">name := entry.Name()
                if !strings.HasPrefix(name, prefix) </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">backup, err := createBackupFromEntry(entry, backupDir, sourceFile)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">backups = append(backups, backup)</span>
        }

        <span class="cov0" title="0">return backups, nil</span>
}

// createBackupFromEntry creates a Backup object from a directory entry
func createBackupFromEntry(entry os.DirEntry, backupDir, sourceFile string) (*Backup, error) <span class="cov0" title="0">{
        info, err := entry.Info()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">name := entry.Name()
        backupPath := filepath.Join(backupDir, name)

        // Extract note from filename if present
        note := ""
        if idx := strings.Index(name, "="); idx != -1 </span><span class="cov0" title="0">{
                note = name[idx+1:]
        }</span>

        <span class="cov0" title="0">backup := &amp;Backup{
                Name:         name,
                Path:         backupPath,
                CreationTime: info.ModTime(),
                SourceFile:   sourceFile,
                Note:         note,
        }

        return backup, nil</span>
}

// sortBackupsByCreationTime sorts backups by creation time (most recent first)
func sortBackupsByCreationTime(backups []*Backup) <span class="cov0" title="0">{
        for i := 0; i &lt; len(backups)-1; i++ </span><span class="cov0" title="0">{
                for j := i + 1; j &lt; len(backups); j++ </span><span class="cov0" title="0">{
                        if backups[i].CreationTime.Before(backups[j].CreationTime) </span><span class="cov0" title="0">{
                                backups[i], backups[j] = backups[j], backups[i]
                        }</span>
                }
        }
}

// GetMostRecentBackup finds the most recent backup for a given file
func GetMostRecentBackup(backupDir, sourceFile string) (*Backup, error) <span class="cov0" title="0">{
        backups, err := ListFileBackupsWithContext(context.Background(), backupDir, sourceFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(backups) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">return backups[0], nil</span> // Already sorted with most recent first
}

// ValidateFileForBackup validates that a file can be backed up (public version)
func ValidateFileForBackup(filePath string) error <span class="cov0" title="0">{
        fileInfo, err := os.Stat(filePath)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return fmt.Errorf("file not found: %s", filePath)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to access file: %v", err)</span>
        }

        <span class="cov0" title="0">if !fileInfo.Mode().IsRegular() </span><span class="cov0" title="0">{
                return fmt.Errorf("path is not a regular file: %s", filePath)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// This file is part of bkpdir
//
// Package main provides directory comparison functionality for the BkpDir application.
// It handles comparing directories to detect changes and identical states.
package main

import (
        "archive/zip"
        "crypto/sha256"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "time"
)

// FileInfo represents information about a file for comparison
type FileInfo struct {
        RelativePath string
        Size         int64
        ModTime      time.Time
        IsDir        bool
        Hash         string // SHA-256 hash for content comparison
}

// DirectorySnapshot represents a snapshot of a directory's contents
type DirectorySnapshot struct {
        Files []FileInfo
}

// CreateDirectorySnapshot creates a snapshot of the given directory
func CreateDirectorySnapshot(rootPath string, excludePatterns []string) (*DirectorySnapshot, error) <span class="cov8" title="1">{
        // ARCH-003: Directory snapshot creation for incremental comparison
        // FILE-003: Directory comparison implementation
        var files []FileInfo

        err := filepath.Walk(rootPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                // Get relative path
                <span class="cov8" title="1">relPath, err := filepath.Rel(rootPath, path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Skip root directory
                <span class="cov8" title="1">if relPath == "." </span><span class="cov8" title="1">{
                        return nil
                }</span>

                // Check exclusion patterns
                <span class="cov8" title="1">if ShouldExcludeFile(relPath, excludePatterns) </span><span class="cov8" title="1">{
                        if info.IsDir() </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">fileInfo := FileInfo{
                        RelativePath: relPath,
                        Size:         info.Size(),
                        ModTime:      info.ModTime(),
                        IsDir:        info.IsDir(),
                }

                // Calculate hash for regular files
                if !info.IsDir() </span><span class="cov8" title="1">{
                        hash, err := calculateFileHash(path)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">fileInfo.Hash = hash</span>
                }

                <span class="cov8" title="1">files = append(files, fileInfo)
                return nil</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Sort files for consistent comparison
        <span class="cov8" title="1">sort.Slice(files, func(i, j int) bool </span><span class="cov8" title="1">{
                return files[i].RelativePath &lt; files[j].RelativePath
        }</span>)

        <span class="cov8" title="1">return &amp;DirectorySnapshot{Files: files}, nil</span>
}

// CreateArchiveSnapshot creates a snapshot from a ZIP archive
func CreateArchiveSnapshot(archivePath string) (*DirectorySnapshot, error) <span class="cov8" title="1">{
        // ARCH-003: Archive snapshot creation for incremental comparison
        // FILE-003: Archive comparison implementation
        // DECISION-REF: DEC-001
        reader, err := zip.OpenReader(archivePath)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        var files []FileInfo

        for _, file := range reader.File </span><span class="cov8" title="1">{
                // Skip directories in ZIP files (they're implicit)
                if strings.HasSuffix(file.Name, "/") </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">fileInfo := FileInfo{
                        RelativePath: file.Name,
                        Size:         int64(file.UncompressedSize64),
                        ModTime:      file.Modified,
                        IsDir:        false,
                }

                // Calculate hash of file content in archive
                hash, err := calculateArchiveFileHash(file)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">fileInfo.Hash = hash

                files = append(files, fileInfo)</span>
        }

        // Sort files for consistent comparison
        <span class="cov8" title="1">sort.Slice(files, func(i, j int) bool </span><span class="cov8" title="1">{
                return files[i].RelativePath &lt; files[j].RelativePath
        }</span>)

        <span class="cov8" title="1">return &amp;DirectorySnapshot{Files: files}, nil</span>
}

// CompareSnapshots compares two directory snapshots
func CompareSnapshots(snapshot1, snapshot2 *DirectorySnapshot) bool <span class="cov8" title="1">{
        // FILE-003: Snapshot comparison implementation
        if len(snapshot1.Files) != len(snapshot2.Files) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for i, file1 := range snapshot1.Files </span><span class="cov8" title="1">{
                file2 := snapshot2.Files[i]

                // Compare basic properties
                if file1.RelativePath != file2.RelativePath ||
                        file1.Size != file2.Size ||
                        file1.IsDir != file2.IsDir </span><span class="cov8" title="1">{
                        return false
                }</span>

                // Compare content hash for regular files
                <span class="cov8" title="1">if !file1.IsDir &amp;&amp; file1.Hash != file2.Hash </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// IsDirectoryIdenticalToArchive checks if a directory is identical to an archive
func IsDirectoryIdenticalToArchive(dirPath, archivePath string, excludePatterns []string) (bool, error) <span class="cov8" title="1">{
        // ARCH-003: Directory-to-archive comparison for incremental detection
        // FILE-003: Identical state detection
        // Create snapshot of directory
        dirSnapshot, err := CreateDirectorySnapshot(dirPath, excludePatterns)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // Create snapshot of archive
        <span class="cov8" title="1">archiveSnapshot, err := CreateArchiveSnapshot(archivePath)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        // Compare snapshots
        <span class="cov8" title="1">return CompareSnapshots(dirSnapshot, archiveSnapshot), nil</span>
}

// FindMostRecentArchive finds the most recent archive in the archive directory
func FindMostRecentArchive(archiveDir string) (string, error) <span class="cov8" title="1">{
        // ARCH-003: Most recent archive detection for incremental comparison
        archives, err := ListArchives(archiveDir)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if len(archives) == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        // Find the most recent archive (archives are already sorted by creation time)
        <span class="cov8" title="1">var mostRecent Archive
        var mostRecentTime time.Time

        for _, archive := range archives </span><span class="cov8" title="1">{
                // Skip incremental archives for this comparison
                if archive.IsIncremental </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Get file modification time
                <span class="cov8" title="1">info, err := os.Stat(archive.Path)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if info.ModTime().After(mostRecentTime) </span><span class="cov8" title="1">{
                        mostRecentTime = info.ModTime()
                        mostRecent = archive
                }</span>
        }

        <span class="cov8" title="1">if mostRecent.Path == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return mostRecent.Path, nil</span>
}

// CheckForIdenticalArchive checks if the directory is identical to the most recent archive
func CheckForIdenticalArchive(dirPath, archiveDir string, excludePatterns []string) (bool, string, error) <span class="cov8" title="1">{
        // ARCH-003: Identical archive detection
        // FILE-003: Duplicate detection logic
        // Find most recent archive
        mostRecentArchive, err := FindMostRecentArchive(archiveDir)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        <span class="cov8" title="1">if mostRecentArchive == "" </span><span class="cov8" title="1">{
                // No archives exist
                return false, "", nil
        }</span>

        // Check if directory is identical to most recent archive
        <span class="cov8" title="1">identical, err := IsDirectoryIdenticalToArchive(dirPath, mostRecentArchive, excludePatterns)
        if err != nil </span><span class="cov0" title="0">{
                return false, "", err
        }</span>

        <span class="cov8" title="1">return identical, mostRecentArchive, nil</span>
}

// Helper function to calculate SHA-256 hash of a file
func calculateFileHash(filePath string) (string, error) <span class="cov8" title="1">{
        // FILE-003: File hash calculation for comparison
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}

// Helper function to calculate SHA-256 hash of a file in a ZIP archive
func calculateArchiveFileHash(file *zip.File) (string, error) <span class="cov8" title="1">{
        // FILE-003: Archive file hash calculation for comparison
        // DECISION-REF: DEC-001
        reader, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, reader); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return fmt.Sprintf("%x", hash.Sum(nil)), nil</span>
}

// GetDirectoryTreeSummary returns a summary of the directory tree for debugging
func GetDirectoryTreeSummary(dirPath string, excludePatterns []string) (string, error) <span class="cov8" title="1">{
        // Directory tree summary generation
        snapshot, err := CreateDirectorySnapshot(dirPath, excludePatterns)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">var summary strings.Builder
        summary.WriteString(fmt.Sprintf("Directory: %s\n", dirPath))
        summary.WriteString(fmt.Sprintf("Files: %d\n", len(snapshot.Files)))

        for _, file := range snapshot.Files </span><span class="cov8" title="1">{
                if file.IsDir </span><span class="cov8" title="1">{
                        summary.WriteString(fmt.Sprintf("  [DIR]  %s\n", file.RelativePath))
                }</span> else<span class="cov8" title="1"> {
                        summary.WriteString(fmt.Sprintf("  [FILE] %s (%d bytes, %s)\n",
                                file.RelativePath, file.Size, file.Hash[:8]))
                }</span>
        }

        <span class="cov8" title="1">return summary.String(), nil</span>
}

// GetArchiveTreeSummary returns a summary of the archive contents for debugging
func GetArchiveTreeSummary(archivePath string) (string, error) <span class="cov8" title="1">{
        // Archive tree summary generation
        // DECISION-REF: DEC-001
        snapshot, err := CreateArchiveSnapshot(archivePath)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">var summary strings.Builder
        summary.WriteString(fmt.Sprintf("Archive: %s\n", archivePath))
        summary.WriteString(fmt.Sprintf("Files: %d\n", len(snapshot.Files)))

        for _, file := range snapshot.Files </span><span class="cov8" title="1">{
                summary.WriteString(fmt.Sprintf("  [FILE] %s (%d bytes, %s)\n",
                        file.RelativePath, file.Size, file.Hash[:8]))
        }</span>

        <span class="cov8" title="1">return summary.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// This file is part of bkpdir
//
// Package main provides configuration loading, merging, and validation for BkpDir.
// It handles loading, merging, and validating configuration from YAML files
// and environment variables.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License
package main

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        yaml "gopkg.in/yaml.v3"
)

// CFG-002: Verification configuration structure
// IMMUTABLE-REF: Archive Verification Requirements
// TEST-REF: TestDefaultConfig
// DECISION-REF: DEC-002
// VerificationConfig defines settings for archive verification.
// It controls whether archives are verified on creation and which checksum algorithm to use.
type VerificationConfig struct {
        VerifyOnCreate    bool   `yaml:"verify_on_create"`
        ChecksumAlgorithm string `yaml:"checksum_algorithm"`
}

// CFG-001: Main configuration structure
// CFG-002: Status code configuration
// CFG-003: Output formatting configuration
// IMMUTABLE-REF: Configuration Defaults, Output Formatting Requirements
// TEST-REF: TestDefaultConfig
// DECISION-REF: DEC-002
// Config holds all configuration settings for the BkpDir application.
// It includes settings for archive creation, file backup, status codes,
// and output formatting.
// The configuration can be loaded from YAML files and environment variables.
type Config struct {
        // Basic settings
        ArchiveDirPath     string              `yaml:"archive_dir_path"`
        UseCurrentDirName  bool                `yaml:"use_current_dir_name"`
        ExcludePatterns    []string            `yaml:"exclude_patterns"`
        IncludeGitInfo     bool                `yaml:"include_git_info"`
        ShowGitDirtyStatus bool                `yaml:"show_git_dirty_status"`
        Verification       *VerificationConfig `yaml:"verification"`

        // File backup settings
        BackupDirPath             string `yaml:"backup_dir_path"`
        UseCurrentDirNameForFiles bool   `yaml:"use_current_dir_name_for_files"`

        // Status codes for directory operations
        StatusCreatedArchive                        int `yaml:"status_created_archive"`
        StatusFailedToCreateArchiveDirectory        int `yaml:"status_failed_to_create_archive_directory"`
        StatusDirectoryIsIdenticalToExistingArchive int `yaml:"status_directory_is_identical_to_existing_archive"`
        StatusDirectoryNotFound                     int `yaml:"status_directory_not_found"`
        StatusInvalidDirectoryType                  int `yaml:"status_invalid_directory_type"`
        StatusPermissionDenied                      int `yaml:"status_permission_denied"`
        StatusDiskFull                              int `yaml:"status_disk_full"`
        StatusConfigError                           int `yaml:"status_config_error"`

        // Status codes for file operations
        StatusCreatedBackup                   int `yaml:"status_created_backup"`
        StatusFailedToCreateBackupDirectory   int `yaml:"status_failed_to_create_backup_directory"`
        StatusFileIsIdenticalToExistingBackup int `yaml:"status_file_is_identical_to_existing_backup"`
        StatusFileNotFound                    int `yaml:"status_file_not_found"`
        StatusInvalidFileType                 int `yaml:"status_invalid_file_type"`

        // Printf-style format strings for directory operations
        FormatCreatedArchive   string `yaml:"format_created_archive"`
        FormatIdenticalArchive string `yaml:"format_identical_archive"`
        FormatListArchive      string `yaml:"format_list_archive"`
        FormatConfigValue      string `yaml:"format_config_value"`
        FormatDryRunArchive    string `yaml:"format_dry_run_archive"`
        FormatError            string `yaml:"format_error"`

        // Printf-style format strings for file operations
        FormatCreatedBackup   string `yaml:"format_created_backup"`
        FormatIdenticalBackup string `yaml:"format_identical_backup"`
        FormatListBackup      string `yaml:"format_list_backup"`
        FormatDryRunBackup    string `yaml:"format_dry_run_backup"`

        // Template-based format strings for directory operations
        TemplateCreatedArchive   string `yaml:"template_created_archive"`
        TemplateIdenticalArchive string `yaml:"template_identical_archive"`
        TemplateListArchive      string `yaml:"template_list_archive"`
        TemplateConfigValue      string `yaml:"template_config_value"`
        TemplateDryRunArchive    string `yaml:"template_dry_run_archive"`
        TemplateError            string `yaml:"template_error"`

        // Template-based format strings for file operations
        TemplateCreatedBackup   string `yaml:"template_created_backup"`
        TemplateIdenticalBackup string `yaml:"template_identical_backup"`
        TemplateListBackup      string `yaml:"template_list_backup"`
        TemplateDryRunBackup    string `yaml:"template_dry_run_backup"`

        // Regex patterns
        PatternArchiveFilename string `yaml:"pattern_archive_filename"`
        PatternBackupFilename  string `yaml:"pattern_backup_filename"`
        PatternConfigLine      string `yaml:"pattern_config_line"`
        PatternTimestamp       string `yaml:"pattern_timestamp"`

        // CFG-004: Extended format strings for comprehensive string configuration
        // Archive operation messages
        FormatNoArchivesFound      string `yaml:"format_no_archives_found"`
        FormatVerificationFailed   string `yaml:"format_verification_failed"`
        FormatVerificationSuccess  string `yaml:"format_verification_success"`
        FormatVerificationWarning  string `yaml:"format_verification_warning"`
        FormatConfigurationUpdated string `yaml:"format_configuration_updated"`
        FormatConfigFilePath       string `yaml:"format_config_file_path"`
        FormatDryRunFilesHeader    string `yaml:"format_dry_run_files_header"`
        FormatDryRunFileEntry      string `yaml:"format_dry_run_file_entry"`
        FormatNoFilesModified      string `yaml:"format_no_files_modified"`
        FormatIncrementalCreated   string `yaml:"format_incremental_created"`

        // Backup operation messages
        FormatNoBackupsFound    string `yaml:"format_no_backups_found"`
        FormatBackupWouldCreate string `yaml:"format_backup_would_create"`
        FormatBackupIdentical   string `yaml:"format_backup_identical"`
        FormatBackupCreated     string `yaml:"format_backup_created"`

        // CFG-004: Error message format strings
        FormatDiskFullError       string `yaml:"format_disk_full_error"`
        FormatPermissionError     string `yaml:"format_permission_error"`
        FormatDirectoryNotFound   string `yaml:"format_directory_not_found"`
        FormatFileNotFound        string `yaml:"format_file_not_found"`
        FormatInvalidDirectory    string `yaml:"format_invalid_directory"`
        FormatInvalidFile         string `yaml:"format_invalid_file"`
        FormatFailedWriteTemp     string `yaml:"format_failed_write_temp"`
        FormatFailedFinalizeFile  string `yaml:"format_failed_finalize_file"`
        FormatFailedCreateDirDisk string `yaml:"format_failed_create_dir_disk"`
        FormatFailedCreateDir     string `yaml:"format_failed_create_dir"`
        FormatFailedAccessDir     string `yaml:"format_failed_access_dir"`
        FormatFailedAccessFile    string `yaml:"format_failed_access_file"`

        // Template-based extended format strings
        TemplateNoArchivesFound      string `yaml:"template_no_archives_found"`
        TemplateVerificationFailed   string `yaml:"template_verification_failed"`
        TemplateVerificationSuccess  string `yaml:"template_verification_success"`
        TemplateVerificationWarning  string `yaml:"template_verification_warning"`
        TemplateConfigurationUpdated string `yaml:"template_configuration_updated"`
        TemplateConfigFilePath       string `yaml:"template_config_file_path"`
        TemplateDryRunFilesHeader    string `yaml:"template_dry_run_files_header"`
        TemplateDryRunFileEntry      string `yaml:"template_dry_run_file_entry"`
        TemplateNoFilesModified      string `yaml:"template_no_files_modified"`
        TemplateIncrementalCreated   string `yaml:"template_incremental_created"`

        // Template-based backup operation messages
        TemplateNoBackupsFound    string `yaml:"template_no_backups_found"`
        TemplateBackupWouldCreate string `yaml:"template_backup_would_create"`
        TemplateBackupIdentical   string `yaml:"template_backup_identical"`
        TemplateBackupCreated     string `yaml:"template_backup_created"`

        // CFG-004: Template-based error message format strings
        TemplateDiskFullError       string `yaml:"template_disk_full_error"`
        TemplatePermissionError     string `yaml:"template_permission_error"`
        TemplateDirectoryNotFound   string `yaml:"template_directory_not_found"`
        TemplateFileNotFound        string `yaml:"template_file_not_found"`
        TemplateInvalidDirectory    string `yaml:"template_invalid_directory"`
        TemplateInvalidFile         string `yaml:"template_invalid_file"`
        TemplateFailedWriteTemp     string `yaml:"template_failed_write_temp"`
        TemplateFailedFinalizeFile  string `yaml:"template_failed_finalize_file"`
        TemplateFailedCreateDirDisk string `yaml:"template_failed_create_dir_disk"`
        TemplateFailedCreateDir     string `yaml:"template_failed_create_dir"`
        TemplateFailedAccessDir     string `yaml:"template_failed_access_dir"`
        TemplateFailedAccessFile    string `yaml:"template_failed_access_file"`
}

// CFG-003: Configuration value representation
// IMMUTABLE-REF: Commands - Display Configuration
// TEST-REF: TestDisplayConfig
// DECISION-REF: DEC-002
// ConfigValue represents a single configuration value with its source.
// It is used for displaying configuration values and their origins.
type ConfigValue struct {
        Name   string
        Value  string
        Source string
}

// CFG-003: Default regex patterns for template extraction
// IMMUTABLE-REF: Template Formatting Requirements, Configuration Defaults
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// Default regex patterns
const (
        defaultArchivePattern = `(?P&lt;prefix&gt;[^-]*)-(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})-` +
                `(?P&lt;hour&gt;\d{2})-(?P&lt;minute&gt;\d{2})(?:=(?P&lt;branch&gt;[^=]+))?(?:=(?P&lt;hash&gt;[^=]+))?(?:=(?P&lt;note&gt;.+))?\.zip`
        defaultBackupPattern = `(?P&lt;filename&gt;[^/]+)-(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})-` +
                `(?P&lt;hour&gt;\d{2})-(?P&lt;minute&gt;\d{2})(?:=(?P&lt;note&gt;.+))?`
        defaultConfigPattern    = `(?P&lt;name&gt;[^:]+):\s*(?P&lt;value&gt;[^(]+)\s*\(source:\s*(?P&lt;source&gt;[^)]+)\)`
        defaultTimestampPattern = `(?P&lt;year&gt;\d{4})-(?P&lt;month&gt;\d{2})-(?P&lt;day&gt;\d{2})\s+` +
                `(?P&lt;hour&gt;\d{2}):(?P&lt;minute&gt;\d{2}):(?P&lt;second&gt;\d{2})`
)

// CFG-001: Default configuration implementation
// CFG-002: Default status codes
// CFG-003: Default format strings and templates
// IMMUTABLE-REF: Configuration Defaults
// TEST-REF: TestDefaultConfig
// DECISION-REF: DEC-002
// DefaultConfig returns a new Config instance with default values.
// These values are used when no configuration is provided or when merging configurations.
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                // Basic settings
                ArchiveDirPath:     "../.bkpdir",
                UseCurrentDirName:  true,
                ExcludePatterns:    []string{".git/", "vendor/"},
                IncludeGitInfo:     false,
                ShowGitDirtyStatus: true,
                Verification: &amp;VerificationConfig{
                        VerifyOnCreate:    false,
                        ChecksumAlgorithm: "sha256",
                },

                // File backup settings
                BackupDirPath:             "../.bkpdir",
                UseCurrentDirNameForFiles: true,

                // Status codes for directory operations
                StatusCreatedArchive:                        0,
                StatusFailedToCreateArchiveDirectory:        31,
                StatusDirectoryIsIdenticalToExistingArchive: 0,
                StatusDirectoryNotFound:                     20,
                StatusInvalidDirectoryType:                  21,
                StatusPermissionDenied:                      22,
                StatusDiskFull:                              30,
                StatusConfigError:                           10,

                // Status codes for file operations
                StatusCreatedBackup:                   0,
                StatusFailedToCreateBackupDirectory:   31,
                StatusFileIsIdenticalToExistingBackup: 0,
                StatusFileNotFound:                    20,
                StatusInvalidFileType:                 21,

                // Printf-style format strings for directory operations
                FormatCreatedArchive:   "Created archive: %s\n",
                FormatIdenticalArchive: "Directory is identical to existing archive: %s\n",
                FormatListArchive:      "%s (created: %s)\n",
                FormatConfigValue:      "%s: %s (source: %s)\n",
                FormatDryRunArchive:    "Would create archive: %s\n",
                FormatError:            "Error: %s\n",

                // Printf-style format strings for file operations
                FormatCreatedBackup:   "Created backup: %s\n",
                FormatIdenticalBackup: "File is identical to existing backup: %s\n",
                FormatListBackup:      "%s (created: %s)\n",
                FormatDryRunBackup:    "Would create backup: %s\n",

                // Template-based format strings for directory operations
                TemplateCreatedArchive:   "Created archive: %{path}\n",
                TemplateIdenticalArchive: "Directory is identical to existing archive: %{path}\n",
                TemplateListArchive:      "%{path} (created: %{creation_time})\n",
                TemplateConfigValue:      "%{name}: %{value} (source: %{source})\n",
                TemplateDryRunArchive:    "Would create archive: %{path}\n",
                TemplateError:            "Error: %{message}\n",

                // Template-based format strings for file operations
                TemplateCreatedBackup:   "Created backup: %{path}\n",
                TemplateIdenticalBackup: "File is identical to existing backup: %{path}\n",
                TemplateListBackup:      "%{path} (created: %{creation_time})\n",
                TemplateDryRunBackup:    "Would create backup: %{path}\n",

                // Regex patterns
                PatternArchiveFilename: defaultArchivePattern,
                PatternBackupFilename:  defaultBackupPattern,
                PatternConfigLine:      defaultConfigPattern,
                PatternTimestamp:       defaultTimestampPattern,

                // CFG-004: Extended format strings for comprehensive string configuration
                // Archive operation messages
                FormatNoArchivesFound:      "No archives found in %s\n",
                FormatVerificationFailed:   "Archive %s verification failed: %v\n",
                FormatVerificationSuccess:  "Archive %s verified successfully\n",
                FormatVerificationWarning:  "Warning: Could not store verification status for %s: %v\n",
                FormatConfigurationUpdated: "Configuration updated: %s = %v\n",
                FormatConfigFilePath:       "Config file: %s\n",
                FormatDryRunFilesHeader:    "[Dry Run] Files to include:\n",
                FormatDryRunFileEntry:      "  %s\n",
                FormatNoFilesModified:      "No files modified since last full archive\n",
                FormatIncrementalCreated:   "Created incremental archive: %s\n",

                // Backup operation messages
                FormatNoBackupsFound:    "No backups found for %s in %s\n",
                FormatBackupWouldCreate: "Would create backup: %s\n",
                FormatBackupIdentical:   "File is identical to existing backup: %s\n",
                FormatBackupCreated:     "Created backup: %s\n",

                // CFG-004: Error message format strings
                FormatDiskFullError:       "Disk full error: %v\n",
                FormatPermissionError:     "Permission error: %v\n",
                FormatDirectoryNotFound:   "Directory not found: %v\n",
                FormatFileNotFound:        "File not found: %v\n",
                FormatInvalidDirectory:    "Invalid directory: %v\n",
                FormatInvalidFile:         "Invalid file: %v\n",
                FormatFailedWriteTemp:     "Failed to write temporary file: %v\n",
                FormatFailedFinalizeFile:  "Failed to finalize file: %v\n",
                FormatFailedCreateDirDisk: "Failed to create directory on disk: %v\n",
                FormatFailedCreateDir:     "Failed to create directory: %v\n",
                FormatFailedAccessDir:     "Failed to access directory: %v\n",
                FormatFailedAccessFile:    "Failed to access file: %v\n",

                // Template-based extended format strings
                TemplateNoArchivesFound:      "No archives found in %{archive_dir}\n",
                TemplateVerificationFailed:   "Archive %{name} verification failed: %{error}\n",
                TemplateVerificationSuccess:  "Archive %{name} verified successfully\n",
                TemplateVerificationWarning:  "Warning: Could not store verification status for %{name}: %{error}\n",
                TemplateConfigurationUpdated: "Configuration updated: %{key} = %{value}\n",
                TemplateConfigFilePath:       "Config file: %{path}\n",
                TemplateDryRunFilesHeader:    "[Dry Run] Files to include:\n",
                TemplateDryRunFileEntry:      "  %{file}\n",
                TemplateNoFilesModified:      "No files modified since last full archive\n",
                TemplateIncrementalCreated:   "Created incremental archive: %{path}\n",

                // Template-based backup operation messages
                TemplateNoBackupsFound:    "No backups found for %{filename} in %{backup_dir}\n",
                TemplateBackupWouldCreate: "Would create backup: %{path}\n",
                TemplateBackupIdentical:   "File is identical to existing backup: %{path}\n",
                TemplateBackupCreated:     "Created backup: %{path}\n",

                // CFG-004: Template-based error message format strings
                TemplateDiskFullError:       "Disk full error: %v\n",
                TemplatePermissionError:     "Permission error: %v\n",
                TemplateDirectoryNotFound:   "Directory not found: %v\n",
                TemplateFileNotFound:        "File not found: %v\n",
                TemplateInvalidDirectory:    "Invalid directory: %v\n",
                TemplateInvalidFile:         "Invalid file: %v\n",
                TemplateFailedWriteTemp:     "Failed to write temporary file: %v\n",
                TemplateFailedFinalizeFile:  "Failed to finalize file: %v\n",
                TemplateFailedCreateDirDisk: "Failed to create directory on disk: %v\n",
                TemplateFailedCreateDir:     "Failed to create directory: %v\n",
                TemplateFailedAccessDir:     "Failed to access directory: %v\n",
                TemplateFailedAccessFile:    "Failed to access file: %v\n",
        }
}</span>

// CFG-001: Configuration search path implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// getConfigSearchPaths returns the list of paths to search for configuration files.
// It includes both system-wide and user-specific configuration paths.
func getConfigSearchPaths() []string <span class="cov8" title="1">{
        // Check BKPDIR_CONFIG environment variable
        if configPaths := os.Getenv("BKPDIR_CONFIG"); configPaths != "" </span><span class="cov8" title="1">{
                return strings.Split(configPaths, ":")
        }</span>

        // Default search path
        <span class="cov8" title="1">return []string{"./.bkpdir.yml", "~/.bkpdir.yml"}</span>
}

// CFG-001: Path expansion implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// expandPath expands a path by replacing special tokens with actual values.
// It handles tokens like ~ for home directory and %ROOT% for the root directory.
func expandPath(path string) string <span class="cov8" title="1">{
        if strings.HasPrefix(path, "~/") </span><span class="cov8" title="1">{
                home, err := os.UserHomeDir()
                if err != nil </span><span class="cov0" title="0">{
                        return path
                }</span>
                <span class="cov8" title="1">return filepath.Join(home, path[2:])</span>
        }
        <span class="cov8" title="1">return path</span>
}

// CFG-001: Configuration loading implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// LoadConfig loads configuration from YAML files and environment variables.
// It searches for configuration files in the standard locations and merges them with defaults.
func LoadConfig(root string) (*Config, error) <span class="cov8" title="1">{
        cfg := DefaultConfig()
        searchPaths := getConfigSearchPaths()

        // Process configuration files in order (earlier files take precedence)
        for _, configPath := range searchPaths </span><span class="cov8" title="1">{
                expandedPath := expandPath(configPath)

                // Make relative paths relative to root directory
                if !filepath.IsAbs(expandedPath) </span><span class="cov8" title="1">{
                        expandedPath = filepath.Join(root, expandedPath)
                }</span>

                <span class="cov8" title="1">if _, err := os.Stat(expandedPath); err == nil </span><span class="cov8" title="1">{
                        f, err := os.Open(expandedPath)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // Skip files we can't open
                        }
                        <span class="cov8" title="1">defer f.Close()

                        // Create a temporary config to load into
                        tempCfg := DefaultConfig()
                        d := yaml.NewDecoder(f)
                        if err := d.Decode(tempCfg); err != nil </span><span class="cov8" title="1">{
                                f.Close()
                                continue</span> // Skip files with invalid YAML
                        }
                        <span class="cov8" title="1">f.Close()

                        // Merge non-zero values from tempCfg into cfg
                        mergeConfigs(cfg, tempCfg)
                        break</span> // Use first valid config file found
                }
        }

        <span class="cov8" title="1">return cfg, nil</span>
}

// CFG-001: Configuration merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeConfigs merges source configuration into destination configuration.
// It preserves non-zero values from the source configuration.
func mergeConfigs(dst, src *Config) <span class="cov8" title="1">{
        mergeBasicSettings(dst, src)
        mergeFileBackupSettings(dst, src)
        mergeStatusCodes(dst, src)
        mergeFormatStrings(dst, src)
        mergeTemplates(dst, src)
        mergePatterns(dst, src)
        mergeExtendedFormatStrings(dst, src)
        mergeExtendedTemplates(dst, src)
}</span>

// CFG-001: Basic settings merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeBasicSettings merges basic configuration settings.
// It handles archive directory path, Git integration, and verification settings.
func mergeBasicSettings(dst, src *Config) <span class="cov8" title="1">{
        if src.ArchiveDirPath != DefaultConfig().ArchiveDirPath </span><span class="cov8" title="1">{
                dst.ArchiveDirPath = src.ArchiveDirPath
        }</span>
        <span class="cov8" title="1">if src.UseCurrentDirName != DefaultConfig().UseCurrentDirName </span><span class="cov8" title="1">{
                dst.UseCurrentDirName = src.UseCurrentDirName
        }</span>
        <span class="cov8" title="1">if len(src.ExcludePatterns) &gt; 0 &amp;&amp; !equalStringSlices(src.ExcludePatterns, DefaultConfig().ExcludePatterns) </span><span class="cov8" title="1">{
                dst.ExcludePatterns = src.ExcludePatterns
        }</span>
        <span class="cov8" title="1">if src.IncludeGitInfo != DefaultConfig().IncludeGitInfo </span><span class="cov8" title="1">{
                dst.IncludeGitInfo = src.IncludeGitInfo
        }</span>
        <span class="cov8" title="1">if src.ShowGitDirtyStatus != DefaultConfig().ShowGitDirtyStatus </span><span class="cov0" title="0">{
                dst.ShowGitDirtyStatus = src.ShowGitDirtyStatus
        }</span>
        <span class="cov8" title="1">if src.Verification != nil </span><span class="cov8" title="1">{
                dst.Verification = src.Verification
        }</span>
}

// CFG-001: File backup settings merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeFileBackupSettings merges file backup configuration settings.
// It handles backup directory path and naming settings.
func mergeFileBackupSettings(dst, src *Config) <span class="cov8" title="1">{
        if src.BackupDirPath != DefaultConfig().BackupDirPath </span><span class="cov8" title="1">{
                dst.BackupDirPath = src.BackupDirPath
        }</span>
        <span class="cov8" title="1">if src.UseCurrentDirNameForFiles != DefaultConfig().UseCurrentDirNameForFiles </span><span class="cov0" title="0">{
                dst.UseCurrentDirNameForFiles = src.UseCurrentDirNameForFiles
        }</span>
}

// CFG-002: Status code merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeStatusCodes merges all status code settings.
// It handles both directory and file operation status codes.
func mergeStatusCodes(dst, src *Config) <span class="cov8" title="1">{
        mergeDirectoryStatusCodes(dst, src)
        mergeFileStatusCodes(dst, src)
}</span>

// CFG-002: Directory status code merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeDirectoryStatusCodes merges directory operation status codes.
// It handles archive creation and verification status codes.
func mergeDirectoryStatusCodes(dst, src *Config) <span class="cov8" title="1">{
        statusCodes := map[string]struct {
                src *int
                dst *int
        }{
                "created_archive": {
                        &amp;src.StatusCreatedArchive,
                        &amp;dst.StatusCreatedArchive,
                },
                "failed_to_create_archive_directory": {
                        &amp;src.StatusFailedToCreateArchiveDirectory,
                        &amp;dst.StatusFailedToCreateArchiveDirectory,
                },
                "directory_is_identical_to_existing": {
                        &amp;src.StatusDirectoryIsIdenticalToExistingArchive,
                        &amp;dst.StatusDirectoryIsIdenticalToExistingArchive,
                },
                "directory_not_found": {
                        &amp;src.StatusDirectoryNotFound,
                        &amp;dst.StatusDirectoryNotFound,
                },
                "invalid_directory_type": {
                        &amp;src.StatusInvalidDirectoryType,
                        &amp;dst.StatusInvalidDirectoryType,
                },
                "permission_denied": {
                        &amp;src.StatusPermissionDenied,
                        &amp;dst.StatusPermissionDenied,
                },
                "disk_full": {
                        &amp;src.StatusDiskFull,
                        &amp;dst.StatusDiskFull,
                },
                "config_error": {
                        &amp;src.StatusConfigError,
                        &amp;dst.StatusConfigError,
                },
        }

        for _, codes := range statusCodes </span><span class="cov8" title="1">{
                if *codes.src != *codes.dst &amp;&amp; *codes.src != 0 </span><span class="cov8" title="1">{
                        *codes.dst = *codes.src
                }</span>
        }
}

// CFG-002: File status code merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeFileStatusCodes merges file operation status codes.
// It handles file backup and verification status codes.
func mergeFileStatusCodes(dst, src *Config) <span class="cov8" title="1">{
        statusCodes := map[string]struct {
                src *int
                dst *int
        }{
                "created_backup": {
                        &amp;src.StatusCreatedBackup,
                        &amp;dst.StatusCreatedBackup,
                },
                "failed_to_create_backup_directory": {
                        &amp;src.StatusFailedToCreateBackupDirectory,
                        &amp;dst.StatusFailedToCreateBackupDirectory,
                },
                "file_is_identical_to_existing": {
                        &amp;src.StatusFileIsIdenticalToExistingBackup,
                        &amp;dst.StatusFileIsIdenticalToExistingBackup,
                },
                "file_not_found": {
                        &amp;src.StatusFileNotFound,
                        &amp;dst.StatusFileNotFound,
                },
                "invalid_file_type": {
                        &amp;src.StatusInvalidFileType,
                        &amp;dst.StatusInvalidFileType,
                },
        }

        for _, codes := range statusCodes </span><span class="cov8" title="1">{
                if *codes.src != *codes.dst &amp;&amp; *codes.src != 0 </span><span class="cov0" title="0">{
                        *codes.dst = *codes.src
                }</span>
        }
}

// mergeFormatStrings merges printf-style format string settings.
func mergeFormatStrings(dst, src *Config) <span class="cov8" title="1">{
        mergeDirectoryFormatStrings(dst, src)
        mergeFileFormatStrings(dst, src)
}</span>

// mergeDirectoryFormatStrings merges directory operation format strings.
func mergeDirectoryFormatStrings(dst, src *Config) <span class="cov8" title="1">{
        formats := map[string]struct {
                src *string
                dst *string
        }{
                "created_archive": {
                        &amp;src.FormatCreatedArchive,
                        &amp;dst.FormatCreatedArchive,
                },
                "identical_archive": {
                        &amp;src.FormatIdenticalArchive,
                        &amp;dst.FormatIdenticalArchive,
                },
                "list_archive": {
                        &amp;src.FormatListArchive,
                        &amp;dst.FormatListArchive,
                },
                "config_value": {
                        &amp;src.FormatConfigValue,
                        &amp;dst.FormatConfigValue,
                },
                "dry_run_archive": {
                        &amp;src.FormatDryRunArchive,
                        &amp;dst.FormatDryRunArchive,
                },
                "error": {
                        &amp;src.FormatError,
                        &amp;dst.FormatError,
                },
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if *format.src != *format.dst &amp;&amp; *format.src != "" </span><span class="cov0" title="0">{
                        *format.dst = *format.src
                }</span>
        }
}

// mergeFileFormatStrings merges file operation format strings.
func mergeFileFormatStrings(dst, src *Config) <span class="cov8" title="1">{
        formats := map[string]struct {
                src *string
                dst *string
        }{
                "created_backup": {
                        &amp;src.FormatCreatedBackup,
                        &amp;dst.FormatCreatedBackup,
                },
                "identical_backup": {
                        &amp;src.FormatIdenticalBackup,
                        &amp;dst.FormatIdenticalBackup,
                },
                "list_backup": {
                        &amp;src.FormatListBackup,
                        &amp;dst.FormatListBackup,
                },
                "dry_run_backup": {
                        &amp;src.FormatDryRunBackup,
                        &amp;dst.FormatDryRunBackup,
                },
        }

        for _, format := range formats </span><span class="cov8" title="1">{
                if *format.src != *format.dst &amp;&amp; *format.src != "" </span><span class="cov0" title="0">{
                        *format.dst = *format.src
                }</span>
        }
}

// mergeTemplates merges template-based format string settings.
func mergeTemplates(dst, src *Config) <span class="cov8" title="1">{
        mergeDirectoryTemplates(dst, src)
        mergeFileTemplates(dst, src)
}</span>

// mergeDirectoryTemplates merges directory operation templates.
func mergeDirectoryTemplates(dst, src *Config) <span class="cov8" title="1">{
        templates := map[string]struct {
                src *string
                dst *string
        }{
                "created_archive": {
                        &amp;src.TemplateCreatedArchive,
                        &amp;dst.TemplateCreatedArchive,
                },
                "identical_archive": {
                        &amp;src.TemplateIdenticalArchive,
                        &amp;dst.TemplateIdenticalArchive,
                },
                "list_archive": {
                        &amp;src.TemplateListArchive,
                        &amp;dst.TemplateListArchive,
                },
                "config_value": {
                        &amp;src.TemplateConfigValue,
                        &amp;dst.TemplateConfigValue,
                },
                "dry_run_archive": {
                        &amp;src.TemplateDryRunArchive,
                        &amp;dst.TemplateDryRunArchive,
                },
                "error": {
                        &amp;src.TemplateError,
                        &amp;dst.TemplateError,
                },
        }

        for _, tmpl := range templates </span><span class="cov8" title="1">{
                if *tmpl.src != *tmpl.dst &amp;&amp; *tmpl.src != "" </span><span class="cov0" title="0">{
                        *tmpl.dst = *tmpl.src
                }</span>
        }
}

// mergeFileTemplates merges file operation templates.
func mergeFileTemplates(dst, src *Config) <span class="cov8" title="1">{
        templates := map[string]struct {
                src *string
                dst *string
        }{
                "created_backup": {
                        &amp;src.TemplateCreatedBackup,
                        &amp;dst.TemplateCreatedBackup,
                },
                "identical_backup": {
                        &amp;src.TemplateIdenticalBackup,
                        &amp;dst.TemplateIdenticalBackup,
                },
                "list_backup": {
                        &amp;src.TemplateListBackup,
                        &amp;dst.TemplateListBackup,
                },
                "dry_run_backup": {
                        &amp;src.TemplateDryRunBackup,
                        &amp;dst.TemplateDryRunBackup,
                },
        }

        for _, tmpl := range templates </span><span class="cov8" title="1">{
                if *tmpl.src != *tmpl.dst &amp;&amp; *tmpl.src != "" </span><span class="cov0" title="0">{
                        *tmpl.dst = *tmpl.src
                }</span>
        }
}

// mergePatterns merges regex pattern settings.
func mergePatterns(dst, src *Config) <span class="cov8" title="1">{
        if src.PatternArchiveFilename != DefaultConfig().PatternArchiveFilename </span><span class="cov0" title="0">{
                dst.PatternArchiveFilename = src.PatternArchiveFilename
        }</span>
        <span class="cov8" title="1">if src.PatternBackupFilename != DefaultConfig().PatternBackupFilename </span><span class="cov0" title="0">{
                dst.PatternBackupFilename = src.PatternBackupFilename
        }</span>
        <span class="cov8" title="1">if src.PatternConfigLine != DefaultConfig().PatternConfigLine </span><span class="cov0" title="0">{
                dst.PatternConfigLine = src.PatternConfigLine
        }</span>
        <span class="cov8" title="1">if src.PatternTimestamp != DefaultConfig().PatternTimestamp </span><span class="cov0" title="0">{
                dst.PatternTimestamp = src.PatternTimestamp
        }</span>
}

func equalStringSlices(a, b []string) bool <span class="cov8" title="1">{
        if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i := range a </span><span class="cov8" title="1">{
                if a[i] != b[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// GetConfigValues returns a slice of ConfigValue containing all configuration
// values and their sources.
func GetConfigValues(cfg *Config) []ConfigValue <span class="cov8" title="1">{
        // This would be used by the --config command to display all configuration values
        // For now, return basic values - this can be expanded
        return []ConfigValue{
                {Name: "archive_dir_path", Value: cfg.ArchiveDirPath, Source: "config"},
                {Name: "use_current_dir_name", Value: boolToString(cfg.UseCurrentDirName), Source: "config"},
                {Name: "include_git_info", Value: boolToString(cfg.IncludeGitInfo), Source: "config"},
                {Name: "backup_dir_path", Value: cfg.BackupDirPath, Source: "config"},
                {Name: "use_current_dir_name_for_files", Value: boolToString(cfg.UseCurrentDirNameForFiles), Source: "config"},
                {Name: "verify_on_create", Value: boolToString(cfg.Verification.VerifyOnCreate), Source: "config"},
                {Name: "checksum_algorithm", Value: cfg.Verification.ChecksumAlgorithm, Source: "config"},
        }
}</span>

// GetConfigValuesWithSources returns a slice of ConfigValue containing all configuration
// values with their actual sources (default, config file, etc.).
// The returned values are sorted alphabetically by configuration name.
func GetConfigValuesWithSources(cfg *Config, root string) []ConfigValue <span class="cov8" title="1">{
        defaultCfg := DefaultConfig()
        configSource := determineConfigSource(root)
        getSource := createSourceDeterminer(configSource)

        var configValues []ConfigValue
        configValues = append(configValues, getBasicConfigValues(cfg, defaultCfg, getSource)...)
        configValues = append(configValues, getStatusCodeValues(cfg, defaultCfg, getSource)...)
        configValues = append(configValues, getVerificationValues(cfg, defaultCfg, getSource)...)

        // Requirement: Sort configuration values alphabetically by name
        sort.Slice(configValues, func(i, j int) bool </span><span class="cov8" title="1">{
                return configValues[i].Name &lt; configValues[j].Name
        }</span>)

        <span class="cov8" title="1">return configValues</span>
}

// determineConfigSource finds which config file was actually loaded
func determineConfigSource(root string) string <span class="cov8" title="1">{
        searchPaths := getConfigSearchPaths()
        for _, configPath := range searchPaths </span><span class="cov8" title="1">{
                expandedPath := expandPath(configPath)
                if !filepath.IsAbs(expandedPath) </span><span class="cov8" title="1">{
                        expandedPath = filepath.Join(root, expandedPath)
                }</span>
                <span class="cov8" title="1">if _, err := os.Stat(expandedPath); err == nil </span><span class="cov8" title="1">{
                        return expandedPath
                }</span>
        }
        <span class="cov8" title="1">return "default"</span>
}

// createSourceDeterminer creates a function to determine if a value is default or from config
func createSourceDeterminer(configSource string) func(interface{}, interface{}) string <span class="cov8" title="1">{
        return func(current, defaultVal interface{}) string </span><span class="cov8" title="1">{
                switch v := current.(type) </span>{
                case string:<span class="cov8" title="1">
                        if v == defaultVal.(string) </span><span class="cov8" title="1">{
                                return "default"
                        }</span>
                case bool:<span class="cov8" title="1">
                        if v == defaultVal.(bool) </span><span class="cov8" title="1">{
                                return "default"
                        }</span>
                case int:<span class="cov8" title="1">
                        if v == defaultVal.(int) </span><span class="cov8" title="1">{
                                return "default"
                        }</span>
                case []string:<span class="cov8" title="1">
                        if equalStringSlices(v, defaultVal.([]string)) </span><span class="cov8" title="1">{
                                return "default"
                        }</span>
                }
                <span class="cov8" title="1">return configSource</span>
        }
}

// getBasicConfigValues returns basic configuration values
func getBasicConfigValues(cfg, defaultCfg *Config, getSource func(interface{}, interface{}) string) []ConfigValue <span class="cov8" title="1">{
        return []ConfigValue{
                {
                        Name:   "archive_dir_path",
                        Value:  cfg.ArchiveDirPath,
                        Source: getSource(cfg.ArchiveDirPath, defaultCfg.ArchiveDirPath),
                },
                {
                        Name:   "backup_dir_path",
                        Value:  cfg.BackupDirPath,
                        Source: getSource(cfg.BackupDirPath, defaultCfg.BackupDirPath),
                },
                {
                        Name:   "use_current_dir_name",
                        Value:  boolToString(cfg.UseCurrentDirName),
                        Source: getSource(cfg.UseCurrentDirName, defaultCfg.UseCurrentDirName),
                },
                {
                        Name:   "use_current_dir_name_for_files",
                        Value:  boolToString(cfg.UseCurrentDirNameForFiles),
                        Source: getSource(cfg.UseCurrentDirNameForFiles, defaultCfg.UseCurrentDirNameForFiles),
                },
                {
                        Name:   "include_git_info",
                        Value:  boolToString(cfg.IncludeGitInfo),
                        Source: getSource(cfg.IncludeGitInfo, defaultCfg.IncludeGitInfo),
                },
        }
}</span>

// getStatusCodeValues returns status code configuration values
func getStatusCodeValues(cfg, defaultCfg *Config, getSource func(interface{}, interface{}) string) []ConfigValue <span class="cov8" title="1">{
        return []ConfigValue{
                {
                        Name:   "status_config_error",
                        Value:  fmt.Sprintf("%d", cfg.StatusConfigError),
                        Source: getSource(cfg.StatusConfigError, defaultCfg.StatusConfigError),
                },
                {
                        Name:   "status_created_archive",
                        Value:  fmt.Sprintf("%d", cfg.StatusCreatedArchive),
                        Source: getSource(cfg.StatusCreatedArchive, defaultCfg.StatusCreatedArchive),
                },
                {
                        Name:   "status_created_backup",
                        Value:  fmt.Sprintf("%d", cfg.StatusCreatedBackup),
                        Source: getSource(cfg.StatusCreatedBackup, defaultCfg.StatusCreatedBackup),
                },
                {
                        Name:   "status_disk_full",
                        Value:  fmt.Sprintf("%d", cfg.StatusDiskFull),
                        Source: getSource(cfg.StatusDiskFull, defaultCfg.StatusDiskFull),
                },
                {
                        Name:   "status_permission_denied",
                        Value:  fmt.Sprintf("%d", cfg.StatusPermissionDenied),
                        Source: getSource(cfg.StatusPermissionDenied, defaultCfg.StatusPermissionDenied),
                },
        }
}</span>

// getVerificationValues returns verification configuration values
func getVerificationValues(cfg, defaultCfg *Config, getSource func(interface{}, interface{}) string) []ConfigValue <span class="cov8" title="1">{
        return []ConfigValue{
                {
                        Name:   "verify_on_create",
                        Value:  boolToString(cfg.Verification.VerifyOnCreate),
                        Source: getSource(cfg.Verification.VerifyOnCreate, defaultCfg.Verification.VerifyOnCreate),
                },
                {
                        Name:   "checksum_algorithm",
                        Value:  cfg.Verification.ChecksumAlgorithm,
                        Source: getSource(cfg.Verification.ChecksumAlgorithm, defaultCfg.Verification.ChecksumAlgorithm),
                },
        }
}</span>

func boolToString(b bool) string <span class="cov8" title="1">{
        if b </span><span class="cov8" title="1">{
                return "true"
        }</span>
        <span class="cov8" title="1">return "false"</span>
}

// CFG-001: Configuration value loading implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// LoadConfigValues loads configuration values from YAML files and environment variables.
// It returns a map of configuration values with their sources.
func LoadConfigValues(root string) (map[string]ConfigValue, error) <span class="cov8" title="1">{
        // Implementation of LoadConfigValues function
        return nil, nil // Placeholder return, actual implementation needed
}</span>

// CFG-001: Configuration value merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeConfigValues merges configuration values from source into destination.
// It preserves values from the source configuration.
func mergeConfigValues(dst, src map[string]ConfigValue) {<span class="cov8" title="1">
        // Implementation of mergeConfigValues function
}</span>

// CFG-001: Basic settings value merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeBasicSettingValues merges basic configuration setting values.
// It handles archive directory path, Git integration, and verification settings.
func mergeBasicSettingValues(dst, src map[string]ConfigValue, srcCfg *Config) {<span class="cov8" title="1">
        // Implementation of mergeBasicSettingValues function
}</span>

// CFG-001: File backup settings value merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeFileBackupSettingValues merges file backup configuration setting values.
// It handles backup directory path and naming settings.
func mergeFileBackupSettingValues(dst, src map[string]ConfigValue, srcCfg *Config) {<span class="cov8" title="1">
        // Implementation of mergeFileBackupSettingValues function
}</span>

// CFG-002: Status code value merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeStatusCodeValues merges all status code setting values.
// It handles both directory and file operation status codes.
func mergeStatusCodeValues(dst, src map[string]ConfigValue, srcCfg *Config) {<span class="cov8" title="1">
        // Implementation of mergeStatusCodeValues function
}</span>

// CFG-002: Directory status code value merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeDirectoryStatusCodeValues merges directory operation status code values.
// It handles archive creation and verification status codes.
func mergeDirectoryStatusCodeValues(dst, src map[string]ConfigValue, srcCfg *Config) {<span class="cov8" title="1">
        // Implementation of mergeDirectoryStatusCodeValues function
}</span>

// CFG-002: File status code value merging implementation
// IMMUTABLE-REF: Configuration Discovery
// TEST-REF: TestGetConfigSearchPath
// DECISION-REF: DEC-002
// mergeFileStatusCodeValues merges file operation status code values.
// It handles file backup and verification status codes.
func mergeFileStatusCodeValues(dst, src map[string]ConfigValue, srcCfg *Config) {<span class="cov8" title="1">
        // Implementation of mergeFileStatusCodeValues function
}</span>

// CFG-004: Extended format strings for comprehensive string configuration
// mergeExtendedFormatStrings merges extended format string settings.
func mergeExtendedFormatStrings(dst, src *Config) <span class="cov8" title="1">{
        defaultCfg := DefaultConfig()

        // Archive operation messages
        if src.FormatNoArchivesFound != defaultCfg.FormatNoArchivesFound </span><span class="cov8" title="1">{
                dst.FormatNoArchivesFound = src.FormatNoArchivesFound
        }</span>
        <span class="cov8" title="1">if src.FormatVerificationFailed != defaultCfg.FormatVerificationFailed </span><span class="cov8" title="1">{
                dst.FormatVerificationFailed = src.FormatVerificationFailed
        }</span>
        <span class="cov8" title="1">if src.FormatVerificationSuccess != defaultCfg.FormatVerificationSuccess </span><span class="cov8" title="1">{
                dst.FormatVerificationSuccess = src.FormatVerificationSuccess
        }</span>
        <span class="cov8" title="1">if src.FormatVerificationWarning != defaultCfg.FormatVerificationWarning </span><span class="cov8" title="1">{
                dst.FormatVerificationWarning = src.FormatVerificationWarning
        }</span>
        <span class="cov8" title="1">if src.FormatConfigurationUpdated != defaultCfg.FormatConfigurationUpdated </span><span class="cov8" title="1">{
                dst.FormatConfigurationUpdated = src.FormatConfigurationUpdated
        }</span>
        <span class="cov8" title="1">if src.FormatConfigFilePath != defaultCfg.FormatConfigFilePath </span><span class="cov8" title="1">{
                dst.FormatConfigFilePath = src.FormatConfigFilePath
        }</span>
        <span class="cov8" title="1">if src.FormatDryRunFilesHeader != defaultCfg.FormatDryRunFilesHeader </span><span class="cov8" title="1">{
                dst.FormatDryRunFilesHeader = src.FormatDryRunFilesHeader
        }</span>
        <span class="cov8" title="1">if src.FormatDryRunFileEntry != defaultCfg.FormatDryRunFileEntry </span><span class="cov8" title="1">{
                dst.FormatDryRunFileEntry = src.FormatDryRunFileEntry
        }</span>
        <span class="cov8" title="1">if src.FormatNoFilesModified != defaultCfg.FormatNoFilesModified </span><span class="cov8" title="1">{
                dst.FormatNoFilesModified = src.FormatNoFilesModified
        }</span>
        <span class="cov8" title="1">if src.FormatIncrementalCreated != defaultCfg.FormatIncrementalCreated </span><span class="cov8" title="1">{
                dst.FormatIncrementalCreated = src.FormatIncrementalCreated
        }</span>

        // Backup operation messages
        <span class="cov8" title="1">if src.FormatNoBackupsFound != defaultCfg.FormatNoBackupsFound </span><span class="cov8" title="1">{
                dst.FormatNoBackupsFound = src.FormatNoBackupsFound
        }</span>
        <span class="cov8" title="1">if src.FormatBackupWouldCreate != defaultCfg.FormatBackupWouldCreate </span><span class="cov8" title="1">{
                dst.FormatBackupWouldCreate = src.FormatBackupWouldCreate
        }</span>
        <span class="cov8" title="1">if src.FormatBackupIdentical != defaultCfg.FormatBackupIdentical </span><span class="cov8" title="1">{
                dst.FormatBackupIdentical = src.FormatBackupIdentical
        }</span>
        <span class="cov8" title="1">if src.FormatBackupCreated != defaultCfg.FormatBackupCreated </span><span class="cov8" title="1">{
                dst.FormatBackupCreated = src.FormatBackupCreated
        }</span>
}

// CFG-004: Extended templates for comprehensive string configuration
// mergeExtendedTemplates merges extended template settings.
func mergeExtendedTemplates(dst, src *Config) <span class="cov8" title="1">{
        defaultCfg := DefaultConfig()

        // Archive operation templates
        if src.TemplateNoArchivesFound != defaultCfg.TemplateNoArchivesFound </span><span class="cov8" title="1">{
                dst.TemplateNoArchivesFound = src.TemplateNoArchivesFound
        }</span>
        <span class="cov8" title="1">if src.TemplateVerificationFailed != defaultCfg.TemplateVerificationFailed </span><span class="cov8" title="1">{
                dst.TemplateVerificationFailed = src.TemplateVerificationFailed
        }</span>
        <span class="cov8" title="1">if src.TemplateVerificationSuccess != defaultCfg.TemplateVerificationSuccess </span><span class="cov8" title="1">{
                dst.TemplateVerificationSuccess = src.TemplateVerificationSuccess
        }</span>
        <span class="cov8" title="1">if src.TemplateVerificationWarning != defaultCfg.TemplateVerificationWarning </span><span class="cov8" title="1">{
                dst.TemplateVerificationWarning = src.TemplateVerificationWarning
        }</span>
        <span class="cov8" title="1">if src.TemplateConfigurationUpdated != defaultCfg.TemplateConfigurationUpdated </span><span class="cov8" title="1">{
                dst.TemplateConfigurationUpdated = src.TemplateConfigurationUpdated
        }</span>
        <span class="cov8" title="1">if src.TemplateConfigFilePath != defaultCfg.TemplateConfigFilePath </span><span class="cov8" title="1">{
                dst.TemplateConfigFilePath = src.TemplateConfigFilePath
        }</span>
        <span class="cov8" title="1">if src.TemplateDryRunFilesHeader != defaultCfg.TemplateDryRunFilesHeader </span><span class="cov8" title="1">{
                dst.TemplateDryRunFilesHeader = src.TemplateDryRunFilesHeader
        }</span>
        <span class="cov8" title="1">if src.TemplateDryRunFileEntry != defaultCfg.TemplateDryRunFileEntry </span><span class="cov8" title="1">{
                dst.TemplateDryRunFileEntry = src.TemplateDryRunFileEntry
        }</span>
        <span class="cov8" title="1">if src.TemplateNoFilesModified != defaultCfg.TemplateNoFilesModified </span><span class="cov8" title="1">{
                dst.TemplateNoFilesModified = src.TemplateNoFilesModified
        }</span>
        <span class="cov8" title="1">if src.TemplateIncrementalCreated != defaultCfg.TemplateIncrementalCreated </span><span class="cov8" title="1">{
                dst.TemplateIncrementalCreated = src.TemplateIncrementalCreated
        }</span>

        // Backup operation templates
        <span class="cov8" title="1">if src.TemplateNoBackupsFound != defaultCfg.TemplateNoBackupsFound </span><span class="cov8" title="1">{
                dst.TemplateNoBackupsFound = src.TemplateNoBackupsFound
        }</span>
        <span class="cov8" title="1">if src.TemplateBackupWouldCreate != defaultCfg.TemplateBackupWouldCreate </span><span class="cov8" title="1">{
                dst.TemplateBackupWouldCreate = src.TemplateBackupWouldCreate
        }</span>
        <span class="cov8" title="1">if src.TemplateBackupIdentical != defaultCfg.TemplateBackupIdentical </span><span class="cov8" title="1">{
                dst.TemplateBackupIdentical = src.TemplateBackupIdentical
        }</span>
        <span class="cov8" title="1">if src.TemplateBackupCreated != defaultCfg.TemplateBackupCreated </span><span class="cov8" title="1">{
                dst.TemplateBackupCreated = src.TemplateBackupCreated
        }</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// This file is part of bkpdir
//
// Package main provides error handling and resource management for BkpDir.
// It includes error types, resource cleanup, and context-aware operations.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License
package main

import (
        "context"
        "errors"
        "fmt"
        "os"
        "strings"
        "sync"
)

// ArchiveError represents a structured error with status code
type ArchiveError struct {
        Message    string
        StatusCode int
        Operation  string
        Path       string
        Err        error
}

func (e *ArchiveError) Error() string <span class="cov8" title="1">{
        // CFG-002: Structured error message formatting
        // DECISION-REF: DEC-004
        if e.Err != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s: %v", e.Message, e.Err)
        }</span>
        <span class="cov8" title="1">return e.Message</span>
}

func (e *ArchiveError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewArchiveError creates a new structured error
func NewArchiveError(message string, statusCode int) *ArchiveError <span class="cov8" title="1">{
        // CFG-002: Basic structured error creation
        // DECISION-REF: DEC-004
        return &amp;ArchiveError{
                Message:    message,
                StatusCode: statusCode,
        }
}</span>

// NewArchiveErrorWithCause creates a new structured error with underlying cause
func NewArchiveErrorWithCause(message string, statusCode int, err error) *ArchiveError <span class="cov8" title="1">{
        // CFG-002: Error creation with cause chain
        // DECISION-REF: DEC-004
        return &amp;ArchiveError{
                Message:    message,
                StatusCode: statusCode,
                Err:        err,
        }
}</span>

// NewArchiveErrorWithContext creates a new structured error with operation context
func NewArchiveErrorWithContext(
        message string,
        statusCode int,
        operation, path string,
        err error,
) *ArchiveError <span class="cov8" title="1">{
        // CFG-002: Error creation with operation context
        // DECISION-REF: DEC-004
        return &amp;ArchiveError{
                Message:    message,
                StatusCode: statusCode,
                Operation:  operation,
                Path:       path,
                Err:        err,
        }
}</span>

// IsDiskFullError reports whether the error is due to disk full or quota exceeded conditions.
func IsDiskFullError(err error) bool <span class="cov8" title="1">{
        // Error classification for disk space issues
        // DECISION-REF: DEC-004
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())
        diskFullPatterns := []string{
                "no space left on device",
                "disk full",
                "not enough space",
                "insufficient disk space",
                "device full",
                "quota exceeded",
                "file too large",
        }

        for _, pattern := range diskFullPatterns </span><span class="cov8" title="1">{
                if strings.Contains(errStr, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// isDiskFullError provides enhanced disk space error detection with comprehensive pattern matching
func isDiskFullError(err error) bool <span class="cov8" title="1">{
        // Enhanced disk space error detection
        // DECISION-REF: DEC-004
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())
        diskFullPatterns := []string{
                "no space left",
                "disk full",
                "not enough space",
                "insufficient disk space",
                "device full",
                "quota exceeded",
                "file too large",
        }

        for _, pattern := range diskFullPatterns </span><span class="cov8" title="1">{
                if strings.Contains(errStr, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

// IsPermissionError reports whether the error is due to permission or access denied conditions.
func IsPermissionError(err error) bool <span class="cov8" title="1">{
        // Error classification for permission issues
        // DECISION-REF: DEC-004
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())
        permissionPatterns := []string{
                "permission denied",
                "access denied",
                "operation not permitted",
                "insufficient privileges",
        }

        for _, pattern := range permissionPatterns </span><span class="cov8" title="1">{
                if strings.Contains(errStr, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// IsDirectoryNotFoundError reports whether the error is due to a missing directory.
func IsDirectoryNotFoundError(err error) bool <span class="cov8" title="1">{
        // Error classification for directory not found
        // DECISION-REF: DEC-004
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">errStr := strings.ToLower(err.Error())
        return strings.Contains(errStr, "no such file or directory") ||
                strings.Contains(errStr, "cannot find the path") ||
                strings.Contains(errStr, "directory not found")</span>
}

// Resource represents a resource that needs cleanup
type Resource interface {
        Cleanup() error
        String() string
}

// TempFile represents a temporary file resource
type TempFile struct {
        Path string
}

// Cleanup removes the temporary file from the filesystem.
func (tf *TempFile) Cleanup() error <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        return os.Remove(tf.Path)
}</span>

func (tf *TempFile) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("temp file: %s", tf.Path)
}</span>

// TempDir represents a temporary directory resource
type TempDir struct {
        Path string
}

// Cleanup removes the temporary directory and its contents from the filesystem.
func (td *TempDir) Cleanup() error <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        return os.RemoveAll(td.Path)
}</span>

func (td *TempDir) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("temp dir: %s", td.Path)
}</span>

// ResourceManager manages automatic cleanup of resources
type ResourceManager struct {
        resources []Resource
        mutex     sync.RWMutex
}

// NewResourceManager creates a new ResourceManager for tracking resources.
func NewResourceManager() *ResourceManager <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        return &amp;ResourceManager{
                resources: make([]Resource, 0),
        }
}</span>

// AddResource adds a resource to the ResourceManager for cleanup.
func (rm *ResourceManager) AddResource(resource Resource) <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        rm.mutex.Lock()
        defer rm.mutex.Unlock()
        rm.resources = append(rm.resources, resource)
}</span>

// AddTempFile adds a temporary file resource to the ResourceManager.
func (rm *ResourceManager) AddTempFile(path string) <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        rm.AddResource(&amp;TempFile{Path: path})
}</span>

// AddTempDir adds a temporary directory resource to the ResourceManager.
func (rm *ResourceManager) AddTempDir(path string) <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        rm.AddResource(&amp;TempDir{Path: path})
}</span>

// RemoveResource removes a resource from the ResourceManager.
func (rm *ResourceManager) RemoveResource(resource Resource) <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        rm.mutex.Lock()
        defer rm.mutex.Unlock()

        for i, r := range rm.resources </span><span class="cov8" title="1">{
                if r.String() == resource.String() </span><span class="cov8" title="1">{
                        rm.resources = append(rm.resources[:i], rm.resources[i+1:]...)
                        break</span>
                }
        }
}

// Cleanup cleans up all tracked resources in the ResourceManager.
func (rm *ResourceManager) Cleanup() error <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        rm.mutex.Lock()
        defer rm.mutex.Unlock()

        var lastError error
        for _, resource := range rm.resources </span><span class="cov8" title="1">{
                if err := resource.Cleanup(); err != nil </span><span class="cov8" title="1">{
                        lastError = err
                        // Continue cleanup even if individual operations fail
                }</span>
        }

        <span class="cov8" title="1">rm.resources = rm.resources[:0] // Clear the slice
        return lastError</span>
}

// CleanupWithPanicRecovery cleans up all resources and recovers from panics during cleanup.
func (rm *ResourceManager) CleanupWithPanicRecovery() (err error) <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        err = fmt.Errorf("panic during cleanup: %v", r)
                }</span>
        }()

        <span class="cov8" title="1">return rm.Cleanup()</span>
}

// ContextualOperation provides context and resource management for operations.
type ContextualOperation struct {
        ctx context.Context
        rm  *ResourceManager
}

// NewContextualOperation creates a new ContextualOperation with the given context.
func NewContextualOperation(ctx context.Context) *ContextualOperation <span class="cov8" title="1">{
        // DECISION-REF: DEC-006, DEC-007
        return &amp;ContextualOperation{
                ctx: ctx,
                rm:  NewResourceManager(),
        }
}</span>

// Context returns the context associated with the ContextualOperation.
func (co *ContextualOperation) Context() context.Context <span class="cov8" title="1">{
        // DECISION-REF: DEC-007
        return co.ctx
}</span>

// ResourceManager returns the ResourceManager associated with the ContextualOperation.
func (co *ContextualOperation) ResourceManager() *ResourceManager <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        return co.rm
}</span>

// IsCancelled checks if the operation has been cancelled.
func (co *ContextualOperation) IsCancelled() bool <span class="cov8" title="1">{
        // DECISION-REF: DEC-007
        select </span>{
        case &lt;-co.ctx.Done():<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

// CheckCancellation checks if the operation has been cancelled and returns an error if it has.
func (co *ContextualOperation) CheckCancellation() error <span class="cov8" title="1">{
        // DECISION-REF: DEC-007
        return co.ctx.Err()
}</span>

// Cleanup cleans up all resources associated with the operation.
func (co *ContextualOperation) Cleanup() error <span class="cov8" title="1">{
        // DECISION-REF: DEC-006
        return co.rm.Cleanup()
}</span>

// HandleArchiveError processes an archive error and returns the appropriate status code.
func HandleArchiveError(err error, cfg *Config, formatter *OutputFormatter) int <span class="cov8" title="1">{
        // CFG-002: Error handling with status code resolution
        // CFG-003: Error output formatting
        // CFG-004: Configurable error messages
        // DECISION-REF: DEC-004
        if err == nil </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">var archiveErr *ArchiveError
        if errors.As(err, &amp;archiveErr) </span><span class="cov8" title="1">{
                formatter.PrintError(archiveErr.Error())
                return archiveErr.StatusCode
        }</span>

        // Handle specific error types with configurable messages
        <span class="cov8" title="1">switch </span>{
        case IsDiskFullError(err):<span class="cov8" title="1">
                formatter.PrintDiskFullError(err)
                return cfg.StatusDiskFull</span>
        case IsPermissionError(err):<span class="cov8" title="1">
                formatter.PrintPermissionError(err)
                return cfg.StatusPermissionDenied</span>
        case IsDirectoryNotFoundError(err):<span class="cov8" title="1">
                formatter.PrintDirectoryNotFound(err)
                return cfg.StatusDirectoryNotFound</span>
        default:<span class="cov8" title="1">
                formatter.PrintError(err.Error())
                return 1</span>
        }
}

// AtomicWriteFile writes data to a file atomically using a temporary file.
func AtomicWriteFile(path string, data []byte, rm *ResourceManager) error <span class="cov8" title="1">{
        // DECISION-REF: DEC-006, DEC-008
        // CFG-004: Configurable error messages
        tempFile := path + ".tmp"
        rm.AddTempFile(tempFile)

        if err := os.WriteFile(tempFile, data, 0644); err != nil </span><span class="cov8" title="1">{
                return NewArchiveErrorWithCause(
                        "Failed to write temporary file",
                        1,
                        err,
                )
        }</span>

        <span class="cov8" title="1">if err := os.Rename(tempFile, path); err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause(
                        "Failed to finalize file",
                        1,
                        err,
                )
        }</span>

        <span class="cov8" title="1">rm.RemoveResource(&amp;TempFile{Path: tempFile})
        return nil</span>
}

// SafeMkdirAll creates a directory and all necessary parent directories.
func SafeMkdirAll(path string, perm os.FileMode, cfg *Config) error <span class="cov8" title="1">{
        // Directory creation with error handling
        // CFG-004: Configurable error messages
        // DECISION-REF: DEC-004
        if err := os.MkdirAll(path, perm); err != nil </span><span class="cov8" title="1">{
                if IsDiskFullError(err) </span><span class="cov0" title="0">{
                        return NewArchiveErrorWithCause(
                                "Failed to create directory: disk full",
                                cfg.StatusDiskFull,
                                err,
                        )
                }</span>
                <span class="cov8" title="1">return NewArchiveErrorWithCause(
                        "Failed to create directory",
                        cfg.StatusConfigError,
                        err,
                )</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// ValidateDirectoryPath checks if a path is a valid directory.
func ValidateDirectoryPath(path string, cfg *Config) error <span class="cov8" title="1">{
        // Directory path validation
        // CFG-004: Configurable error messages
        // DECISION-REF: DEC-004
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return NewArchiveError(
                                "Directory not found",
                                cfg.StatusDirectoryNotFound,
                        )
                }</span>
                <span class="cov8" title="1">if IsPermissionError(err) </span><span class="cov8" title="1">{
                        return NewArchiveErrorWithCause(
                                "Permission denied",
                                cfg.StatusPermissionDenied,
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return NewArchiveErrorWithCause(
                        "Failed to access directory",
                        cfg.StatusConfigError,
                        err,
                )</span>
        }

        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return NewArchiveError(
                        "Path is not a directory",
                        cfg.StatusInvalidDirectoryType,
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ValidateFilePath checks if a path is a valid file.
func ValidateFilePath(path string, cfg *Config) error <span class="cov8" title="1">{
        // File path validation
        // CFG-004: Configurable error messages
        // DECISION-REF: DEC-004
        info, err := os.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return NewArchiveError(
                                "File not found",
                                cfg.StatusFileNotFound,
                        )
                }</span>
                <span class="cov8" title="1">if IsPermissionError(err) </span><span class="cov8" title="1">{
                        return NewArchiveErrorWithCause(
                                "Permission denied",
                                cfg.StatusPermissionDenied,
                                err,
                        )
                }</span>
                <span class="cov0" title="0">return NewArchiveErrorWithCause(
                        "Failed to access file",
                        cfg.StatusConfigError,
                        err,
                )</span>
        }

        <span class="cov8" title="1">if !info.Mode().IsRegular() </span><span class="cov8" title="1">{
                return NewArchiveError(
                        "Path is not a regular file",
                        cfg.StatusInvalidFileType,
                )
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// This file is part of bkpdir
//
// Package main provides file exclusion functionality for BkpDir.
// It handles pattern matching for excluding files and directories from archives.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License
package main

import (
        "path/filepath"
        "strings"

        doublestar "github.com/bmatcuk/doublestar/v4"
)

// PatternMatcher handles matching paths against exclusion patterns
type PatternMatcher struct {
        patterns []string
}

// NewPatternMatcher creates a new PatternMatcher with the given patterns
func NewPatternMatcher(patterns []string) *PatternMatcher <span class="cov8" title="1">{
        // Pattern matcher initialization
        // DECISION-REF: DEC-004
        return &amp;PatternMatcher{patterns: patterns}
}</span>

// ShouldExclude checks if a path should be excluded based on patterns
func (pm *PatternMatcher) ShouldExclude(path string) bool <span class="cov8" title="1">{
        // File exclusion logic implementation
        // ARCH-002: Archive file exclusion
        // FILE-002: Backup file exclusion
        normalizedPath := filepath.ToSlash(path)
        for _, pattern := range pm.patterns </span><span class="cov8" title="1">{
                if pm.matchesPattern(normalizedPath, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// matchesPattern checks if a path matches a single pattern
func (pm *PatternMatcher) matchesPattern(path, pattern string) bool <span class="cov8" title="1">{
        // Pattern matching logic
        normalizedPattern := filepath.ToSlash(pattern)

        if strings.HasSuffix(normalizedPattern, "/") </span><span class="cov8" title="1">{
                return pm.matchesDirectoryPattern(path, normalizedPattern)
        }</span>

        <span class="cov8" title="1">if strings.Contains(normalizedPattern, "*") </span><span class="cov8" title="1">{
                return pm.matchesGlobPattern(path, normalizedPattern)
        }</span>

        <span class="cov0" title="0">return path == normalizedPattern</span>
}

// matchesDirectoryPattern handles patterns ending with /
func (pm *PatternMatcher) matchesDirectoryPattern(path, pattern string) bool <span class="cov8" title="1">{
        // Directory pattern matching
        patternsToTry := []string{
                pattern,                // e.g., node_modules/
                pattern + "**",         // e.g., node_modules/**
                "**/" + pattern,        // e.g., **/node_modules/
                "**/" + pattern + "**", // e.g., **/node_modules/**
        }

        for _, p := range patternsToTry </span><span class="cov8" title="1">{
                matched, err := doublestar.Match(p, path)
                if err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// matchesGlobPattern handles patterns containing *
func (pm *PatternMatcher) matchesGlobPattern(path, pattern string) bool <span class="cov8" title="1">{
        // Glob pattern matching
        if strings.Contains(pattern, "**") </span><span class="cov0" title="0">{
                matched, err := doublestar.Match(pattern, path)
                return err == nil &amp;&amp; matched
        }</span>

        <span class="cov8" title="1">pathParts := strings.Split(path, "/")
        patternParts := strings.Split(pattern, "/")

        if len(patternParts) == 1 </span><span class="cov8" title="1">{
                return pm.matchesRootLevelPattern(path, pattern)
        }</span>

        <span class="cov8" title="1">return pm.matchesDirectoryLevelPattern(path, pattern, pathParts, patternParts)</span>
}

// matchesRootLevelPattern handles patterns without directory parts
func (pm *PatternMatcher) matchesRootLevelPattern(path, pattern string) bool <span class="cov8" title="1">{
        // Root-level pattern matching
        patternsToTry := []string{pattern}
        if !strings.HasPrefix(pattern, "**/") </span><span class="cov8" title="1">{
                patternsToTry = append(patternsToTry, "**/"+pattern)
        }</span>

        <span class="cov8" title="1">for _, p := range patternsToTry </span><span class="cov8" title="1">{
                matched, err := doublestar.Match(p, path)
                if err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// matchesDirectoryLevelPattern handles patterns with directory parts
func (pm *PatternMatcher) matchesDirectoryLevelPattern(
        path, pattern string,
        pathParts, patternParts []string,
) bool <span class="cov8" title="1">{
        // Directory-level pattern matching
        if len(pathParts) == len(patternParts) </span><span class="cov8" title="1">{
                matched, err := doublestar.Match(pattern, path)
                return err == nil &amp;&amp; matched
        }</span>
        <span class="cov8" title="1">return false</span>
}

// ShouldExcludeFile checks if a file should be excluded based on patterns
func ShouldExcludeFile(path string, patterns []string) bool <span class="cov8" title="1">{
        // Public file exclusion interface
        // ARCH-002: Archive file exclusion
        // FILE-002: Backup file exclusion
        matcher := NewPatternMatcher(patterns)
        return matcher.ShouldExclude(path)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">// This file is part of bkpdir
//
// Package main provides output formatting for BkpDir CLI and tests.
// It handles printf-style and template-based formatting of output messages.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License
package main

import (
        "fmt"
        "os"
        "regexp"
        "strings"
        "text/template"
)

// OUT-001: Delayed output management
// OutputMessage represents a message that can be displayed later
type OutputMessage struct {
        Content     string
        Destination string // "stdout" or "stderr"
        Type        string // "info", "error", "warning", etc.
}

// OutputCollector collects output messages for delayed display
type OutputCollector struct {
        messages []OutputMessage
}

// NewOutputCollector creates a new OutputCollector
func NewOutputCollector() *OutputCollector <span class="cov8" title="1">{
        return &amp;OutputCollector{
                messages: make([]OutputMessage, 0),
        }
}</span>

// AddStdout adds a stdout message to the collector
func (oc *OutputCollector) AddStdout(content, messageType string) <span class="cov8" title="1">{
        // OUT-001: Delayed output implementation
        oc.messages = append(oc.messages, OutputMessage{
                Content:     content,
                Destination: "stdout",
                Type:        messageType,
        })
}</span>

// AddStderr adds a stderr message to the collector
func (oc *OutputCollector) AddStderr(content, messageType string) <span class="cov8" title="1">{
        // OUT-001: Delayed output implementation
        oc.messages = append(oc.messages, OutputMessage{
                Content:     content,
                Destination: "stderr",
                Type:        messageType,
        })
}</span>

// GetMessages returns all collected messages
func (oc *OutputCollector) GetMessages() []OutputMessage <span class="cov8" title="1">{
        // OUT-001: Delayed output implementation
        return oc.messages
}</span>

// FlushAll displays all collected messages and clears the collector
func (oc *OutputCollector) FlushAll() <span class="cov8" title="1">{
        // OUT-001: Delayed output implementation
        for _, msg := range oc.messages </span><span class="cov8" title="1">{
                if msg.Destination == "stderr" </span><span class="cov8" title="1">{
                        fmt.Fprint(os.Stderr, msg.Content)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Print(msg.Content)
                }</span>
        }
        <span class="cov8" title="1">oc.messages = make([]OutputMessage, 0)</span>
}

// FlushStdout displays only stdout messages and removes them from the collector
func (oc *OutputCollector) FlushStdout() <span class="cov8" title="1">{
        // OUT-001: Delayed output implementation
        remaining := make([]OutputMessage, 0)
        for _, msg := range oc.messages </span><span class="cov8" title="1">{
                if msg.Destination == "stdout" </span><span class="cov8" title="1">{
                        fmt.Print(msg.Content)
                }</span> else<span class="cov8" title="1"> {
                        remaining = append(remaining, msg)
                }</span>
        }
        <span class="cov8" title="1">oc.messages = remaining</span>
}

// FlushStderr displays only stderr messages and removes them from the collector
func (oc *OutputCollector) FlushStderr() <span class="cov8" title="1">{
        // OUT-001: Delayed output implementation
        remaining := make([]OutputMessage, 0)
        for _, msg := range oc.messages </span><span class="cov8" title="1">{
                if msg.Destination == "stderr" </span><span class="cov8" title="1">{
                        fmt.Fprint(os.Stderr, msg.Content)
                }</span> else<span class="cov8" title="1"> {
                        remaining = append(remaining, msg)
                }</span>
        }
        <span class="cov8" title="1">oc.messages = remaining</span>
}

// Clear removes all collected messages without displaying them
func (oc *OutputCollector) Clear() <span class="cov8" title="1">{
        // OUT-001: Delayed output implementation
        oc.messages = make([]OutputMessage, 0)
}</span>

// CFG-003: Output formatting interface
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// OutputFormatter provides methods for formatting and printing output for BkpDir operations.
// It supports both printf-style and template-based formatting, with optional delayed output.
type OutputFormatter struct {
        cfg       *Config
        collector *OutputCollector // OUT-001: Optional output collector for delayed display
}

// CFG-003: Output formatter constructor
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// NewOutputFormatter creates a new OutputFormatter with the given configuration.
// It initializes the formatter with the provided config for use in formatting operations.
func NewOutputFormatter(cfg *Config) *OutputFormatter <span class="cov8" title="1">{
        return &amp;OutputFormatter{cfg: cfg, collector: nil}
}</span>

// OUT-001: Output formatter constructor with collector
// NewOutputFormatterWithCollector creates a new OutputFormatter with delayed output support.
// Messages will be collected in the provided OutputCollector instead of being printed immediately.
func NewOutputFormatterWithCollector(cfg *Config, collector *OutputCollector) *OutputFormatter <span class="cov8" title="1">{
        return &amp;OutputFormatter{cfg: cfg, collector: collector}
}</span>

// OUT-001: Check if formatter is in delayed output mode
// IsDelayedMode returns true if the formatter is collecting output instead of printing immediately.
func (f *OutputFormatter) IsDelayedMode() bool <span class="cov8" title="1">{
        return f.collector != nil
}</span>

// OUT-001: Get the output collector
// GetCollector returns the OutputCollector if in delayed mode, nil otherwise.
func (f *OutputFormatter) GetCollector() *OutputCollector <span class="cov8" title="1">{
        return f.collector
}</span>

// OUT-001: Set or remove the output collector
// SetCollector sets the output collector for delayed output, or removes it if nil.
func (f *OutputFormatter) SetCollector(collector *OutputCollector) <span class="cov8" title="1">{
        f.collector = collector
}</span>

// CFG-003: Printf-style archive creation formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatCreatedArchive formats a message for a created archive.
// It uses the configured format string to create the output message.
func (f *OutputFormatter) FormatCreatedArchive(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatCreatedArchive, path)
}</span>

// CFG-003: Printf-style identical archive formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatIdenticalArchive formats a message for an identical archive.
// It uses the configured format string to create the output message.
func (f *OutputFormatter) FormatIdenticalArchive(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatIdenticalArchive, path)
}</span>

// CFG-003: Printf-style archive listing formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatListArchive formats a message for listing an archive.
// It uses the configured format string to create the output message with path and creation time.
func (f *OutputFormatter) FormatListArchive(path, creationTime string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatListArchive, path, creationTime)
}</span>

// CFG-003: Printf-style configuration value formatting
// IMMUTABLE-REF: Output Formatting Requirements, Commands - Display Configuration
// TEST-REF: TestDisplayConfig
// DECISION-REF: DEC-003
// FormatConfigValue formats a configuration value for display.
// It uses the configured format string to create the output message with name, value, and source.
func (f *OutputFormatter) FormatConfigValue(name, value, source string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatConfigValue, name, value, source)
}</span>

// CFG-003: Printf-style dry run formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatDryRunArchive formats a message for a dry-run archive operation.
// It uses the configured format string to create the output message.
func (f *OutputFormatter) FormatDryRunArchive(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatDryRunArchive, path)
}</span>

// CFG-003: Printf-style error formatting
// IMMUTABLE-REF: Output Formatting Requirements, Error Handling Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatError formats an error message.
// It uses the configured format string to create the error output message.
func (f *OutputFormatter) FormatError(message string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatError, message)
}</span>

// CFG-003: Output printing for archives
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintCreatedArchive prints a created archive message to stdout.
// It formats the message using FormatCreatedArchive and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintCreatedArchive(path string) <span class="cov8" title="1">{
        message := f.FormatCreatedArchive(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Output printing for identical archives
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintIdenticalArchive prints an identical archive message to stdout.
// It formats the message using FormatIdenticalArchive and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintIdenticalArchive(path string) <span class="cov8" title="1">{
        message := f.FormatIdenticalArchive(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Output printing for archive listings
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintListArchive prints a list archive message to stdout.
// It formats the message using FormatListArchive and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintListArchive(path, creationTime string) <span class="cov8" title="1">{
        message := f.FormatListArchive(path, creationTime)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Output printing for configuration values
// IMMUTABLE-REF: Output Formatting Requirements, Commands - Display Configuration
// TEST-REF: TestDisplayConfig
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintConfigValue prints a config value message to stdout.
// It formats the message using FormatConfigValue and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintConfigValue(name, value, source string) <span class="cov8" title="1">{
        message := f.FormatConfigValue(name, value, source)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "config")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Output printing for dry run operations
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintDryRunArchive prints a dry-run archive message to stdout.
// It formats the message using FormatDryRunArchive and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintDryRunArchive(path string) <span class="cov8" title="1">{
        message := f.FormatDryRunArchive(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "dry-run")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Error output printing
// IMMUTABLE-REF: Output Formatting Requirements, Error Handling Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintError prints an error message to stderr.
// It formats the message using FormatError and writes it to stderr.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintError(message string) <span class="cov8" title="1">{
        errorMessage := f.FormatError(message)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(errorMessage, "error")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprint(os.Stderr, errorMessage)
        }</span>
}

// CFG-003: Printf-style backup creation formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintCreatedBackup prints a created backup message to stdout.
// It formats the message using FormatCreatedBackup and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintCreatedBackup(path string) <span class="cov8" title="1">{
        message := f.FormatCreatedBackup(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Printf-style identical backup formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintIdenticalBackup prints an identical backup message to stdout.
// It formats the message using FormatIdenticalBackup and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintIdenticalBackup(path string) <span class="cov8" title="1">{
        message := f.FormatIdenticalBackup(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Printf-style backup listing formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintListBackup prints a list backup message to stdout.
// It formats the message using FormatListBackup and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintListBackup(path, creationTime string) <span class="cov8" title="1">{
        message := f.FormatListBackup(path, creationTime)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Printf-style backup dry run formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// OUT-001: Enhanced with delayed output support
// PrintDryRunBackup prints a dry-run backup message to stdout.
// It formats the message using FormatDryRunBackup and writes it to stdout.
// If in delayed mode, the message is collected instead of printed immediately.
func (f *OutputFormatter) PrintDryRunBackup(path string) <span class="cov8" title="1">{
        message := f.FormatDryRunBackup(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "dry-run")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// CFG-003: Regex pattern data extraction for archives
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// ExtractArchiveFilenameData extracts data from an archive filename using a regex pattern.
// It returns a map of named capture groups from the configured pattern.
func (f *OutputFormatter) ExtractArchiveFilenameData(filename string) map[string]string <span class="cov8" title="1">{
        return f.extractPatternData(f.cfg.PatternArchiveFilename, filename)
}</span>

// CFG-003: Regex pattern data extraction for backups
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// ExtractBackupFilenameData extracts data from a backup filename using a regex pattern.
// It returns a map of named capture groups from the configured pattern.
func (f *OutputFormatter) ExtractBackupFilenameData(filename string) map[string]string <span class="cov8" title="1">{
        return f.extractPatternData(f.cfg.PatternBackupFilename, filename)
}</span>

// CFG-003: Regex pattern data extraction for config lines
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestDisplayConfig
// DECISION-REF: DEC-003
// ExtractConfigLineData extracts data from a config line using a regex pattern.
// It returns a map of named capture groups from the configured pattern.
func (f *OutputFormatter) ExtractConfigLineData(line string) map[string]string <span class="cov8" title="1">{
        return f.extractPatternData(f.cfg.PatternConfigLine, line)
}</span>

// CFG-003: Regex pattern data extraction for timestamps
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// ExtractTimestampData extracts data from a timestamp using a regex pattern.
// It returns a map of named capture groups from the configured pattern.
func (f *OutputFormatter) ExtractTimestampData(timestamp string) map[string]string <span class="cov8" title="1">{
        return f.extractPatternData(f.cfg.PatternTimestamp, timestamp)
}</span>

// CFG-003: Template-based archive formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatArchiveWithExtraction formats an archive message using template-based formatting.
// It extracts data from the archive filename and applies the configured template.
func (f *OutputFormatter) FormatArchiveWithExtraction(archivePath string) string <span class="cov8" title="1">{
        // Extract data from archive filename
        filename := getFilenameFromPath(archivePath)
        data := f.ExtractArchiveFilenameData(filename)
        data["path"] = archivePath

        // Use template formatting if we have extracted data
        if len(data) &gt; 1 </span><span class="cov8" title="1">{ // More than just "path"
                return f.FormatCreatedArchiveTemplate(data)
        }</span>

        // Fall back to printf-style formatting
        <span class="cov0" title="0">return f.FormatCreatedArchive(archivePath)</span>
}

// CFG-003: Template-based archive listing formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatListArchiveWithExtraction formats a list archive message using template-based formatting.
// It extracts data from the archive filename and applies the configured template.
func (f *OutputFormatter) FormatListArchiveWithExtraction(archivePath, creationTime string) string <span class="cov8" title="1">{
        // Extract data from archive filename
        filename := getFilenameFromPath(archivePath)
        data := f.ExtractArchiveFilenameData(filename)
        data["path"] = archivePath
        data["creation_time"] = creationTime

        // Use template formatting if we have extracted data
        if len(data) &gt; 2 </span><span class="cov8" title="1">{ // More than just "path" and "creation_time"
                return f.FormatListArchiveTemplate(data)
        }</span>

        // Fall back to printf-style formatting
        <span class="cov0" title="0">return f.FormatListArchive(archivePath, creationTime)</span>
}

func getFilenameFromPath(path string) string <span class="cov8" title="1">{
        parts := strings.Split(path, "/")
        if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                return parts[len(parts)-1]
        }</span>
        <span class="cov0" title="0">return path</span>
}

// CFG-003: Printf-style backup creation formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatCreatedBackup formats a message for a created backup.
func (f *OutputFormatter) FormatCreatedBackup(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatCreatedBackup, path)
}</span>

// CFG-003: Printf-style identical backup formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatIdenticalBackup formats a message for an identical backup.
func (f *OutputFormatter) FormatIdenticalBackup(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatIdenticalBackup, path)
}</span>

// CFG-003: Printf-style backup listing formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatListBackup formats a message for listing a backup.
func (f *OutputFormatter) FormatListBackup(path, creationTime string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatListBackup, path, creationTime)
}</span>

// CFG-003: Printf-style backup dry run formatting
// IMMUTABLE-REF: Output Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatDryRunBackup formats a message for a dry-run backup operation.
func (f *OutputFormatter) FormatDryRunBackup(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatDryRunBackup, path)
}</span>

// CFG-003: Template-based archive creation formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatCreatedArchiveTemplate formats a created archive message using a template.
func (f *OutputFormatter) FormatCreatedArchiveTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateCreatedArchive, data)
}</span>

// CFG-003: Template-based identical archive formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatIdenticalArchiveTemplate formats an identical archive message using a template.
func (f *OutputFormatter) FormatIdenticalArchiveTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateIdenticalArchive, data)
}</span>

// CFG-003: Template-based archive listing formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatListArchiveTemplate formats a list archive message using a template.
func (f *OutputFormatter) FormatListArchiveTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateListArchive, data)
}</span>

// FormatConfigValueTemplate formats a config value message using a template.
func (f *OutputFormatter) FormatConfigValueTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateConfigValue, data)
}</span>

// FormatDryRunArchiveTemplate formats a dry-run archive message using a template.
func (f *OutputFormatter) FormatDryRunArchiveTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateDryRunArchive, data)
}</span>

// FormatCreatedBackupTemplate formats a created backup message using a template.
func (f *OutputFormatter) FormatCreatedBackupTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateCreatedBackup, data)
}</span>

// FormatIdenticalBackupTemplate formats an identical backup message using a template.
func (f *OutputFormatter) FormatIdenticalBackupTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateIdenticalBackup, data)
}</span>

// FormatListBackupTemplate formats a list backup message using a template.
func (f *OutputFormatter) FormatListBackupTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateListBackup, data)
}</span>

// FormatDryRunBackupTemplate formats a dry-run backup message using a template.
func (f *OutputFormatter) FormatDryRunBackupTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateDryRunBackup, data)
}</span>

// Template formatting helper
func (f *OutputFormatter) formatTemplate(templateStr string, data map[string]string) string <span class="cov8" title="1">{
        // First handle %{name} style placeholders
        result := templateStr
        for key, value := range data </span><span class="cov8" title="1">{
                placeholder := fmt.Sprintf("%%{%s}", key)
                result = strings.ReplaceAll(result, placeholder, value)
        }</span>

        // Then handle Go text/template style {{.name}} placeholders
        <span class="cov8" title="1">tmpl, err := template.New("format").Parse(result)
        if err != nil </span><span class="cov0" title="0">{
                // Fall back to simple replacement if template parsing fails
                return result
        }</span>

        <span class="cov8" title="1">var buf strings.Builder
        if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                // Fall back to simple replacement if template execution fails
                return result
        }</span>

        <span class="cov8" title="1">return buf.String()</span>
}

// Regex pattern extraction methods
func (f *OutputFormatter) extractPatternData(pattern, text string) map[string]string <span class="cov8" title="1">{
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]string)
        }</span>

        <span class="cov8" title="1">matches := re.FindStringSubmatch(text)
        if matches == nil </span><span class="cov0" title="0">{
                return make(map[string]string)
        }</span>

        <span class="cov8" title="1">result := make(map[string]string)
        for i, name := range re.SubexpNames() </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; i &lt; len(matches) &amp;&amp; name != "" </span><span class="cov8" title="1">{
                        result[name] = matches[i]
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// CFG-003: Template-based formatting interface
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateFormatter provides methods for template-based output formatting.
// It supports both pattern-based and placeholder-based template formatting.
type TemplateFormatter struct {
        config *Config
}

// CFG-003: Template formatter constructor
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// NewTemplateFormatter creates a new TemplateFormatter with the given configuration.
// It initializes the formatter with the provided config for use in template operations.
func NewTemplateFormatter(cfg *Config) *TemplateFormatter <span class="cov8" title="1">{
        return &amp;TemplateFormatter{config: cfg}
}</span>

// CFG-003: Pattern-based template formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatWithTemplate formats input using a pattern and template string.
// It extracts data using the pattern and applies the template to the extracted data.
func (tf *TemplateFormatter) FormatWithTemplate(input, pattern, tmplStr string) (string, error) <span class="cov8" title="1">{
        // Extract data using regex pattern
        re, err := regexp.Compile(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("invalid regex pattern: %w", err)
        }</span>

        <span class="cov8" title="1">matches := re.FindStringSubmatch(input)
        if matches == nil </span><span class="cov0" title="0">{
                return tmplStr, nil // Return template as-is if no matches
        }</span>

        // Build data map from named groups
        <span class="cov8" title="1">data := make(map[string]string)
        for i, name := range re.SubexpNames() </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; i &lt; len(matches) &amp;&amp; name != "" </span><span class="cov8" title="1">{
                        data[name] = matches[i]
                }</span>
        }

        // Apply template formatting
        <span class="cov8" title="1">return tf.FormatWithPlaceholders(tmplStr, data), nil</span>
}

// CFG-003: Placeholder-based template formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatWithPlaceholders formats a string using placeholder-based template formatting.
// It replaces placeholders in the format string with values from the data map.
func (tf *TemplateFormatter) FormatWithPlaceholders(format string, data map[string]string) string <span class="cov8" title="1">{
        result := format

        // Handle %{name} style placeholders
        for key, value := range data </span><span class="cov8" title="1">{
                placeholder := fmt.Sprintf("%%{%s}", key)
                result = strings.ReplaceAll(result, placeholder, value)
        }</span>

        // Handle Go text/template style {{.name}} placeholders
        <span class="cov8" title="1">tmpl, err := template.New("format").Parse(result)
        if err != nil </span><span class="cov0" title="0">{
                // Fall back to simple replacement if template parsing fails
                return result
        }</span>

        <span class="cov8" title="1">var buf strings.Builder
        if err := tmpl.Execute(&amp;buf, data); err != nil </span><span class="cov0" title="0">{
                // Fall back to simple replacement if template execution fails
                return result
        }</span>

        <span class="cov8" title="1">return buf.String()</span>
}

// CFG-003: Template-based archive creation formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateCreatedArchive formats a created archive message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateCreatedArchive(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateCreatedArchive, data)
}</span>

// CFG-003: Template-based identical archive formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateIdenticalArchive formats an identical archive message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateIdenticalArchive(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateIdenticalArchive, data)
}</span>

// CFG-003: Template-based archive listing formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateListArchive formats a list archive message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateListArchive(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateListArchive, data)
}</span>

// CFG-003: Template-based configuration value formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateConfigValue formats a configuration value message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateConfigValue(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateConfigValue, data)
}</span>

// CFG-003: Template-based dry run formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateDryRunArchive formats a dry-run archive message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateDryRunArchive(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateDryRunArchive, data)
}</span>

// CFG-003: Template-based error formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateError formats an error message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateError(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateError, data)
}</span>

// CFG-003: Template-based backup creation formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateCreatedBackup formats a created backup message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateCreatedBackup(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateCreatedBackup, data)
}</span>

// CFG-003: Template-based identical backup formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateIdenticalBackup formats an identical backup message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateIdenticalBackup(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateIdenticalBackup, data)
}</span>

// CFG-003: Template-based backup listing formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateListBackup formats a list backup message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateListBackup(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateListBackup, data)
}</span>

// CFG-003: Template-based backup dry run formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// TemplateDryRunBackup formats a dry-run backup message using a template.
// It applies the configured template to the provided data map.
func (tf *TemplateFormatter) TemplateDryRunBackup(data map[string]string) string <span class="cov8" title="1">{
        return tf.FormatWithPlaceholders(tf.config.TemplateDryRunBackup, data)
}</span>

// CFG-003: Template-based archive creation printing
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// PrintTemplateCreatedArchive prints a created archive message using template formatting.
// It extracts data from the archive filename and prints the formatted message to stdout.
func (tf *TemplateFormatter) PrintTemplateCreatedArchive(path string) <span class="cov8" title="1">{
        // Extract data from archive filename
        filename := getFilenameFromPath(path)
        data := tf.extractArchiveData(filename)
        data["path"] = path
        fmt.Print(tf.TemplateCreatedArchive(data))
}</span>

// CFG-003: Template-based backup creation printing
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// PrintTemplateCreatedBackup prints a created backup message using template formatting.
// It extracts data from the backup filename and prints the formatted message to stdout.
func (tf *TemplateFormatter) PrintTemplateCreatedBackup(path string) <span class="cov8" title="1">{
        // Extract data from backup filename
        filename := getFilenameFromPath(path)
        data := tf.extractBackupData(filename)
        data["path"] = path
        fmt.Print(tf.TemplateCreatedBackup(data))
}</span>

// CFG-003: Template-based backup listing printing
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// PrintTemplateListBackup prints a list backup message using template formatting.
// It extracts data from the backup filename and prints the formatted message to stdout.
func (tf *TemplateFormatter) PrintTemplateListBackup(path, creationTime string) <span class="cov8" title="1">{
        // Extract data from backup filename
        filename := getFilenameFromPath(path)
        data := tf.extractBackupData(filename)
        data["path"] = path
        data["creation_time"] = creationTime
        fmt.Print(tf.TemplateListBackup(data))
}</span>

// CFG-003: Template-based error printing
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// PrintTemplateError prints an error message using template formatting.
// It formats the message with the provided operation and prints it to stderr.
func (tf *TemplateFormatter) PrintTemplateError(message, operation string) <span class="cov8" title="1">{
        data := map[string]string{
                "message":   message,
                "operation": operation,
        }
        fmt.Print(tf.TemplateError(data))
}</span>

// CFG-003: Archive data extraction
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// extractArchiveData extracts data from an archive filename using regex patterns.
// It returns a map of named capture groups from the configured patterns.
func (tf *TemplateFormatter) extractArchiveData(filename string) map[string]string <span class="cov8" title="1">{
        re, err := regexp.Compile(tf.config.PatternArchiveFilename)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]string)
        }</span>

        <span class="cov8" title="1">matches := re.FindStringSubmatch(filename)
        if matches == nil </span><span class="cov8" title="1">{
                return make(map[string]string)
        }</span>

        <span class="cov8" title="1">result := make(map[string]string)
        for i, name := range re.SubexpNames() </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; i &lt; len(matches) &amp;&amp; name != "" </span><span class="cov8" title="1">{
                        result[name] = matches[i]
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// CFG-003: Backup data extraction
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// extractBackupData extracts data from a backup filename using regex patterns.
// It returns a map of named capture groups from the configured patterns.
func (tf *TemplateFormatter) extractBackupData(filename string) map[string]string <span class="cov8" title="1">{
        re, err := regexp.Compile(tf.config.PatternBackupFilename)
        if err != nil </span><span class="cov0" title="0">{
                return make(map[string]string)
        }</span>

        <span class="cov8" title="1">matches := re.FindStringSubmatch(filename)
        if matches == nil </span><span class="cov8" title="1">{
                return make(map[string]string)
        }</span>

        <span class="cov8" title="1">result := make(map[string]string)
        for i, name := range re.SubexpNames() </span><span class="cov8" title="1">{
                if i &gt; 0 &amp;&amp; i &lt; len(matches) &amp;&amp; name != "" </span><span class="cov8" title="1">{
                        result[name] = matches[i]
                }</span>
        }

        <span class="cov8" title="1">return result</span>
}

// CFG-003: Template-based backup formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatBackupWithExtraction formats a backup message using template-based formatting.
// It extracts data from the backup filename and applies the configured template.
func (f *OutputFormatter) FormatBackupWithExtraction(backupPath string) string <span class="cov8" title="1">{
        // Extract data from backup filename
        filename := getFilenameFromPath(backupPath)
        data := f.ExtractBackupFilenameData(filename)
        data["path"] = backupPath

        // Use template formatting if we have extracted data
        if len(data) &gt; 1 </span><span class="cov8" title="1">{ // More than just "path"
                return f.FormatCreatedBackupTemplate(data)
        }</span>

        // Fall back to printf-style formatting
        <span class="cov0" title="0">return f.FormatCreatedBackup(backupPath)</span>
}

// CFG-003: Template-based backup listing formatting
// IMMUTABLE-REF: Template Formatting Requirements
// TEST-REF: TestTemplateFormatter
// DECISION-REF: DEC-003
// FormatListBackupWithExtraction formats a list backup message using template-based formatting.
// It extracts data from the backup filename and applies the configured template.
func (f *OutputFormatter) FormatListBackupWithExtraction(backupPath, creationTime string) string <span class="cov8" title="1">{
        // Extract data from backup filename
        filename := getFilenameFromPath(backupPath)
        data := f.ExtractBackupFilenameData(filename)
        data["path"] = backupPath
        data["creation_time"] = creationTime

        // Use template formatting if we have extracted data
        if len(data) &gt; 2 </span><span class="cov8" title="1">{ // More than just "path" and "creation_time"
                return f.FormatListBackupTemplate(data)
        }</span>

        // Fall back to printf-style formatting
        <span class="cov0" title="0">return f.FormatListBackup(backupPath, creationTime)</span>
}

// CFG-004: Incremental created formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatIncrementalCreated(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatIncrementalCreated, path)
}</span>

// Printf-style formatting methods for archive operations
// CFG-004: No archives found formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatNoArchivesFound(archiveDir string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatNoArchivesFound, archiveDir)
}</span>

// CFG-004: Verification failed formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatVerificationFailed(archiveName string, err error) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatVerificationFailed, archiveName, err)
}</span>

// CFG-004: Verification success formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatVerificationSuccess(archiveName string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatVerificationSuccess, archiveName)
}</span>

// CFG-004: Verification warning formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatVerificationWarning(archiveName string, err error) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatVerificationWarning, archiveName, err)
}</span>

// CFG-004: Configuration updated formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatConfigurationUpdated(key string, value interface{}) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatConfigurationUpdated, key, value)
}</span>

// CFG-004: Config file path formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatConfigFilePath(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatConfigFilePath, path)
}</span>

// CFG-004: Dry run files header formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatDryRunFilesHeader() string <span class="cov8" title="1">{
        return f.cfg.FormatDryRunFilesHeader
}</span>

// CFG-004: Dry run file entry formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatDryRunFileEntry(file string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatDryRunFileEntry, file)
}</span>

// CFG-004: No files modified formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatNoFilesModified() string <span class="cov8" title="1">{
        return f.cfg.FormatNoFilesModified
}</span>

// Printf-style formatting methods for backup operations
// CFG-004: No backups found formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatNoBackupsFound(filename, backupDir string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatNoBackupsFound, filename, backupDir)
}</span>

// CFG-004: Backup would create formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatBackupWouldCreate(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatBackupWouldCreate, path)
}</span>

// CFG-004: Backup identical formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatBackupIdentical(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatBackupIdentical, path)
}</span>

// CFG-004: Backup created formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatBackupCreated(path string) string <span class="cov8" title="1">{
        return fmt.Sprintf(f.cfg.FormatBackupCreated, path)
}</span>

// Template-based formatting methods for archive operations
// CFG-004: No archives found template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatNoArchivesFoundTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateNoArchivesFound, data)
}</span>

// CFG-004: Verification failed template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatVerificationFailedTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateVerificationFailed, data)
}</span>

// CFG-004: Verification success template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatVerificationSuccessTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateVerificationSuccess, data)
}</span>

// CFG-004: Verification warning template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatVerificationWarningTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateVerificationWarning, data)
}</span>

// CFG-004: Configuration updated template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatConfigurationUpdatedTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateConfigurationUpdated, data)
}</span>

// CFG-004: Config file path template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatConfigFilePathTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateConfigFilePath, data)
}</span>

// CFG-004: Dry run files header template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatDryRunFilesHeaderTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateDryRunFilesHeader, data)
}</span>

// CFG-004: Dry run file entry template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatDryRunFileEntryTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateDryRunFileEntry, data)
}</span>

// CFG-004: No files modified template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatNoFilesModifiedTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateNoFilesModified, data)
}</span>

// CFG-004: Incremental created template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatIncrementalCreatedTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateIncrementalCreated, data)
}</span>

// Template-based formatting methods for backup operations
// CFG-004: No backups found template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatNoBackupsFoundTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateNoBackupsFound, data)
}</span>

// CFG-004: Backup would create template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatBackupWouldCreateTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateBackupWouldCreate, data)
}</span>

// CFG-004: Backup identical template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatBackupIdenticalTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateBackupIdentical, data)
}</span>

// CFG-004: Backup created template formatting
// IMMUTABLE-REF: String externalization requirements
// TEST-REF: TestStringExternalization
// DECISION-REF: DEC-009
func (f *OutputFormatter) FormatBackupCreatedTemplate(data map[string]string) string <span class="cov8" title="1">{
        return f.formatTemplate(f.cfg.TemplateBackupCreated, data)
}</span>

// Print methods for CFG-004 format strings
// CFG-004: Print methods for archive operations
// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintNoArchivesFound(archiveDir string) <span class="cov8" title="1">{
        message := f.FormatNoArchivesFound(archiveDir)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintVerificationFailed(archiveName string, err error) <span class="cov8" title="1">{
        message := f.FormatVerificationFailed(archiveName, err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "error")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintVerificationSuccess(archiveName string) <span class="cov8" title="1">{
        message := f.FormatVerificationSuccess(archiveName)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintVerificationWarning(archiveName string, err error) <span class="cov8" title="1">{
        message := f.FormatVerificationWarning(archiveName, err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "warning")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintConfigurationUpdated(key string, value interface{}) <span class="cov8" title="1">{
        message := f.FormatConfigurationUpdated(key, value)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "config")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintConfigFilePath(path string) <span class="cov8" title="1">{
        message := f.FormatConfigFilePath(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "config")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintDryRunFilesHeader() <span class="cov8" title="1">{
        message := f.FormatDryRunFilesHeader()
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "dry-run")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintDryRunFileEntry(file string) <span class="cov8" title="1">{
        message := f.FormatDryRunFileEntry(file)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "dry-run")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintNoFilesModified() <span class="cov8" title="1">{
        message := f.FormatNoFilesModified()
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintIncrementalCreated(path string) <span class="cov8" title="1">{
        message := f.FormatIncrementalCreated(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// CFG-004: Print methods for backup operations
// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintNoBackupsFound(filename, backupDir string) <span class="cov8" title="1">{
        message := f.FormatNoBackupsFound(filename, backupDir)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintBackupWouldCreate(path string) <span class="cov8" title="1">{
        message := f.FormatBackupWouldCreate(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "dry-run")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintBackupIdentical(path string) <span class="cov8" title="1">{
        message := f.FormatBackupIdentical(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov0" title="0"> {
                fmt.Print(message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintBackupCreated(path string) <span class="cov8" title="1">{
        message := f.FormatBackupCreated(path)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// CFG-004: Error message formatting methods
func (f *OutputFormatter) FormatDiskFullError(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatDiskFullError, err)
}</span>

func (f *OutputFormatter) FormatPermissionError(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatPermissionError, err)
}</span>

func (f *OutputFormatter) FormatDirectoryNotFound(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatDirectoryNotFound, err)
}</span>

func (f *OutputFormatter) FormatFileNotFound(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatFileNotFound, err)
}</span>

func (f *OutputFormatter) FormatInvalidDirectory(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatInvalidDirectory, err)
}</span>

func (f *OutputFormatter) FormatInvalidFile(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatInvalidFile, err)
}</span>

func (f *OutputFormatter) FormatFailedWriteTemp(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatFailedWriteTemp, err)
}</span>

func (f *OutputFormatter) FormatFailedFinalizeFile(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatFailedFinalizeFile, err)
}</span>

func (f *OutputFormatter) FormatFailedCreateDirDisk(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatFailedCreateDirDisk, err)
}</span>

func (f *OutputFormatter) FormatFailedCreateDir(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatFailedCreateDir, err)
}</span>

func (f *OutputFormatter) FormatFailedAccessDir(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatFailedAccessDir, err)
}</span>

func (f *OutputFormatter) FormatFailedAccessFile(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        return fmt.Sprintf(f.cfg.FormatFailedAccessFile, err)
}</span>

// CFG-004: Template-based error message formatting methods
func (f *OutputFormatter) TemplateDiskFullError(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateDiskFullError, data)
}</span>

func (f *OutputFormatter) TemplatePermissionError(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplatePermissionError, data)
}</span>

func (f *OutputFormatter) TemplateDirectoryNotFound(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateDirectoryNotFound, data)
}</span>

func (f *OutputFormatter) TemplateFileNotFound(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateFileNotFound, data)
}</span>

func (f *OutputFormatter) TemplateInvalidDirectory(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateInvalidDirectory, data)
}</span>

func (f *OutputFormatter) TemplateInvalidFile(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateInvalidFile, data)
}</span>

func (f *OutputFormatter) TemplateFailedWriteTemp(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateFailedWriteTemp, data)
}</span>

func (f *OutputFormatter) TemplateFailedFinalizeFile(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateFailedFinalizeFile, data)
}</span>

func (f *OutputFormatter) TemplateFailedCreateDirDisk(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateFailedCreateDirDisk, data)
}</span>

func (f *OutputFormatter) TemplateFailedCreateDir(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateFailedCreateDir, data)
}</span>

func (f *OutputFormatter) TemplateFailedAccessDir(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateFailedAccessDir, data)
}</span>

func (f *OutputFormatter) TemplateFailedAccessFile(err error) string <span class="cov8" title="1">{
        // CFG-004: Implementation token
        data := map[string]string{
                "error": err.Error(),
        }
        return f.formatTemplate(f.cfg.TemplateFailedAccessFile, data)
}</span>

// CFG-004: Print methods for error messages
// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintDiskFullError(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatDiskFullError(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintPermissionError(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatPermissionError(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintDirectoryNotFound(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatDirectoryNotFound(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov8" title="1"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintFileNotFound(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatFileNotFound(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintInvalidDirectory(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatInvalidDirectory(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintInvalidFile(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatInvalidFile(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintFailedWriteTemp(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatFailedWriteTemp(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintFailedFinalizeFile(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatFailedFinalizeFile(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintFailedCreateDirDisk(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatFailedCreateDirDisk(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintFailedCreateDir(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatFailedCreateDir(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintFailedAccessDir(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatFailedAccessDir(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintFailedAccessFile(err error) <span class="cov8" title="1">{
        // CFG-004: Implementation token
        message := f.FormatFailedAccessFile(err)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStderr(message, "error")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprint(os.Stderr, message)
        }</span>
}

// CFG-004: Print method for verification error details
// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintVerificationErrorDetail(errMsg string) <span class="cov8" title="1">{
        message := fmt.Sprintf("  - %s\n", errMsg)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "error")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}

// CFG-004: Print method for archive list with status
// OUT-001: Enhanced with delayed output support
func (f *OutputFormatter) PrintArchiveListWithStatus(output, status string) <span class="cov8" title="1">{
        message := fmt.Sprintf("%s%s\n", output, status)
        if f.collector != nil </span><span class="cov8" title="1">{
                // OUT-001: Delayed output implementation
                f.collector.AddStdout(message, "info")
        }</span> else<span class="cov8" title="1"> {
                fmt.Print(message)
        }</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// This file is part of bkpdir
//
// Package main provides Git integration for archive naming and metadata in BkpDir.
// It handles Git branch and commit hash detection for archive naming.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License
package main

import (
        "fmt"
        "os/exec"
        "strings"
)

// GIT-001: Git error handling structure
// IMMUTABLE-REF: Error Handling Requirements
// TEST-REF: TestGitIntegration
// DECISION-REF: DEC-005
// GitError represents an error that occurred during Git operations.
// It includes the operation that failed and the underlying error.
type GitError struct {
        Operation string
        Err       error
}

func (e *GitError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("git %s failed: %v", e.Operation, e.Err)
}</span>

// GIT-001: Git repository detection implementation
// IMMUTABLE-REF: Git Integration Requirements
// TEST-REF: TestGitIntegration
// DECISION-REF: DEC-005
// IsGitRepository checks if the given directory is a Git repository.
// It uses git rev-parse to check if the directory is inside a git work tree.
func IsGitRepository(dir string) bool <span class="cov8" title="1">{
        cmd := exec.Command("git", "rev-parse", "--is-inside-work-tree")
        cmd.Dir = dir
        out, err := cmd.Output()
        return err == nil &amp;&amp; strings.TrimSpace(string(out)) == "true"
}</span>

// GIT-002: Git branch extraction implementation
// IMMUTABLE-REF: Git Integration Requirements, Archive Naming Convention
// TEST-REF: TestGitNaming
// DECISION-REF: DEC-005
// GetGitBranch returns the current Git branch name.
// It returns an empty string if not in a Git repository or on error.
func GetGitBranch(dir string) string <span class="cov8" title="1">{
        cmd := exec.Command("git", "rev-parse", "--abbrev-ref", "HEAD")
        cmd.Dir = dir
        out, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(string(out))</span>
}

// GIT-002: Git commit hash extraction implementation
// IMMUTABLE-REF: Git Integration Requirements, Archive Naming Convention
// TEST-REF: TestGitNaming
// DECISION-REF: DEC-005
// GetGitShortHash returns the short commit hash of the current HEAD.
// It returns an empty string if not in a Git repository or on error.
func GetGitShortHash(dir string) string <span class="cov8" title="1">{
        cmd := exec.Command("git", "rev-parse", "--short", "HEAD")
        cmd.Dir = dir
        out, err := cmd.Output()
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(string(out))</span>
}

// GIT-001: Combined Git information extraction
// IMMUTABLE-REF: Git Integration Requirements
// TEST-REF: TestGitIntegration
// DECISION-REF: DEC-005
// GetGitInfo returns both the branch name and commit hash.
// It returns empty strings if not in a Git repository or on error.
func GetGitInfo(dir string) (branch, hash string) <span class="cov8" title="1">{
        if !IsGitRepository(dir) </span><span class="cov8" title="1">{
                return "", ""
        }</span>
        <span class="cov8" title="1">return GetGitBranch(dir), GetGitShortHash(dir)</span>
}

// GIT-003: Git working directory state detection
// IMMUTABLE-REF: Git Integration Requirements
// TEST-REF: TestGitStatus
// DECISION-REF: DEC-005
// IsGitWorkingDirectoryClean checks if the Git working directory is clean (no uncommitted changes).
// It returns true if the working directory is clean, false if there are changes or not in a Git repository.
func IsGitWorkingDirectoryClean(dir string) bool <span class="cov8" title="1">{
        if !IsGitRepository(dir) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">cmd := exec.Command("git", "status", "--porcelain")
        cmd.Dir = dir
        out, err := cmd.Output()
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return len(strings.TrimSpace(string(out))) == 0</span>
}

// GIT-003: Combined Git information extraction with status
// IMMUTABLE-REF: Git Integration Requirements
// TEST-REF: TestGitStatus
// DECISION-REF: DEC-005
// GetGitInfoWithStatus returns branch name, commit hash, and working directory status.
// It returns empty strings and false for status if not in a Git repository or on error.
func GetGitInfoWithStatus(dir string) (branch, hash string, isClean bool) <span class="cov8" title="1">{
        if !IsGitRepository(dir) </span><span class="cov8" title="1">{
                return "", "", false
        }</span>
        <span class="cov8" title="1">return GetGitBranch(dir), GetGitShortHash(dir), IsGitWorkingDirectoryClean(dir)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// This file is part of bkpdir
//
// Package testutil provides testing infrastructure for complex scenarios,
// specifically context cancellation testing helpers for reliable testing
// of context-aware operations.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License

// TEST-INFRA-001-D: Context cancellation testing helpers
// DECISION-REF: DEC-007 (Context-aware operations)
// IMPLEMENTATION-NOTES: Use ticker-based timing control and goroutine coordination for deterministic cancellation testing

package testutil

import (
        "context"
        "fmt"
        "sync"
        "sync/atomic"
        "time"
)

// CancellationPoint represents a specific point in an operation where cancellation can be injected
type CancellationPoint struct {
        ID               string
        Name             string
        Description      string
        OperationStage   string
        CancellationFunc func(ctx context.Context) error
        ExecutionCount   int64
        InjectionEnabled bool
}

// ContextController provides controlled timing and cancellation for context testing
type ContextController struct {
        mu                sync.RWMutex
        baseContext       context.Context
        cancelFunc        context.CancelFunc
        timeout           time.Duration
        cancellationDelay time.Duration
        ticker            *time.Ticker
        stopTicker        chan bool
        isActive          bool
        events            []ContextEvent
        stats             ContextTestStats
}

// ContextEvent represents an event during context testing
type ContextEvent struct {
        Timestamp   time.Time
        Type        ContextEventType
        Description string
        PointID     string
        Error       error
}

// ContextEventType defines the type of context event
type ContextEventType int

// Context event types for tracking operations and cancellations
const (
        // EventOperationStart indicates an operation has started
        EventOperationStart ContextEventType = iota
        // EventCancellationTriggered indicates cancellation was triggered
        EventCancellationTriggered
        // EventTimeoutTriggered indicates a timeout occurred
        EventTimeoutTriggered
        // EventOperationComplete indicates an operation completed
        EventOperationComplete
        // EventOperationCancelled indicates an operation was cancelled
        EventOperationCancelled
        // EventPropagationVerified indicates propagation was verified
        EventPropagationVerified
        // EventPropagationFailed indicates propagation verification failed
        EventPropagationFailed
)

// ContextTestStats tracks statistics for context testing
type ContextTestStats struct {
        TotalOperations      int64
        CancelledOperations  int64
        TimeoutOperations    int64
        SuccessfulOperations int64
        FailedOperations     int64
        PropagationTests     int64
        PropagationFailures  int64
        AverageDuration      time.Duration
        TotalDuration        time.Duration
}

// CancellationManager manages cancellation point injection and timing
type CancellationManager struct {
        mu                 sync.RWMutex
        cancellationPoints map[string]*CancellationPoint
        controllers        map[string]*ContextController
        globalEnabled      bool
        stats              CancellationStats
}

// CancellationStats tracks cancellation testing statistics
type CancellationStats struct {
        TotalInjections      int64
        SuccessfulInjections int64
        FailedInjections     int64
        PointsRegistered     int64
        ControllersActive    int64
}

// ConcurrentTestConfig configures concurrent operation testing
type ConcurrentTestConfig struct {
        NumOperations       int
        MaxConcurrency      int
        OperationTimeout    time.Duration
        CancellationDelay   time.Duration
        StaggerStart        time.Duration
        EnableRandomization bool
        TestDuration        time.Duration
}

// ConcurrentTestResult contains results from concurrent testing
type ConcurrentTestResult struct {
        TotalOperations     int
        CompletedOperations int
        CancelledOperations int
        TimeoutOperations   int
        FailedOperations    int
        AverageDuration     time.Duration
        MaxDuration         time.Duration
        MinDuration         time.Duration
        ConcurrencyAchieved int
        ResourceLeaks       int
        PropagationFailures int
}

// PropagationTestConfig configures context propagation testing
type PropagationTestConfig struct {
        ChainDepth         int
        PropagationDelay   time.Duration
        VerificationPoints []string
        TimeoutDuration    time.Duration
        EnableDeepTrace    bool
}

// PropagationChain represents a chain of operations for propagation testing
type PropagationChain struct {
        ID             string
        Depth          int
        Operations     []PropagationOperation
        StartTime      time.Time
        EndTime        time.Time
        PropagationLog []PropagationEvent
        Success        bool
        Error          error
}

// PropagationOperation represents an operation in the propagation chain
type PropagationOperation struct {
        ID         string
        Name       string
        Depth      int
        StartTime  time.Time
        EndTime    time.Time
        Context    context.Context
        Success    bool
        Error      error
        Propagated bool
}

// PropagationEvent tracks propagation events
type PropagationEvent struct {
        Timestamp time.Time
        Depth     int
        Operation string
        EventType string
        Message   string
        Error     error
}

// NewContextController creates a new context controller for testing
func NewContextController(timeout time.Duration) *ContextController <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())

        controller := &amp;ContextController{
                baseContext:       ctx,
                cancelFunc:        cancel,
                timeout:           timeout,
                cancellationDelay: 0,
                stopTicker:        make(chan bool, 1),
                isActive:          false,
                events:            make([]ContextEvent, 0),
                stats:             ContextTestStats{},
        }

        return controller
}</span>

// SetCancellationDelay sets the delay before cancellation is triggered
func (cc *ContextController) SetCancellationDelay(delay time.Duration) <span class="cov8" title="1">{
        cc.mu.Lock()
        defer cc.mu.Unlock()
        cc.cancellationDelay = delay
}</span>

// StartControlledCancellation starts controlled cancellation with timing
func (cc *ContextController) StartControlledCancellation() context.Context <span class="cov8" title="1">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        if cc.isActive </span><span class="cov8" title="1">{
                return cc.baseContext
        }</span>

        <span class="cov8" title="1">cc.isActive = true

        // Create context with timeout if specified
        var ctx context.Context
        if cc.timeout &gt; 0 </span><span class="cov8" title="1">{
                ctx, _ = context.WithTimeout(cc.baseContext, cc.timeout)
        }</span> else<span class="cov8" title="1"> {
                ctx = cc.baseContext
        }</span>

        // Start cancellation timer if delay is specified
        <span class="cov8" title="1">if cc.cancellationDelay &gt; 0 </span><span class="cov8" title="1">{
                cc.ticker = time.NewTicker(cc.cancellationDelay)
                go cc.cancellationTimer()
        }</span>

        <span class="cov8" title="1">cc.recordEvent(EventOperationStart, "Controlled cancellation started", "", nil)
        atomic.AddInt64(&amp;cc.stats.TotalOperations, 1)

        return ctx</span>
}

// cancellationTimer handles delayed cancellation
func (cc *ContextController) cancellationTimer() <span class="cov8" title="1">{
        select </span>{
        case &lt;-cc.ticker.C:<span class="cov8" title="1">
                cc.triggerCancellation()</span>
        case &lt;-cc.stopTicker:<span class="cov0" title="0">
                cc.ticker.Stop()
                return</span>
        }
}

// triggerCancellation triggers the cancellation
func (cc *ContextController) triggerCancellation() <span class="cov8" title="1">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        if cc.cancelFunc != nil </span><span class="cov8" title="1">{
                cc.cancelFunc()
                cc.recordEvent(EventCancellationTriggered, "Cancellation triggered by timer", "", nil)
                atomic.AddInt64(&amp;cc.stats.CancelledOperations, 1)
        }</span>
}

// Stop stops the controller and cleans up resources
func (cc *ContextController) Stop() <span class="cov8" title="1">{
        cc.mu.Lock()
        defer cc.mu.Unlock()

        if cc.ticker != nil </span><span class="cov8" title="1">{
                cc.stopTicker &lt;- true
                cc.ticker.Stop()
        }</span>

        <span class="cov8" title="1">if cc.cancelFunc != nil </span><span class="cov8" title="1">{
                cc.cancelFunc()
        }</span>

        <span class="cov8" title="1">cc.isActive = false
        cc.recordEvent(EventOperationComplete, "Controller stopped", "", nil)</span>
}

// recordEvent records a context event
func (cc *ContextController) recordEvent(eventType ContextEventType, description, pointID string, err error) <span class="cov8" title="1">{
        event := ContextEvent{
                Timestamp:   time.Now(),
                Type:        eventType,
                Description: description,
                PointID:     pointID,
                Error:       err,
        }
        cc.events = append(cc.events, event)
}</span>

// GetEvents returns all recorded events
func (cc *ContextController) GetEvents() []ContextEvent <span class="cov8" title="1">{
        cc.mu.RLock()
        defer cc.mu.RUnlock()

        events := make([]ContextEvent, len(cc.events))
        copy(events, cc.events)
        return events
}</span>

// GetStats returns current statistics
func (cc *ContextController) GetStats() ContextTestStats <span class="cov8" title="1">{
        cc.mu.RLock()
        defer cc.mu.RUnlock()

        stats := cc.stats
        stats.TotalOperations = atomic.LoadInt64(&amp;cc.stats.TotalOperations)
        stats.CancelledOperations = atomic.LoadInt64(&amp;cc.stats.CancelledOperations)
        stats.TimeoutOperations = atomic.LoadInt64(&amp;cc.stats.TimeoutOperations)
        stats.SuccessfulOperations = atomic.LoadInt64(&amp;cc.stats.SuccessfulOperations)
        stats.FailedOperations = atomic.LoadInt64(&amp;cc.stats.FailedOperations)
        stats.PropagationTests = atomic.LoadInt64(&amp;cc.stats.PropagationTests)
        stats.PropagationFailures = atomic.LoadInt64(&amp;cc.stats.PropagationFailures)

        return stats
}</span>

// NewCancellationManager creates a new cancellation manager
func NewCancellationManager() *CancellationManager <span class="cov8" title="1">{
        return &amp;CancellationManager{
                cancellationPoints: make(map[string]*CancellationPoint),
                controllers:        make(map[string]*ContextController),
                globalEnabled:      true,
                stats:              CancellationStats{},
        }
}</span>

// RegisterCancellationPoint registers a new cancellation point
func (cm *CancellationManager) RegisterCancellationPoint(point *CancellationPoint) <span class="cov8" title="1">{
        cm.mu.Lock()
        defer cm.mu.Unlock()

        cm.cancellationPoints[point.ID] = point
        atomic.AddInt64(&amp;cm.stats.PointsRegistered, 1)
}</span>

// InjectCancellation injects cancellation at a specific point
func (cm *CancellationManager) InjectCancellation(pointID string, ctx context.Context) error <span class="cov8" title="1">{
        cm.mu.RLock()
        point, exists := cm.cancellationPoints[pointID]
        cm.mu.RUnlock()

        if !exists || !cm.globalEnabled || !point.InjectionEnabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">atomic.AddInt64(&amp;point.ExecutionCount, 1)
        atomic.AddInt64(&amp;cm.stats.TotalInjections, 1)

        if point.CancellationFunc != nil </span><span class="cov8" title="1">{
                err := point.CancellationFunc(ctx)
                if err != nil </span><span class="cov8" title="1">{
                        atomic.AddInt64(&amp;cm.stats.FailedInjections, 1)
                        return err
                }</span>
                <span class="cov8" title="1">atomic.AddInt64(&amp;cm.stats.SuccessfulInjections, 1)</span>
        }

        <span class="cov8" title="1">return ctx.Err()</span> // Return cancellation error if context is cancelled
}

// EnableGlobal enables or disables global cancellation injection
func (cm *CancellationManager) EnableGlobal(enabled bool) <span class="cov8" title="1">{
        cm.mu.Lock()
        defer cm.mu.Unlock()
        cm.globalEnabled = enabled
}</span>

// EnablePoint enables or disables a specific cancellation point
func (cm *CancellationManager) EnablePoint(pointID string, enabled bool) <span class="cov8" title="1">{
        cm.mu.RLock()
        point, exists := cm.cancellationPoints[pointID]
        cm.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                point.InjectionEnabled = enabled
        }</span>
}

// GetStats returns cancellation manager statistics
func (cm *CancellationManager) GetStats() CancellationStats <span class="cov8" title="1">{
        cm.mu.RLock()
        defer cm.mu.RUnlock()

        stats := cm.stats
        stats.TotalInjections = atomic.LoadInt64(&amp;cm.stats.TotalInjections)
        stats.SuccessfulInjections = atomic.LoadInt64(&amp;cm.stats.SuccessfulInjections)
        stats.FailedInjections = atomic.LoadInt64(&amp;cm.stats.FailedInjections)
        stats.PointsRegistered = atomic.LoadInt64(&amp;cm.stats.PointsRegistered)
        stats.ControllersActive = atomic.LoadInt64(&amp;cm.stats.ControllersActive)

        return stats
}</span>

// RunConcurrentTest runs a concurrent operation test with cancellation
func (cm *CancellationManager) RunConcurrentTest(
        config ConcurrentTestConfig,
        operationFunc func(ctx context.Context) error,
) *ConcurrentTestResult <span class="cov8" title="1">{
        result := &amp;ConcurrentTestResult{
                TotalOperations: config.NumOperations,
        }

        var wg sync.WaitGroup
        semaphore := make(chan struct{}, config.MaxConcurrency)
        results := make(chan operationResult, config.NumOperations)

        // Start operations
        for i := 0; i &lt; config.NumOperations; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go func(opID int) </span><span class="cov8" title="1">{
                        defer wg.Done()

                        // Acquire semaphore slot
                        semaphore &lt;- struct{}{}
                        defer func() </span><span class="cov8" title="1">{ &lt;-semaphore }</span>()

                        // Optional stagger start
                        <span class="cov8" title="1">if config.StaggerStart &gt; 0 </span><span class="cov0" title="0">{
                                time.Sleep(time.Duration(opID) * config.StaggerStart)
                        }</span>

                        // Create context with timeout
                        <span class="cov8" title="1">ctx, cancel := context.WithTimeout(
                                context.Background(),
                                config.OperationTimeout,
                        )
                        defer cancel()

                        // Optional cancellation delay
                        if config.CancellationDelay &gt; 0 </span><span class="cov8" title="1">{
                                go func() </span><span class="cov8" title="1">{
                                        time.Sleep(config.CancellationDelay)
                                        cancel()
                                }</span>()
                        }

                        <span class="cov8" title="1">opStart := time.Now()
                        err := operationFunc(ctx)
                        duration := time.Since(opStart)

                        results &lt;- operationResult{
                                ID:        opID,
                                Duration:  duration,
                                Error:     err,
                                Cancelled: ctx.Err() == context.Canceled,
                                Timeout:   ctx.Err() == context.DeadlineExceeded,
                        }</span>
                }(i)
        }

        // Close results channel when all operations complete
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                wg.Wait()
                close(results)
        }</span>()

        // Collect results
        <span class="cov8" title="1">durations := make([]time.Duration, 0, config.NumOperations)

        for opResult := range results </span><span class="cov8" title="1">{
                durations = append(durations, opResult.Duration)

                if opResult.Error != nil </span><span class="cov8" title="1">{
                        result.FailedOperations++
                }</span> else<span class="cov8" title="1"> {
                        result.CompletedOperations++
                }</span>

                <span class="cov8" title="1">if opResult.Cancelled </span><span class="cov8" title="1">{
                        result.CancelledOperations++
                }</span>

                <span class="cov8" title="1">if opResult.Timeout </span><span class="cov8" title="1">{
                        result.TimeoutOperations++
                }</span>
        }

        // Calculate statistics
        <span class="cov8" title="1">if len(durations) &gt; 0 </span><span class="cov8" title="1">{
                var totalDuration time.Duration
                result.MinDuration = durations[0]
                result.MaxDuration = durations[0]

                for _, d := range durations </span><span class="cov8" title="1">{
                        totalDuration += d
                        if d &lt; result.MinDuration </span><span class="cov8" title="1">{
                                result.MinDuration = d
                        }</span>
                        <span class="cov8" title="1">if d &gt; result.MaxDuration </span><span class="cov8" title="1">{
                                result.MaxDuration = d
                        }</span>
                }

                <span class="cov8" title="1">result.AverageDuration = totalDuration / time.Duration(len(durations))</span>
        }

        <span class="cov8" title="1">result.ConcurrencyAchieved = config.MaxConcurrency

        return result</span>
}

// operationResult represents the result of a single operation
type operationResult struct {
        ID        int
        Duration  time.Duration
        Error     error
        Cancelled bool
        Timeout   bool
}

// TestPropagation tests context propagation through a chain of operations
func (cm *CancellationManager) TestPropagation(config PropagationTestConfig) *PropagationChain <span class="cov8" title="1">{
        chain := &amp;PropagationChain{
                ID:             fmt.Sprintf("chain-%d", time.Now().UnixNano()),
                Depth:          config.ChainDepth,
                Operations:     make([]PropagationOperation, 0, config.ChainDepth),
                StartTime:      time.Now(),
                PropagationLog: make([]PropagationEvent, 0),
                Success:        true,
        }

        // Create base context with timeout
        ctx, cancel := context.WithTimeout(context.Background(), config.TimeoutDuration)
        defer cancel()

        // Start propagation chain
        chain.Error = cm.executePropagationChain(ctx, chain, config, 0)
        chain.EndTime = time.Now()

        if chain.Error != nil </span><span class="cov0" title="0">{
                chain.Success = false
        }</span>

        <span class="cov8" title="1">return chain</span>
}

// executePropagationChain recursively executes the propagation chain
func (cm *CancellationManager) executePropagationChain(ctx context.Context, chain *PropagationChain, config PropagationTestConfig, depth int) error <span class="cov8" title="1">{
        if depth &gt;= config.ChainDepth </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">operation := PropagationOperation{
                ID:        fmt.Sprintf("op-%d-%d", depth, time.Now().UnixNano()),
                Name:      fmt.Sprintf("Operation Level %d", depth),
                Depth:     depth,
                StartTime: time.Now(),
                Context:   ctx,
                Success:   true,
        }

        // Check context at this level
        if err := ctx.Err(); err != nil </span><span class="cov0" title="0">{
                operation.Success = false
                operation.Error = err
                operation.Propagated = true
                chain.Operations = append(chain.Operations, operation)

                chain.PropagationLog = append(chain.PropagationLog, PropagationEvent{
                        Timestamp: time.Now(),
                        Depth:     depth,
                        Operation: operation.Name,
                        EventType: "cancellation_propagated",
                        Message:   fmt.Sprintf("Context cancellation propagated to depth %d", depth),
                        Error:     err,
                })

                return err
        }</span>

        // Simulate work with propagation delay
        <span class="cov8" title="1">if config.PropagationDelay &gt; 0 </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-time.After(config.PropagationDelay):<span class="cov8" title="1"></span>
                        // Continue
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        operation.Success = false
                        operation.Error = ctx.Err()
                        operation.Propagated = true
                        operation.EndTime = time.Now()
                        chain.Operations = append(chain.Operations, operation)
                        return ctx.Err()</span>
                }
        }

        // Continue to next level
        <span class="cov8" title="1">err := cm.executePropagationChain(ctx, chain, config, depth+1)
        operation.EndTime = time.Now()

        if err != nil </span><span class="cov8" title="1">{
                operation.Error = err
                operation.Success = false
                operation.Propagated = true
        }</span>

        <span class="cov8" title="1">chain.Operations = append(chain.Operations, operation)
        return err</span>
}

// CreateTimeoutContext creates a context with specified timeout for testing
func CreateTimeoutContext(timeout time.Duration) (context.Context, context.CancelFunc) <span class="cov8" title="1">{
        return context.WithTimeout(context.Background(), timeout)
}</span>

// CreateCancelledContext creates a pre-cancelled context for testing
func CreateCancelledContext() context.Context <span class="cov8" title="1">{
        ctx, cancel := context.WithCancel(context.Background())
        cancel()
        return ctx
}</span>

// CreateDeadlineContext creates a context with a deadline in the past for testing
func CreateDeadlineContext() context.Context <span class="cov8" title="1">{
        deadline := time.Now().Add(-1 * time.Second)
        ctx, _ := context.WithDeadline(context.Background(), deadline)
        return ctx
}</span>

// SimulateSlowOperation simulates a slow operation that can be cancelled
func SimulateSlowOperation(ctx context.Context, duration time.Duration, checkInterval time.Duration) error <span class="cov8" title="1">{
        ticker := time.NewTicker(checkInterval)
        defer ticker.Stop()

        endTime := time.Now().Add(duration)

        for time.Now().Before(endTime) </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>
                case &lt;-ticker.C:<span class="cov8" title="1"></span>
                        // Continue operation
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// VerifyContextPropagation verifies that context cancellation properly propagates
func VerifyContextPropagation(
        ctx context.Context,
        operationFunc func(context.Context) error,
) error <span class="cov8" title="1">{
        // Run operation and verify it respects context cancellation
        done := make(chan error, 1)

        go func() </span><span class="cov8" title="1">{
                done &lt;- operationFunc(ctx)
        }</span>()

        <span class="cov8" title="1">select </span>{
        case err := &lt;-done:<span class="cov8" title="1">
                if ctx.Err() != nil &amp;&amp; err != ctx.Err() </span><span class="cov8" title="1">{
                        return fmt.Errorf(
                                "operation did not properly handle context cancellation: expected %v, got %v",
                                ctx.Err(), err,
                        )
                }</span>
                <span class="cov8" title="1">return err</span>
        case &lt;-time.After(5 * time.Second):<span class="cov8" title="1">
                return fmt.Errorf(
                        "operation did not complete or respect cancellation within timeout",
                )</span>
        }
}

// Helper functions for common cancellation testing scenarios

// CreateArchiveCancellationPoint creates a cancellation point for archive operations
func CreateArchiveCancellationPoint(stage string) *CancellationPoint <span class="cov8" title="1">{
        return &amp;CancellationPoint{
                ID:               fmt.Sprintf("archive_%s", stage),
                Name:             fmt.Sprintf("Archive %s", stage),
                Description:      fmt.Sprintf("Cancellation point during archive %s", stage),
                OperationStage:   stage,
                InjectionEnabled: true,
                CancellationFunc: func(ctx context.Context) error </span><span class="cov8" title="1">{
                        return ctx.Err()
                }</span>,
        }
}

// CreateBackupCancellationPoint creates a cancellation point for backup operations
func CreateBackupCancellationPoint(stage string) *CancellationPoint <span class="cov8" title="1">{
        return &amp;CancellationPoint{
                ID:               fmt.Sprintf("backup_%s", stage),
                Name:             fmt.Sprintf("Backup %s", stage),
                Description:      fmt.Sprintf("Cancellation point during backup %s", stage),
                OperationStage:   stage,
                InjectionEnabled: true,
                CancellationFunc: func(ctx context.Context) error </span><span class="cov8" title="1">{
                        return ctx.Err()
                }</span>,
        }
}

// CreateResourceCleanupCancellationPoint creates a cancellation point for resource cleanup
func CreateResourceCleanupCancellationPoint() *CancellationPoint <span class="cov8" title="1">{
        return &amp;CancellationPoint{
                ID:               "resource_cleanup",
                Name:             "Resource Cleanup",
                Description:      "Cancellation point during resource cleanup",
                OperationStage:   "cleanup",
                InjectionEnabled: true,
                CancellationFunc: func(ctx context.Context) error </span><span class="cov0" title="0">{
                        return ctx.Err()
                }</span>,
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">// This file is part of bkpdir
//
// Package testutil provides testing infrastructure for complex scenarios,
// specifically archive corruption testing utilities.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License

// TEST-INFRA-001-A: Archive corruption testing framework
// DECISION-REF: DEC-001 (ZIP format)
// IMPLEMENTATION-NOTES: Provides systematic corruption for verification testing

package testutil

import (
        "archive/zip"
        "crypto/rand"
        "encoding/binary"
        "fmt"
        "io"
        "os"
        "sort"
)

// CorruptionType represents different types of archive corruption
type CorruptionType int

const (
        // CRC errors - corrupt file checksums
        CorruptionCRC CorruptionType = iota
        // Header corruption - corrupt ZIP file headers
        CorruptionHeader
        // File truncation - cut off end of archive
        CorruptionTruncate
        // Central directory corruption - corrupt ZIP central directory
        CorruptionCentralDir
        // Local header corruption - corrupt individual file headers
        CorruptionLocalHeader
        // Data corruption - corrupt actual file data
        CorruptionData
        // Signature corruption - corrupt ZIP file signatures
        CorruptionSignature
        // Comment corruption - corrupt archive comments
        CorruptionComment
)

// CorruptionConfig configures how corruption should be applied
type CorruptionConfig struct {
        Type           CorruptionType
        Seed           int64   // For reproducible corruption
        TargetFile     string  // Specific file to corrupt (empty for archive-level)
        CorruptionSize int     // Number of bytes to corrupt
        Offset         int     // Byte offset for corruption (-1 for random)
        Severity       float32 // 0.0-1.0, how severe the corruption should be
}

// CorruptionResult contains information about applied corruption
type CorruptionResult struct {
        Type           CorruptionType
        AppliedAt      []int  // Byte offsets where corruption was applied
        OriginalBytes  []byte // Original bytes for potential recovery
        CorruptedBytes []byte // The corrupted bytes that were written
        Description    string // Human-readable description of corruption
        Recoverable    bool   // Whether this corruption can be recovered from
}

// ArchiveCorruptor provides utilities for controlled ZIP corruption
type ArchiveCorruptor struct {
        originalPath string
        backupPath   string
        config       CorruptionConfig
}

// NewArchiveCorruptor creates a new archive corruptor for the given archive
func NewArchiveCorruptor(archivePath string, config CorruptionConfig) (*ArchiveCorruptor, error) <span class="cov8" title="1">{
        if _, err := os.Stat(archivePath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("archive file does not exist: %s", archivePath)
        }</span>

        <span class="cov8" title="1">backupPath := archivePath + ".corruption-backup"

        return &amp;ArchiveCorruptor{
                originalPath: archivePath,
                backupPath:   backupPath,
                config:       config,
        }, nil</span>
}

// CreateBackup creates a backup of the original archive
func (ac *ArchiveCorruptor) CreateBackup() error <span class="cov8" title="1">{
        input, err := os.Open(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open original archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer input.Close()

        output, err := os.Create(ac.backupPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create backup: %w", err)
        }</span>
        <span class="cov8" title="1">defer output.Close()

        _, err = io.Copy(output, input)
        return err</span>
}

// RestoreFromBackup restores the archive from backup
func (ac *ArchiveCorruptor) RestoreFromBackup() error <span class="cov8" title="1">{
        if _, err := os.Stat(ac.backupPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("backup file does not exist: %s", ac.backupPath)
        }</span>

        <span class="cov8" title="1">return os.Rename(ac.backupPath, ac.originalPath)</span>
}

// Cleanup removes the backup file
func (ac *ArchiveCorruptor) Cleanup() error <span class="cov8" title="1">{
        if _, err := os.Stat(ac.backupPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil // Nothing to clean up
        }</span>
        <span class="cov8" title="1">return os.Remove(ac.backupPath)</span>
}

// ApplyCorruption applies the configured corruption to the archive
func (ac *ArchiveCorruptor) ApplyCorruption() (*CorruptionResult, error) <span class="cov8" title="1">{
        // Create backup first
        if err := ac.CreateBackup(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create backup: %w", err)
        }</span>

        <span class="cov8" title="1">switch ac.config.Type </span>{
        case CorruptionCRC:<span class="cov8" title="1">
                return ac.corruptCRC()</span>
        case CorruptionHeader:<span class="cov8" title="1">
                return ac.corruptHeader()</span>
        case CorruptionTruncate:<span class="cov8" title="1">
                return ac.corruptTruncate()</span>
        case CorruptionCentralDir:<span class="cov8" title="1">
                return ac.corruptCentralDirectory()</span>
        case CorruptionLocalHeader:<span class="cov0" title="0">
                return ac.corruptLocalHeader()</span>
        case CorruptionData:<span class="cov8" title="1">
                return ac.corruptData()</span>
        case CorruptionSignature:<span class="cov8" title="1">
                return ac.corruptSignature()</span>
        case CorruptionComment:<span class="cov8" title="1">
                return ac.corruptComment()</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("unsupported corruption type: %d", ac.config.Type)</span>
        }
}

// findLocalHeaderOffsets finds all local header offsets in a deterministic order
func (ac *ArchiveCorruptor) findLocalHeaderOffsets(data []byte) []int <span class="cov8" title="1">{
        var offsets []int
        for i := 0; i &lt; len(data)-4; i++ </span><span class="cov8" title="1">{
                // Look for local file header signature (0x04034b50)
                if binary.LittleEndian.Uint32(data[i:i+4]) == 0x04034b50 </span><span class="cov8" title="1">{
                        offsets = append(offsets, i)
                }</span>
        }
        // Sort to ensure deterministic order
        <span class="cov8" title="1">sort.Ints(offsets)
        return offsets</span>
}

// corruptCRC corrupts file CRC checksums
func (ac *ArchiveCorruptor) corruptCRC() (*CorruptionResult, error) <span class="cov8" title="1">{
        // Read entire file into memory for manipulation
        data, err := os.ReadFile(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read archive: %w", err)
        }</span>

        <span class="cov8" title="1">result := &amp;CorruptionResult{
                Type:        CorruptionCRC,
                Description: "Corrupted CRC checksums in ZIP headers",
                Recoverable: true, // CRC errors are often recoverable
        }

        // Find all local header offsets in deterministic order
        headerOffsets := ac.findLocalHeaderOffsets(data)

        corruptedCount := 0
        for _, headerOffset := range headerOffsets </span><span class="cov8" title="1">{
                crcOffset := headerOffset + 14 // CRC is at offset 14 from header start
                if crcOffset+4 &lt;= len(data) </span><span class="cov8" title="1">{
                        // Store original bytes
                        originalCRC := make([]byte, 4)
                        copy(originalCRC, data[crcOffset:crcOffset+4])
                        result.OriginalBytes = append(result.OriginalBytes, originalCRC...)

                        // Generate corrupted CRC using seed for reproducibility
                        corruptedCRC := make([]byte, 4)
                        if ac.config.Seed != 0 </span><span class="cov8" title="1">{
                                // Use seed + offset for deterministic but different corruption per location
                                seedValue := uint32(ac.config.Seed + int64(headerOffset))
                                binary.LittleEndian.PutUint32(corruptedCRC, seedValue)
                        }</span> else<span class="cov0" title="0"> {
                                rand.Read(corruptedCRC)
                        }</span>

                        // Apply corruption
                        <span class="cov8" title="1">copy(data[crcOffset:crcOffset+4], corruptedCRC)
                        result.AppliedAt = append(result.AppliedAt, crcOffset)
                        result.CorruptedBytes = append(result.CorruptedBytes, corruptedCRC...)
                        corruptedCount++

                        if ac.config.CorruptionSize &gt; 0 &amp;&amp; corruptedCount &gt;= ac.config.CorruptionSize </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if corruptedCount == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no CRC locations found to corrupt")
        }</span>

        <span class="cov8" title="1">result.Description = fmt.Sprintf("Corrupted %d CRC checksums", corruptedCount)

        // Write corrupted data back to file
        return result, os.WriteFile(ac.originalPath, data, 0644)</span>
}

// corruptHeader corrupts ZIP file headers - more aggressively to ensure unreadability
func (ac *ArchiveCorruptor) corruptHeader() (*CorruptionResult, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read archive: %w", err)
        }</span>

        <span class="cov8" title="1">result := &amp;CorruptionResult{
                Type:        CorruptionHeader,
                Description: "Corrupted ZIP file headers",
                Recoverable: false, // Header corruption is usually fatal
        }

        // Find first local file header and corrupt multiple fields to ensure unreadability
        headerOffsets := ac.findLocalHeaderOffsets(data)
        if len(headerOffsets) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no headers found to corrupt")
        }</span>

        <span class="cov8" title="1">headerOffset := headerOffsets[0]

        // Corrupt signature (first 4 bytes)
        if headerOffset+4 &lt;= len(data) </span><span class="cov8" title="1">{
                result.OriginalBytes = make([]byte, 4)
                copy(result.OriginalBytes, data[headerOffset:headerOffset+4])

                // Use recognizably corrupted signature
                corruptedSig := []byte{0xDE, 0xAD, 0xBE, 0xEF}
                if ac.config.Seed != 0 </span><span class="cov8" title="1">{
                        binary.LittleEndian.PutUint32(corruptedSig, uint32(ac.config.Seed))
                }</span>

                <span class="cov8" title="1">copy(data[headerOffset:headerOffset+4], corruptedSig)
                result.AppliedAt = append(result.AppliedAt, headerOffset)
                result.CorruptedBytes = append(result.CorruptedBytes, corruptedSig...)</span>
        }

        // Also corrupt version field for good measure
        <span class="cov8" title="1">versionOffset := headerOffset + 4
        if versionOffset+2 &lt;= len(data) </span><span class="cov8" title="1">{
                originalVersion := make([]byte, 2)
                copy(originalVersion, data[versionOffset:versionOffset+2])
                result.OriginalBytes = append(result.OriginalBytes, originalVersion...)

                corruptedVersion := []byte{0xFF, 0xFF}
                copy(data[versionOffset:versionOffset+2], corruptedVersion)
                result.AppliedAt = append(result.AppliedAt, versionOffset)
                result.CorruptedBytes = append(result.CorruptedBytes, corruptedVersion...)
        }</span>

        <span class="cov8" title="1">return result, os.WriteFile(ac.originalPath, data, 0644)</span>
}

// corruptTruncate truncates the archive file
func (ac *ArchiveCorruptor) corruptTruncate() (*CorruptionResult, error) <span class="cov8" title="1">{
        info, err := os.Stat(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to stat archive: %w", err)
        }</span>

        <span class="cov8" title="1">originalSize := info.Size()
        truncateSize := originalSize

        if ac.config.CorruptionSize &gt; 0 </span><span class="cov8" title="1">{
                truncateSize = originalSize - int64(ac.config.CorruptionSize)
        }</span> else<span class="cov0" title="0"> {
                // Default: truncate 10% of the file
                truncateSize = int64(float64(originalSize) * (1.0 - float64(ac.config.Severity)))
        }</span>

        <span class="cov8" title="1">if truncateSize &lt; 0 </span><span class="cov0" title="0">{
                truncateSize = 0
        }</span>

        <span class="cov8" title="1">err = os.Truncate(ac.originalPath, truncateSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to truncate archive: %w", err)
        }</span>

        <span class="cov8" title="1">result := &amp;CorruptionResult{
                Type:        CorruptionTruncate,
                AppliedAt:   []int{int(truncateSize)},
                Description: fmt.Sprintf("Truncated archive from %d to %d bytes", originalSize, truncateSize),
                Recoverable: false, // Truncation loses data permanently
        }

        return result, nil</span>
}

// corruptCentralDirectory corrupts the ZIP central directory
func (ac *ArchiveCorruptor) corruptCentralDirectory() (*CorruptionResult, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read archive: %w", err)
        }</span>

        <span class="cov8" title="1">result := &amp;CorruptionResult{
                Type:        CorruptionCentralDir,
                Description: "Corrupted ZIP central directory",
                Recoverable: false, // Central directory corruption is usually fatal
        }

        // Find End of Central Directory signature (0x06054b50)
        for i := len(data) - 4; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if binary.LittleEndian.Uint32(data[i:i+4]) == 0x06054b50 </span><span class="cov8" title="1">{
                        // Found EOCD, now corrupt central directory offset
                        if i+16 &lt; len(data) </span><span class="cov8" title="1">{
                                cdOffset := i + 16 // Central directory offset is at this position

                                // Store original bytes
                                result.OriginalBytes = make([]byte, 4)
                                copy(result.OriginalBytes, data[cdOffset:cdOffset+4])

                                // Corrupt the offset
                                corruptedOffset := make([]byte, 4)
                                if ac.config.Seed != 0 </span><span class="cov8" title="1">{
                                        binary.LittleEndian.PutUint32(corruptedOffset, uint32(ac.config.Seed))
                                }</span> else<span class="cov0" title="0"> {
                                        binary.LittleEndian.PutUint32(corruptedOffset, 0xFFFFFFFF)
                                }</span>

                                <span class="cov8" title="1">copy(data[cdOffset:cdOffset+4], corruptedOffset)
                                result.AppliedAt = append(result.AppliedAt, cdOffset)
                                result.CorruptedBytes = corruptedOffset
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(result.AppliedAt) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no central directory found to corrupt")
        }</span>

        <span class="cov8" title="1">return result, os.WriteFile(ac.originalPath, data, 0644)</span>
}

// corruptLocalHeader corrupts local file headers
func (ac *ArchiveCorruptor) corruptLocalHeader() (*CorruptionResult, error) <span class="cov0" title="0">{
        data, err := os.ReadFile(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read archive: %w", err)
        }</span>

        <span class="cov0" title="0">result := &amp;CorruptionResult{
                Type:        CorruptionLocalHeader,
                Description: "Corrupted local file headers",
                Recoverable: true, // Sometimes recoverable with repair tools
        }

        // Find local file headers and corrupt version field
        headerOffsets := ac.findLocalHeaderOffsets(data)

        corruptedCount := 0
        for _, headerOffset := range headerOffsets </span><span class="cov0" title="0">{
                versionOffset := headerOffset + 4 // Version field is right after signature

                if versionOffset+2 &lt;= len(data) </span><span class="cov0" title="0">{
                        // Store original bytes
                        original := make([]byte, 2)
                        copy(original, data[versionOffset:versionOffset+2])
                        result.OriginalBytes = append(result.OriginalBytes, original...)

                        // Corrupt version field
                        corruptedVersion := []byte{0xFF, 0xFF}
                        if ac.config.Seed != 0 </span><span class="cov0" title="0">{
                                binary.LittleEndian.PutUint16(corruptedVersion, uint16(ac.config.Seed+int64(headerOffset)))
                        }</span>

                        <span class="cov0" title="0">copy(data[versionOffset:versionOffset+2], corruptedVersion)
                        result.AppliedAt = append(result.AppliedAt, versionOffset)
                        result.CorruptedBytes = append(result.CorruptedBytes, corruptedVersion...)
                        corruptedCount++

                        if ac.config.CorruptionSize &gt; 0 &amp;&amp; corruptedCount &gt;= ac.config.CorruptionSize </span><span class="cov0" title="0">{
                                break</span>
                        }
                }
        }

        <span class="cov0" title="0">if corruptedCount == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no local headers found to corrupt")
        }</span>

        <span class="cov0" title="0">result.Description = fmt.Sprintf("Corrupted %d local file headers", corruptedCount)
        return result, os.WriteFile(ac.originalPath, data, 0644)</span>
}

// corruptData corrupts actual file data within the archive
func (ac *ArchiveCorruptor) corruptData() (*CorruptionResult, error) <span class="cov8" title="1">{
        // Open archive to find file data locations
        reader, err := zip.OpenReader(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        data, err := os.ReadFile(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read archive: %w", err)
        }</span>

        <span class="cov8" title="1">result := &amp;CorruptionResult{
                Type:        CorruptionData,
                Description: "Corrupted file data within archive",
                Recoverable: true, // Data corruption might be detectable/recoverable
        }

        // Find file data and corrupt it
        if len(reader.File) &gt; 0 </span><span class="cov8" title="1">{
                file := reader.File[0] // Corrupt first file's data

                // Calculate approximate data location
                // This is a simplified approach - in reality, finding exact data location
                // in ZIP requires parsing headers carefully
                headerSize := 30 + len(file.Name) // Approximate local header size
                dataStart := headerSize
                dataSize := int(file.CompressedSize64)

                if dataStart+dataSize &lt; len(data) </span><span class="cov8" title="1">{
                        corruptionSize := ac.config.CorruptionSize
                        if corruptionSize == 0 </span><span class="cov0" title="0">{
                                corruptionSize = min(dataSize/10, 100) // Corrupt up to 10% or 100 bytes
                        }</span>

                        // Store original bytes
                        <span class="cov8" title="1">result.OriginalBytes = make([]byte, corruptionSize)
                        copy(result.OriginalBytes, data[dataStart:dataStart+corruptionSize])

                        // Generate corruption
                        corruptedBytes := make([]byte, corruptionSize)
                        if ac.config.Seed != 0 </span><span class="cov8" title="1">{
                                // Deterministic corruption based on seed
                                for i := range corruptedBytes </span><span class="cov8" title="1">{
                                        corruptedBytes[i] = byte((ac.config.Seed + int64(i)) % 256)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                rand.Read(corruptedBytes)
                        }</span>

                        <span class="cov8" title="1">copy(data[dataStart:dataStart+corruptionSize], corruptedBytes)
                        result.AppliedAt = append(result.AppliedAt, dataStart)
                        result.CorruptedBytes = corruptedBytes

                        result.Description = fmt.Sprintf("Corrupted %d bytes of file data", corruptionSize)</span>
                }
        }

        <span class="cov8" title="1">if len(result.AppliedAt) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no file data found to corrupt")
        }</span>

        <span class="cov8" title="1">return result, os.WriteFile(ac.originalPath, data, 0644)</span>
}

// corruptSignature corrupts ZIP file signatures more thoroughly
func (ac *ArchiveCorruptor) corruptSignature() (*CorruptionResult, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read archive: %w", err)
        }</span>

        <span class="cov8" title="1">result := &amp;CorruptionResult{
                Type:        CorruptionSignature,
                Description: "Corrupted ZIP file signatures",
                Recoverable: false, // Signature corruption usually makes files unreadable
        }

        // Corrupt the very first bytes completely (should be local file header signature)
        if len(data) &gt;= 4 </span><span class="cov8" title="1">{
                result.OriginalBytes = make([]byte, 4)
                copy(result.OriginalBytes, data[0:4])

                // Use completely invalid signature that will definitely break ZIP reading
                corruptedSig := []byte{0x00, 0x00, 0x00, 0x00}
                if ac.config.Seed != 0 </span><span class="cov8" title="1">{
                        binary.LittleEndian.PutUint32(corruptedSig, uint32(ac.config.Seed))
                }</span>

                <span class="cov8" title="1">copy(data[0:4], corruptedSig)
                result.AppliedAt = append(result.AppliedAt, 0)
                result.CorruptedBytes = corruptedSig</span>
        }

        <span class="cov8" title="1">if len(result.AppliedAt) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("archive too small to corrupt signature")
        }</span>

        <span class="cov8" title="1">return result, os.WriteFile(ac.originalPath, data, 0644)</span>
}

// corruptComment corrupts ZIP archive comments
func (ac *ArchiveCorruptor) corruptComment() (*CorruptionResult, error) <span class="cov8" title="1">{
        data, err := os.ReadFile(ac.originalPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read archive: %w", err)
        }</span>

        <span class="cov8" title="1">result := &amp;CorruptionResult{
                Type:        CorruptionComment,
                Description: "Corrupted ZIP archive comment",
                Recoverable: true, // Comment corruption is usually non-fatal
        }

        // Find End of Central Directory and add/corrupt comment
        for i := len(data) - 22; i &gt;= 0; i-- </span><span class="cov8" title="1">{ // EOCD is at least 22 bytes
                if binary.LittleEndian.Uint32(data[i:i+4]) == 0x06054b50 </span><span class="cov8" title="1">{
                        commentLenOffset := i + 20
                        if commentLenOffset+2 &lt;= len(data) </span><span class="cov8" title="1">{
                                // Set comment length to indicate corrupted comment
                                commentLen := uint16(10) // 10 bytes of corrupted comment
                                binary.LittleEndian.PutUint16(data[commentLenOffset:commentLenOffset+2], commentLen)

                                // Append corrupted comment data
                                corruptedComment := []byte("CORRUPTED!")
                                if ac.config.Seed != 0 </span><span class="cov8" title="1">{
                                        corruptedComment = []byte(fmt.Sprintf("SEED:%d", ac.config.Seed))
                                }</span>

                                // Extend the file with the comment
                                <span class="cov8" title="1">data = append(data, corruptedComment...)
                                result.AppliedAt = append(result.AppliedAt, len(data)-len(corruptedComment))
                                result.CorruptedBytes = corruptedComment
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if len(result.AppliedAt) == 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("no suitable location found for comment corruption")
        }</span>

        <span class="cov8" title="1">return result, os.WriteFile(ac.originalPath, data, 0644)</span>
}

// Helper function for min since it's not available in older Go versions
func min(a, b int) int <span class="cov0" title="0">{
        if a &lt; b </span><span class="cov0" title="0">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// CorruptionDetector provides utilities for detecting archive corruption
type CorruptionDetector struct {
        archivePath string
}

// NewCorruptionDetector creates a new corruption detector
func NewCorruptionDetector(archivePath string) *CorruptionDetector <span class="cov8" title="1">{
        return &amp;CorruptionDetector{archivePath: archivePath}
}</span>

// DetectCorruption attempts to detect various types of corruption
func (cd *CorruptionDetector) DetectCorruption() ([]CorruptionType, error) <span class="cov8" title="1">{
        var detectedTypes []CorruptionType

        // Check for basic corruption first
        if isTruncated(cd.archivePath) </span><span class="cov8" title="1">{
                detectedTypes = append(detectedTypes, CorruptionTruncate)
        }</span>

        <span class="cov8" title="1">if isSignatureCorruption(cd.archivePath) </span><span class="cov8" title="1">{
                detectedTypes = append(detectedTypes, CorruptionSignature)
        }</span>

        // Try to open as ZIP archive
        <span class="cov8" title="1">reader, err := zip.OpenReader(cd.archivePath)
        if err != nil </span><span class="cov8" title="1">{
                // If we can't open it but haven't detected signature/truncation, it's likely header corruption
                if len(detectedTypes) == 0 </span><span class="cov0" title="0">{
                        detectedTypes = append(detectedTypes, CorruptionHeader)
                }</span>
                <span class="cov8" title="1">return detectedTypes, nil</span>
        }
        <span class="cov8" title="1">defer reader.Close()

        // Archive opened successfully, check for other types of corruption
        for _, file := range reader.File </span><span class="cov8" title="1">{
                rc, err := file.Open()
                if err != nil </span><span class="cov8" title="1">{
                        // Could be various types of corruption
                        detectedTypes = append(detectedTypes, CorruptionCRC)
                        continue</span>
                }

                // Try to read the file data
                <span class="cov8" title="1">_, err = io.Copy(io.Discard, rc)
                rc.Close()

                if err != nil </span><span class="cov0" title="0">{
                        detectedTypes = append(detectedTypes, CorruptionData)
                }</span>
        }

        <span class="cov8" title="1">return detectedTypes, nil</span>
}

// isSignatureCorruption checks if the file has signature corruption
func isSignatureCorruption(path string) bool <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil || len(data) &lt; 4 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if first 4 bytes are not a valid ZIP signature
        <span class="cov8" title="1">sig := binary.LittleEndian.Uint32(data[0:4])
        validSignatures := []uint32{
                0x04034b50, // Local file header
                0x08074b50, // Data descriptor
                0x02014b50, // Central directory header
                0x06054b50, // End of central directory
        }

        for _, validSig := range validSignatures </span><span class="cov8" title="1">{
                if sig == validSig </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// isHeaderCorruption checks for header corruption beyond signature
func isHeaderCorruption(path string) bool <span class="cov0" title="0">{
        reader, err := zip.OpenReader(path)
        if err != nil </span><span class="cov0" title="0">{
                return true // If we can't open it, assume header corruption
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        // If we can open it but can't read files, might be header corruption
        if len(reader.File) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

// isTruncated checks if the file appears to be truncated
func isTruncated(path string) bool <span class="cov8" title="1">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(data) &lt; 22 </span><span class="cov0" title="0">{ // Minimum size for ZIP file with EOCD
                return true
        }</span>

        // Look for End of Central Directory signature at the end
        <span class="cov8" title="1">found := false
        for i := len(data) - 22; i &gt;= max(0, len(data)-65557); i-- </span><span class="cov8" title="1">{ // Max comment size is 65535
                if len(data[i:]) &gt;= 4 &amp;&amp; binary.LittleEndian.Uint32(data[i:i+4]) == 0x06054b50 </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">return !found</span>
}

// Helper function for max
func max(a, b int) int <span class="cov8" title="1">{
        if a &gt; b </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov0" title="0">return b</span>
}

// CreateTestArchive creates a test archive with specified files for corruption testing
func CreateTestArchive(archivePath string, files map[string]string) error <span class="cov8" title="1">{
        zipFile, err := os.Create(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer zipFile.Close()

        zipWriter := zip.NewWriter(zipFile)
        defer zipWriter.Close()

        for filePath, content := range files </span><span class="cov8" title="1">{
                fileWriter, err := zipWriter.Create(filePath)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create file %s in archive: %w", filePath, err)
                }</span>

                <span class="cov8" title="1">_, err = fileWriter.Write([]byte(content))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write content to file %s: %w", filePath, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// CreateCorruptedTestArchive creates a test archive and immediately applies corruption
func CreateCorruptedTestArchive(archivePath string, files map[string]string, config CorruptionConfig) (*CorruptionResult, error) <span class="cov8" title="1">{
        // First create the archive
        if err := CreateTestArchive(archivePath, files); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create test archive: %w", err)
        }</span>

        // Then corrupt it
        <span class="cov8" title="1">corruptor, err := NewArchiveCorruptor(archivePath, config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create corruptor: %w", err)
        }</span>
        <span class="cov8" title="1">defer corruptor.Cleanup()

        return corruptor.ApplyCorruption()</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// This file is part of bkpdir
//
// Package testutil provides testing infrastructure for complex scenarios,
// specifically disk space simulation utilities for controlled testing.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License

// TEST-INFRA-001-B: Disk space simulation framework
// DECISION-REF: DEC-004 (Error handling)
// IMPLEMENTATION-NOTES: Uses filesystem interface wrapper to simulate space constraints without requiring large files

package testutil

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "sync"
        "syscall"
)

// DiskSpaceSimulator provides controlled disk space simulation for testing
type DiskSpaceSimulator struct {
        mu                  sync.RWMutex
        availableSpace      int64
        totalSpace          int64
        usedSpace           int64
        writeOperations     int
        failurePoints       map[int]error
        spaceExhaustionRate float64 // 0.0-1.0, how much space to reduce per operation
        exhaustionMode      ExhaustionMode
        recoveryPoints      map[int]int64    // operation number -&gt; space to add back
        injectionPoints     map[string]error // file path -&gt; error to inject
        writeCounter        int
        isEnabled           bool
        originalFS          FileSystemInterface
        stats               SimulationStats
}

// ExhaustionMode determines how disk space is reduced during operations
type ExhaustionMode int

const (
        // LinearExhaustion reduces space by a fixed amount each operation
        LinearExhaustion ExhaustionMode = iota
        // ProgressiveExhaustion reduces space by increasing amounts each operation
        ProgressiveExhaustion
        // RandomExhaustion reduces space by random amounts
        RandomExhaustion
        // ImmediateExhaustion triggers disk full immediately
        ImmediateExhaustion
)

// SimulationStats tracks statistics about disk space simulation
type SimulationStats struct {
        TotalWrites         int
        FailedWrites        int
        SpaceExhausted      int
        RecoveryOperations  int
        InjectedErrors      int
        AverageSpaceReduced float64
        TotalSpaceReduced   int64
        LargestFileWritten  int64
        SmallestFileWritten int64
}

// DiskSpaceConfig configures disk space simulation parameters
type DiskSpaceConfig struct {
        InitialSpace      int64 // Initial available space in bytes
        TotalSpace        int64 // Total disk space in bytes
        ExhaustionMode    ExhaustionMode
        ExhaustionRate    float64          // 0.0-1.0, rate of space reduction
        FailurePoints     map[int]error    // operation number -&gt; error to inject
        RecoveryPoints    map[int]int64    // operation number -&gt; space to recover
        InjectionPoints   map[string]error // file path -&gt; error to inject
        MinSpaceThreshold int64            // Minimum space before triggering ENOSPC
}

// FileSystemInterface abstracts file system operations for simulation
type FileSystemInterface interface {
        WriteFile(filename string, data []byte, perm os.FileMode) error
        Create(name string) (*os.File, error)
        OpenFile(name string, flag int, perm os.FileMode) (*os.File, error)
        MkdirAll(path string, perm os.FileMode) error
        Stat(name string) (os.FileInfo, error)
        Remove(name string) error
        RemoveAll(path string) error
}

// RealFileSystem implements FileSystemInterface for actual file operations
type RealFileSystem struct{}

func (rfs *RealFileSystem) WriteFile(filename string, data []byte, perm os.FileMode) error <span class="cov8" title="1">{
        return os.WriteFile(filename, data, perm)
}</span>

func (rfs *RealFileSystem) Create(name string) (*os.File, error) <span class="cov8" title="1">{
        return os.Create(name)
}</span>

func (rfs *RealFileSystem) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) <span class="cov8" title="1">{
        return os.OpenFile(name, flag, perm)
}</span>

func (rfs *RealFileSystem) MkdirAll(path string, perm os.FileMode) error <span class="cov8" title="1">{
        return os.MkdirAll(path, perm)
}</span>

func (rfs *RealFileSystem) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        return os.Stat(name)
}</span>

func (rfs *RealFileSystem) Remove(name string) error <span class="cov8" title="1">{
        return os.Remove(name)
}</span>

func (rfs *RealFileSystem) RemoveAll(path string) error <span class="cov8" title="1">{
        return os.RemoveAll(path)
}</span>

// SimulatedFileSystem wraps a real filesystem with disk space simulation
type SimulatedFileSystem struct {
        simulator  *DiskSpaceSimulator
        underlying FileSystemInterface
}

func (sfs *SimulatedFileSystem) WriteFile(filename string, data []byte, perm os.FileMode) error <span class="cov8" title="1">{
        if err := sfs.simulator.checkSpaceAndInject(filename, int64(len(data))); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return sfs.underlying.WriteFile(filename, data, perm)</span>
}

func (sfs *SimulatedFileSystem) Create(name string) (*os.File, error) <span class="cov8" title="1">{
        if err := sfs.simulator.checkSpaceAndInject(name, 0); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return sfs.underlying.Create(name)</span>
}

func (sfs *SimulatedFileSystem) OpenFile(name string, flag int, perm os.FileMode) (*os.File, error) <span class="cov8" title="1">{
        // Only check space for write operations
        if flag&amp;(os.O_WRONLY|os.O_RDWR|os.O_CREATE) != 0 </span><span class="cov8" title="1">{
                if err := sfs.simulator.checkSpaceAndInject(name, 0); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return sfs.underlying.OpenFile(name, flag, perm)</span>
}

func (sfs *SimulatedFileSystem) MkdirAll(path string, perm os.FileMode) error <span class="cov8" title="1">{
        if err := sfs.simulator.checkSpaceAndInject(path, 1024); err != nil </span><span class="cov8" title="1">{ // Assume 1KB for directory
                return err
        }</span>
        <span class="cov8" title="1">return sfs.underlying.MkdirAll(path, perm)</span>
}

func (sfs *SimulatedFileSystem) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        return sfs.underlying.Stat(name)
}</span>

func (sfs *SimulatedFileSystem) Remove(name string) error <span class="cov8" title="1">{
        // Try to get file size before removal for space recovery
        var fileSize int64
        if info, err := sfs.underlying.Stat(name); err == nil &amp;&amp; !info.IsDir() </span><span class="cov8" title="1">{
                fileSize = info.Size()
        }</span>

        <span class="cov8" title="1">err := sfs.underlying.Remove(name)
        if err == nil &amp;&amp; fileSize &gt; 0 </span><span class="cov8" title="1">{
                // Only recover space if the file actually existed and was removed successfully
                sfs.simulator.recoverSpace(fileSize)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (sfs *SimulatedFileSystem) RemoveAll(path string) error <span class="cov8" title="1">{
        // Calculate space to recover before removal
        var totalSize int64
        if info, err := sfs.underlying.Stat(path); err == nil </span><span class="cov8" title="1">{
                if info.IsDir() </span><span class="cov8" title="1">{
                        // Walk the directory to calculate total size
                        filepath.Walk(path, func(walkPath string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                                if err == nil &amp;&amp; !info.IsDir() </span><span class="cov8" title="1">{
                                        totalSize += info.Size()
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        })
                } else<span class="cov0" title="0"> {
                        // It's a single file
                        totalSize = info.Size()
                }</span>
        }

        <span class="cov8" title="1">err := sfs.underlying.RemoveAll(path)
        if err == nil &amp;&amp; totalSize &gt; 0 </span><span class="cov8" title="1">{
                // Only recover space if removal was successful
                sfs.simulator.recoverSpace(totalSize)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// NewDiskSpaceSimulator creates a new disk space simulator with the given configuration
func NewDiskSpaceSimulator(config DiskSpaceConfig) *DiskSpaceSimulator <span class="cov8" title="1">{
        if config.TotalSpace == 0 </span><span class="cov8" title="1">{
                config.TotalSpace = 100 * 1024 * 1024 // Default 100MB total space
        }</span>

        // Only set default if both InitialSpace and TotalSpace were zero (completely unspecified)
        <span class="cov8" title="1">initialSpace := config.InitialSpace
        if config.InitialSpace == 0 &amp;&amp; config.TotalSpace == 100*1024*1024 </span><span class="cov8" title="1">{
                // This means both were unspecified, use default 50%
                initialSpace = config.TotalSpace / 2
        }</span>

        <span class="cov8" title="1">if config.MinSpaceThreshold == 0 </span><span class="cov8" title="1">{
                config.MinSpaceThreshold = 1024 // Default 1KB threshold
        }</span>

        <span class="cov8" title="1">return &amp;DiskSpaceSimulator{
                availableSpace:      initialSpace,
                totalSpace:          config.TotalSpace,
                usedSpace:           config.TotalSpace - initialSpace,
                failurePoints:       config.FailurePoints,
                spaceExhaustionRate: config.ExhaustionRate,
                exhaustionMode:      config.ExhaustionMode,
                recoveryPoints:      config.RecoveryPoints,
                injectionPoints:     config.InjectionPoints,
                isEnabled:           true,
                originalFS:          &amp;RealFileSystem{},
                stats: SimulationStats{
                        SmallestFileWritten: int64(^uint64(0) &gt;&gt; 1), // Max int64
                },
        }</span>
}

// GetFileSystem returns a FileSystemInterface that simulates disk space constraints
func (ds *DiskSpaceSimulator) GetFileSystem() FileSystemInterface <span class="cov8" title="1">{
        return &amp;SimulatedFileSystem{
                simulator:  ds,
                underlying: ds.originalFS,
        }
}</span>

// checkSpaceAndInject checks available space and injects errors based on configuration
func (ds *DiskSpaceSimulator) checkSpaceAndInject(filename string, requiredSpace int64) error <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()

        if !ds.isEnabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">ds.writeCounter++
        ds.stats.TotalWrites++

        // Check for specific error injection points
        if err, exists := ds.injectionPoints[filename]; exists </span><span class="cov8" title="1">{
                ds.stats.InjectedErrors++
                return err
        }</span>

        // Check for operation-specific failure points
        <span class="cov8" title="1">if err, exists := ds.failurePoints[ds.writeCounter]; exists </span><span class="cov8" title="1">{
                ds.stats.FailedWrites++
                return err
        }</span>

        // Check for space recovery points
        <span class="cov8" title="1">if recoverySpace, exists := ds.recoveryPoints[ds.writeCounter]; exists </span><span class="cov8" title="1">{
                ds.recoverSpaceUnlocked(recoverySpace)
                ds.stats.RecoveryOperations++
        }</span>

        // Simulate space exhaustion based on mode
        <span class="cov8" title="1">spaceToReduce := ds.calculateSpaceReduction(requiredSpace)
        ds.reduceAvailableSpace(spaceToReduce)

        // Check if we have enough space for the operation
        if ds.availableSpace &lt; requiredSpace || ds.availableSpace &lt; 0 </span><span class="cov8" title="1">{
                ds.stats.FailedWrites++
                ds.stats.SpaceExhausted++
                return &amp;os.PathError{
                        Op:   "write",
                        Path: filename,
                        Err:  syscall.ENOSPC,
                }
        }</span>

        // Track file size statistics
        <span class="cov8" title="1">if requiredSpace &gt; 0 </span><span class="cov8" title="1">{
                if requiredSpace &gt; ds.stats.LargestFileWritten </span><span class="cov8" title="1">{
                        ds.stats.LargestFileWritten = requiredSpace
                }</span>
                <span class="cov8" title="1">if requiredSpace &lt; ds.stats.SmallestFileWritten </span><span class="cov8" title="1">{
                        ds.stats.SmallestFileWritten = requiredSpace
                }</span>
        }

        // Consume the space
        <span class="cov8" title="1">ds.usedSpace += requiredSpace
        ds.availableSpace -= requiredSpace

        return nil</span>
}

// calculateSpaceReduction determines how much space to reduce based on exhaustion mode
func (ds *DiskSpaceSimulator) calculateSpaceReduction(operationSize int64) int64 <span class="cov8" title="1">{
        switch ds.exhaustionMode </span>{
        case LinearExhaustion:<span class="cov8" title="1">
                reduction := int64(float64(ds.totalSpace) * ds.spaceExhaustionRate)
                ds.stats.TotalSpaceReduced += reduction
                return reduction</span>

        case ProgressiveExhaustion:<span class="cov8" title="1">
                // Increase reduction amount with each operation
                reduction := int64(float64(ds.totalSpace) * ds.spaceExhaustionRate * float64(ds.writeCounter) / 10.0)
                ds.stats.TotalSpaceReduced += reduction
                return reduction</span>

        case RandomExhaustion:<span class="cov8" title="1">
                // Random reduction between 0 and max rate
                maxReduction := int64(float64(ds.totalSpace) * ds.spaceExhaustionRate)
                reduction := int64(float64(maxReduction) * (float64(ds.writeCounter%7) / 6.0)) // Pseudo-random
                ds.stats.TotalSpaceReduced += reduction
                return reduction</span>

        case ImmediateExhaustion:<span class="cov8" title="1">
                // Exhaust all available space immediately
                reduction := ds.availableSpace
                ds.stats.TotalSpaceReduced += reduction
                return reduction</span>

        default:<span class="cov0" title="0">
                return 0</span>
        }
}

// reduceAvailableSpace reduces available space by the specified amount
func (ds *DiskSpaceSimulator) reduceAvailableSpace(amount int64) <span class="cov8" title="1">{
        ds.availableSpace -= amount
        if ds.availableSpace &lt; 0 </span><span class="cov8" title="1">{
                ds.availableSpace = 0
        }</span>

        // Update average space reduced
        <span class="cov8" title="1">if ds.stats.TotalWrites &gt; 0 </span><span class="cov8" title="1">{
                ds.stats.AverageSpaceReduced = float64(ds.stats.TotalSpaceReduced) / float64(ds.stats.TotalWrites)
        }</span>
}

// recoverSpace adds space back to the available pool (unlocked version)
func (ds *DiskSpaceSimulator) recoverSpaceUnlocked(amount int64) <span class="cov8" title="1">{
        ds.availableSpace += amount
        ds.usedSpace -= amount

        // Ensure we don't exceed total space or go below zero
        if ds.availableSpace &gt; ds.totalSpace </span><span class="cov0" title="0">{
                ds.availableSpace = ds.totalSpace
                ds.usedSpace = 0
        }</span>
        <span class="cov8" title="1">if ds.usedSpace &lt; 0 </span><span class="cov0" title="0">{
                ds.usedSpace = 0
                ds.availableSpace = ds.totalSpace
        }</span>
}

// recoverSpace adds space back to the available pool
func (ds *DiskSpaceSimulator) recoverSpace(amount int64) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        ds.recoverSpaceUnlocked(amount)
}</span>

// GetAvailableSpace returns the current available space
func (ds *DiskSpaceSimulator) GetAvailableSpace() int64 <span class="cov8" title="1">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()
        return ds.availableSpace
}</span>

// GetUsedSpace returns the current used space
func (ds *DiskSpaceSimulator) GetUsedSpace() int64 <span class="cov8" title="1">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()
        return ds.usedSpace
}</span>

// GetTotalSpace returns the total space
func (ds *DiskSpaceSimulator) GetTotalSpace() int64 <span class="cov8" title="1">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()
        return ds.totalSpace
}</span>

// GetStats returns current simulation statistics
func (ds *DiskSpaceSimulator) GetStats() SimulationStats <span class="cov8" title="1">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()

        stats := ds.stats
        if stats.SmallestFileWritten == int64(^uint64(0)&gt;&gt;1) </span><span class="cov0" title="0">{
                stats.SmallestFileWritten = 0
        }</span>
        <span class="cov8" title="1">return stats</span>
}

// Reset resets the simulator to initial state
func (ds *DiskSpaceSimulator) Reset() <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()

        ds.availableSpace = ds.totalSpace / 2 // Reset to 50% available
        ds.usedSpace = ds.totalSpace / 2
        ds.writeCounter = 0
        ds.stats = SimulationStats{
                SmallestFileWritten: int64(^uint64(0) &gt;&gt; 1),
        }
}</span>

// SetEnabled enables or disables the simulation
func (ds *DiskSpaceSimulator) SetEnabled(enabled bool) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        ds.isEnabled = enabled
}</span>

// IsEnabled returns whether simulation is currently enabled
func (ds *DiskSpaceSimulator) IsEnabled() bool <span class="cov8" title="1">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()
        return ds.isEnabled
}</span>

// AddFailurePoint adds a failure point at the specified operation number
func (ds *DiskSpaceSimulator) AddFailurePoint(operation int, err error) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()

        if ds.failurePoints == nil </span><span class="cov8" title="1">{
                ds.failurePoints = make(map[int]error)
        }</span>
        <span class="cov8" title="1">ds.failurePoints[operation] = err</span>
}

// AddRecoveryPoint adds a space recovery point at the specified operation number
func (ds *DiskSpaceSimulator) AddRecoveryPoint(operation int, spaceToRecover int64) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()

        if ds.recoveryPoints == nil </span><span class="cov8" title="1">{
                ds.recoveryPoints = make(map[int]int64)
        }</span>
        <span class="cov8" title="1">ds.recoveryPoints[operation] = spaceToRecover</span>
}

// AddInjectionPoint adds an error injection point for a specific file path
func (ds *DiskSpaceSimulator) AddInjectionPoint(filePath string, err error) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()

        if ds.injectionPoints == nil </span><span class="cov8" title="1">{
                ds.injectionPoints = make(map[string]error)
        }</span>
        <span class="cov8" title="1">ds.injectionPoints[filePath] = err</span>
}

// RemoveFailurePoint removes a failure point
func (ds *DiskSpaceSimulator) RemoveFailurePoint(operation int) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        delete(ds.failurePoints, operation)
}</span>

// RemoveRecoveryPoint removes a recovery point
func (ds *DiskSpaceSimulator) RemoveRecoveryPoint(operation int) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        delete(ds.recoveryPoints, operation)
}</span>

// RemoveInjectionPoint removes an injection point
func (ds *DiskSpaceSimulator) RemoveInjectionPoint(filePath string) <span class="cov8" title="1">{
        ds.mu.Lock()
        defer ds.mu.Unlock()
        delete(ds.injectionPoints, filePath)
}</span>

// GetOperationCount returns the current operation count
func (ds *DiskSpaceSimulator) GetOperationCount() int <span class="cov8" title="1">{
        ds.mu.RLock()
        defer ds.mu.RUnlock()
        return ds.writeCounter
}</span>

// DiskSpaceError represents errors related to disk space simulation
type DiskSpaceError struct {
        Message   string
        Operation string
        Path      string
        Available int64
        Required  int64
        Err       error
}

func (e *DiskSpaceError) Error() string <span class="cov8" title="1">{
        if e.Err != nil </span><span class="cov0" title="0">{
                return fmt.Sprintf("disk space error during %s on %s: %s (available: %d, required: %d): %v",
                        e.Operation, e.Path, e.Message, e.Available, e.Required, e.Err)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("disk space error during %s on %s: %s (available: %d, required: %d)",
                e.Operation, e.Path, e.Message, e.Available, e.Required)</span>
}

func (e *DiskSpaceError) Unwrap() error <span class="cov8" title="1">{
        return e.Err
}</span>

// NewDiskSpaceError creates a new DiskSpaceError
func NewDiskSpaceError(operation, path, message string, available, required int64) *DiskSpaceError <span class="cov8" title="1">{
        return &amp;DiskSpaceError{
                Message:   message,
                Operation: operation,
                Path:      path,
                Available: available,
                Required:  required,
        }
}</span>

// CreateDiskFullError creates a standard "no space left on device" error
func CreateDiskFullError(path string) error <span class="cov8" title="1">{
        return &amp;os.PathError{
                Op:   "write",
                Path: path,
                Err:  syscall.ENOSPC,
        }
}</span>

// CreateQuotaExceededError creates a quota exceeded error
func CreateQuotaExceededError(path string) error <span class="cov8" title="1">{
        return &amp;os.PathError{
                Op:   "write",
                Path: path,
                Err:  errors.New("disk quota exceeded"),
        }
}</span>

// CreateDeviceFullError creates a device full error
func CreateDeviceFullError(path string) error <span class="cov8" title="1">{
        return &amp;os.PathError{
                Op:   "write",
                Path: path,
                Err:  errors.New("device full"),
        }
}</span>

// DiskSpaceScenario represents a complete test scenario with disk space constraints
type DiskSpaceScenario struct {
        Name            string
        Description     string
        InitialSpace    int64
        TotalSpace      int64
        ExhaustionMode  ExhaustionMode
        ExhaustionRate  float64
        FailurePoints   map[int]error
        RecoveryPoints  map[int]int64
        InjectionPoints map[string]error
        ExpectedResults ScenarioResults
}

// ScenarioResults defines expected results for a disk space scenario
type ScenarioResults struct {
        ShouldFailAtOperation  int
        ExpectedAvailableSpace int64
        ExpectedFailureCount   int
        ExpectedRecoveryCount  int
        ShouldTriggerCleanup   bool
}

// PredefinedScenarios provides common disk space testing scenarios
var PredefinedScenarios = map[string]DiskSpaceScenario{
        "GradualExhaustion": {
                Name:           "Gradual Space Exhaustion",
                Description:    "Gradually reduce available space over multiple operations",
                InitialSpace:   10 * 1024 * 1024, // 10MB
                TotalSpace:     20 * 1024 * 1024, // 20MB
                ExhaustionMode: LinearExhaustion,
                ExhaustionRate: 0.1, // 10% per operation
                ExpectedResults: ScenarioResults{
                        ShouldFailAtOperation: 10,
                        ExpectedFailureCount:  1,
                },
        },
        "ImmediateFailure": {
                Name:           "Immediate Disk Full",
                Description:    "Trigger disk full error immediately",
                InitialSpace:   1024,              // 1KB
                TotalSpace:     100 * 1024 * 1024, // 100MB
                ExhaustionMode: ImmediateExhaustion,
                ExpectedResults: ScenarioResults{
                        ShouldFailAtOperation: 1,
                        ExpectedFailureCount:  1,
                },
        },
        "SpaceRecovery": {
                Name:           "Space Recovery Test",
                Description:    "Test behavior when space becomes available again",
                InitialSpace:   1024,             // 1KB
                TotalSpace:     10 * 1024 * 1024, // 10MB
                ExhaustionMode: LinearExhaustion,
                ExhaustionRate: 0.5,
                RecoveryPoints: map[int]int64{
                        3: 5 * 1024 * 1024, // Recover 5MB at operation 3
                },
                ExpectedResults: ScenarioResults{
                        ShouldFailAtOperation: 1,
                        ExpectedFailureCount:  1,
                        ExpectedRecoveryCount: 1,
                },
        },
        "ProgressiveExhaustion": {
                Name:           "Progressive Space Exhaustion",
                Description:    "Progressively increase space reduction with each operation",
                InitialSpace:   50 * 1024 * 1024,  // 50MB
                TotalSpace:     100 * 1024 * 1024, // 100MB
                ExhaustionMode: ProgressiveExhaustion,
                ExhaustionRate: 0.05, // 5% base rate
                ExpectedResults: ScenarioResults{
                        ShouldFailAtOperation: 15,
                        ExpectedFailureCount:  1,
                },
        },
}

// GetScenario returns a predefined scenario by name
func GetScenario(name string) (DiskSpaceScenario, bool) <span class="cov8" title="1">{
        scenario, exists := PredefinedScenarios[name]
        return scenario, exists
}</span>

// GetAllScenarioNames returns names of all predefined scenarios
func GetAllScenarioNames() []string <span class="cov8" title="1">{
        names := make([]string, 0, len(PredefinedScenarios))
        for name := range PredefinedScenarios </span><span class="cov8" title="1">{
                names = append(names, name)
        }</span>
        <span class="cov8" title="1">sort.Strings(names)
        return names</span>
}

// RunScenario creates and configures a simulator for the given scenario
func RunScenario(scenario DiskSpaceScenario) *DiskSpaceSimulator <span class="cov8" title="1">{
        config := DiskSpaceConfig{
                InitialSpace:    scenario.InitialSpace,
                TotalSpace:      scenario.TotalSpace,
                ExhaustionMode:  scenario.ExhaustionMode,
                ExhaustionRate:  scenario.ExhaustionRate,
                FailurePoints:   scenario.FailurePoints,
                RecoveryPoints:  scenario.RecoveryPoints,
                InjectionPoints: scenario.InjectionPoints,
        }

        return NewDiskSpaceSimulator(config)
}</span>

// SimulateArchiveCreation simulates archive creation under disk space constraints
func SimulateArchiveCreation(simulator *DiskSpaceSimulator, archiveSize int64, numFiles int) error <span class="cov8" title="1">{
        fs := simulator.GetFileSystem()

        // Create archive directory
        if err := fs.MkdirAll("/tmp/test_archive", 0755); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create archive directory: %w", err)
        }</span>

        // Simulate writing archive files
        <span class="cov8" title="1">avgFileSize := archiveSize / int64(numFiles)
        for i := 0; i &lt; numFiles; i++ </span><span class="cov8" title="1">{
                filename := fmt.Sprintf("/tmp/test_archive/file_%d.txt", i)
                data := make([]byte, avgFileSize)

                if err := fs.WriteFile(filename, data, 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write file %s: %w", filename, err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// SimulateBackupOperation simulates file backup under disk space constraints
func SimulateBackupOperation(simulator *DiskSpaceSimulator, sourceSize int64, backupPath string) error <span class="cov8" title="1">{
        fs := simulator.GetFileSystem()

        // Create backup directory
        backupDir := filepath.Dir(backupPath)
        if err := fs.MkdirAll(backupDir, 0755); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to create backup directory: %w", err)
        }</span>

        // Simulate writing backup file
        <span class="cov8" title="1">data := make([]byte, sourceSize)
        if err := fs.WriteFile(backupPath, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write backup file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// This file is part of bkpdir
//
// Package testutil provides testing infrastructure for complex scenarios,
// specifically error injection utilities for comprehensive error testing.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License

// TEST-INFRA-001-E: Error injection framework
// DECISION-REF: DEC-004 (Error handling)
// IMPLEMENTATION-NOTES: Uses interface-based injection with configurable error schedules rather than global state modification

package testutil

import (
        "fmt"
        "os"
        "strings"
        "sync"
        "syscall"
        "time"
)

// ErrorType categorizes different types of errors for classification
type ErrorType int

const (
        // ErrorTypeTransient - temporary errors that may resolve on retry
        ErrorTypeTransient ErrorType = iota
        // ErrorTypePermanent - errors that won't resolve without intervention
        ErrorTypePermanent
        // ErrorTypeRecoverable - errors that can be recovered from with specific actions
        ErrorTypeRecoverable
        // ErrorTypeFatal - errors that should cause immediate operation termination
        ErrorTypeFatal
)

// ErrorCategory represents the functional area where error occurs
type ErrorCategory int

const (
        // ErrorCategoryFilesystem - file system operation errors
        ErrorCategoryFilesystem ErrorCategory = iota
        // ErrorCategoryGit - Git operation errors
        ErrorCategoryGit
        // ErrorCategoryNetwork - network operation errors
        ErrorCategoryNetwork
        // ErrorCategoryPermission - permission/access errors
        ErrorCategoryPermission
        // ErrorCategoryResource - resource exhaustion errors
        ErrorCategoryResource
        // ErrorCategoryConfiguration - configuration errors
        ErrorCategoryConfiguration
)

// InjectedError represents a categorized error with metadata
type InjectedError struct {
        Type       ErrorType
        Category   ErrorCategory
        Message    string
        Operation  string
        Path       string
        Retryable  bool
        RetryAfter time.Duration
        Cause      error
        InjectedAt time.Time
        StackTrace []string
}

func (e *InjectedError) Error() string <span class="cov8" title="1">{
        if e.Cause != nil </span><span class="cov8" title="1">{
                return fmt.Sprintf("%s (injected %s error): %v", e.Message, e.CategoryString(), e.Cause)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s (injected %s error)", e.Message, e.CategoryString())</span>
}

func (e *InjectedError) Unwrap() error <span class="cov8" title="1">{
        return e.Cause
}</span>

func (e *InjectedError) TypeString() string <span class="cov8" title="1">{
        switch e.Type </span>{
        case ErrorTypeTransient:<span class="cov8" title="1">
                return "transient"</span>
        case ErrorTypePermanent:<span class="cov0" title="0">
                return "permanent"</span>
        case ErrorTypeRecoverable:<span class="cov0" title="0">
                return "recoverable"</span>
        case ErrorTypeFatal:<span class="cov0" title="0">
                return "fatal"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

func (e *InjectedError) CategoryString() string <span class="cov8" title="1">{
        switch e.Category </span>{
        case ErrorCategoryFilesystem:<span class="cov8" title="1">
                return "filesystem"</span>
        case ErrorCategoryGit:<span class="cov8" title="1">
                return "git"</span>
        case ErrorCategoryNetwork:<span class="cov0" title="0">
                return "network"</span>
        case ErrorCategoryPermission:<span class="cov0" title="0">
                return "permission"</span>
        case ErrorCategoryResource:<span class="cov0" title="0">
                return "resource"</span>
        case ErrorCategoryConfiguration:<span class="cov0" title="0">
                return "configuration"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// ErrorInjectionPoint defines when and how to inject an error
type ErrorInjectionPoint struct {
        Operation       string                            // Operation name pattern to match
        Path            string                            // File/resource path pattern to match
        TriggerCount    int                               // Inject error on Nth occurrence (0 = always)
        MaxInjections   int                               // Maximum number of times to inject (0 = unlimited)
        Error           *InjectedError                    // Error to inject
        Probability     float64                           // Probability of injection (0.0-1.0)
        DelayBefore     time.Duration                     // Delay before injection
        DelayAfter      time.Duration                     // Delay after injection
        ConditionalFunc func(operation, path string) bool // Custom condition function
}

// ErrorPropagationTrace tracks error flow through operation chains
type ErrorPropagationTrace struct {
        ErrorID        string
        OriginalError  *InjectedError
        PropagationLog []ErrorPropagationEntry
        StartTime      time.Time
        EndTime        time.Time
}

// ErrorPropagationEntry represents one step in error propagation
type ErrorPropagationEntry struct {
        Timestamp  time.Time
        Operation  string
        Component  string
        Action     string // "caught", "wrapped", "returned", "handled"
        ErrorType  ErrorType
        Message    string
        StackDepth int
}

// ErrorRecoveryAttempt tracks recovery testing
type ErrorRecoveryAttempt struct {
        ErrorID       string
        RecoveryType  string // "retry", "fallback", "cleanup", "abort"
        AttemptNumber int
        Success       bool
        Duration      time.Duration
        Timestamp     time.Time
}

// ErrorInjectionStats tracks statistics about error injection
type ErrorInjectionStats struct {
        TotalInjections      int
        InjectionsByType     map[ErrorType]int
        InjectionsByCategory map[ErrorCategory]int
        OperationsAffected   map[string]int
        SuccessfulRecoveries int
        FailedRecoveries     int
        PropagationTraces    int
        AverageRecoveryTime  time.Duration
}

// ErrorInjector manages systematic error injection for testing
type ErrorInjector struct {
        mu                 sync.RWMutex
        isEnabled          bool
        injectionPoints    map[string]*ErrorInjectionPoint
        operationCounts    map[string]int
        injectionCounts    map[string]int
        propagationTraces  map[string]*ErrorPropagationTrace
        recoveryAttempts   []ErrorRecoveryAttempt
        stats              ErrorInjectionStats
        defaultProbability float64
        contextTimeouts    map[string]time.Duration
        retryPolicies      map[ErrorType]RetryPolicy
}

// RetryPolicy defines how to handle retry for different error types
type RetryPolicy struct {
        MaxAttempts    int
        BaseDelay      time.Duration
        MaxDelay       time.Duration
        BackoffFactor  float64
        RetryableTypes []ErrorType
}

// FilesystemInterface abstracts filesystem operations for error injection
type FilesystemInterface interface {
        WriteFile(filename string, data []byte, perm os.FileMode) error
        ReadFile(filename string) ([]byte, error)
        Create(name string) (*os.File, error)
        Open(name string) (*os.File, error)
        OpenFile(name string, flag int, perm os.FileMode) (*os.File, error)
        MkdirAll(path string, perm os.FileMode) error
        Remove(name string) error
        RemoveAll(path string) error
        Stat(name string) (os.FileInfo, error)
        Chmod(name string, mode os.FileMode) error
        Rename(oldpath, newpath string) error
}

// GitInterface abstracts Git operations for error injection
type GitInterface interface {
        IsRepository(dir string) (bool, error)
        GetBranch(dir string) (string, error)
        GetShortHash(dir string) (string, error)
        GetStatus(dir string) (string, error)
        ExecuteCommand(dir string, args ...string) ([]byte, error)
}

// NetworkInterface abstracts network operations for error injection
type NetworkInterface interface {
        HTTPGet(url string) ([]byte, error)
        HTTPPost(url string, data []byte) ([]byte, error)
        DNSLookup(hostname string) ([]string, error)
        TCPConnect(address string) error
}

// InjectableFilesystem wraps filesystem operations with error injection
type InjectableFilesystem struct {
        injector   *ErrorInjector
        underlying FilesystemInterface
}

// InjectableGit wraps Git operations with error injection
type InjectableGit struct {
        injector   *ErrorInjector
        underlying GitInterface
}

// InjectableNetwork wraps network operations with error injection
type InjectableNetwork struct {
        injector   *ErrorInjector
        underlying NetworkInterface
}

// NewErrorInjector creates a new error injection manager
func NewErrorInjector() *ErrorInjector <span class="cov8" title="1">{
        return &amp;ErrorInjector{
                isEnabled:          true,
                injectionPoints:    make(map[string]*ErrorInjectionPoint),
                operationCounts:    make(map[string]int),
                injectionCounts:    make(map[string]int),
                propagationTraces:  make(map[string]*ErrorPropagationTrace),
                recoveryAttempts:   make([]ErrorRecoveryAttempt, 0),
                defaultProbability: 1.0,
                contextTimeouts:    make(map[string]time.Duration),
                retryPolicies:      getDefaultRetryPolicies(),
                stats: ErrorInjectionStats{
                        InjectionsByType:     make(map[ErrorType]int),
                        InjectionsByCategory: make(map[ErrorCategory]int),
                        OperationsAffected:   make(map[string]int),
                },
        }
}</span>

// AddInjectionPoint adds a new error injection point
func (ei *ErrorInjector) AddInjectionPoint(id string, point *ErrorInjectionPoint) <span class="cov8" title="1">{
        ei.mu.Lock()
        defer ei.mu.Unlock()

        // Set default probability if not specified
        if point.Probability == 0 </span><span class="cov8" title="1">{
                point.Probability = ei.defaultProbability
        }</span>

        <span class="cov8" title="1">ei.injectionPoints[id] = point</span>
}

// RemoveInjectionPoint removes an error injection point
func (ei *ErrorInjector) RemoveInjectionPoint(id string) <span class="cov8" title="1">{
        ei.mu.Lock()
        defer ei.mu.Unlock()
        delete(ei.injectionPoints, id)
}</span>

// ShouldInjectError determines if an error should be injected for the given operation
func (ei *ErrorInjector) ShouldInjectError(operation, path string) (*InjectedError, bool) <span class="cov8" title="1">{
        ei.mu.Lock()
        defer ei.mu.Unlock()

        if !ei.isEnabled </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        // Increment operation count
        <span class="cov8" title="1">key := fmt.Sprintf("%s:%s", operation, path)
        ei.operationCounts[key]++

        // Check all injection points
        for id, point := range ei.injectionPoints </span><span class="cov8" title="1">{
                if ei.matchesInjectionPoint(point, operation, path) </span><span class="cov8" title="1">{
                        // Check trigger count
                        if point.TriggerCount &gt; 0 &amp;&amp; ei.operationCounts[key] != point.TriggerCount </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Check max injections
                        <span class="cov8" title="1">injectionKey := fmt.Sprintf("%s:%s", id, key)
                        if point.MaxInjections &gt; 0 &amp;&amp; ei.injectionCounts[injectionKey] &gt;= point.MaxInjections </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Check probability
                        <span class="cov8" title="1">if ei.shouldInjectBasedOnProbability(point.Probability) </span><span class="cov8" title="1">{
                                // Apply delays
                                if point.DelayBefore &gt; 0 </span><span class="cov8" title="1">{
                                        time.Sleep(point.DelayBefore)
                                }</span>

                                // Increment injection count
                                <span class="cov8" title="1">ei.injectionCounts[injectionKey]++

                                // Create error with enhanced metadata
                                injectedError := &amp;InjectedError{
                                        Type:       point.Error.Type,
                                        Category:   point.Error.Category,
                                        Message:    point.Error.Message,
                                        Operation:  operation,
                                        Path:       path,
                                        Retryable:  point.Error.Retryable,
                                        RetryAfter: point.Error.RetryAfter,
                                        Cause:      point.Error.Cause,
                                        InjectedAt: time.Now(),
                                }

                                // Update statistics
                                ei.stats.TotalInjections++
                                ei.stats.InjectionsByType[injectedError.Type]++
                                ei.stats.InjectionsByCategory[injectedError.Category]++
                                ei.stats.OperationsAffected[operation]++

                                // Start propagation trace
                                ei.startPropagationTrace(injectedError)

                                // Apply delay after injection
                                if point.DelayAfter &gt; 0 </span><span class="cov8" title="1">{
                                        time.Sleep(point.DelayAfter)
                                }</span>

                                <span class="cov8" title="1">return injectedError, true</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil, false</span>
}

// TrackErrorPropagation records error flow through operations
func (ei *ErrorInjector) TrackErrorPropagation(errorID, operation, component, action string, errorType ErrorType, message string) <span class="cov8" title="1">{
        ei.mu.Lock()
        defer ei.mu.Unlock()

        trace, exists := ei.propagationTraces[errorID]
        if !exists </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">entry := ErrorPropagationEntry{
                Timestamp:  time.Now(),
                Operation:  operation,
                Component:  component,
                Action:     action,
                ErrorType:  errorType,
                Message:    message,
                StackDepth: ei.getCurrentStackDepth(),
        }

        trace.PropagationLog = append(trace.PropagationLog, entry)</span>
}

// TrackRecoveryAttempt records error recovery testing
func (ei *ErrorInjector) TrackRecoveryAttempt(errorID, recoveryType string, attemptNumber int, success bool, duration time.Duration) <span class="cov8" title="1">{
        ei.mu.Lock()
        defer ei.mu.Unlock()

        attempt := ErrorRecoveryAttempt{
                ErrorID:       errorID,
                RecoveryType:  recoveryType,
                AttemptNumber: attemptNumber,
                Success:       success,
                Duration:      duration,
                Timestamp:     time.Now(),
        }

        ei.recoveryAttempts = append(ei.recoveryAttempts, attempt)

        if success </span><span class="cov8" title="1">{
                ei.stats.SuccessfulRecoveries++
        }</span> else<span class="cov8" title="1"> {
                ei.stats.FailedRecoveries++
        }</span>

        // Update average recovery time
        <span class="cov8" title="1">totalTime := time.Duration(0)
        successCount := 0
        for _, ra := range ei.recoveryAttempts </span><span class="cov8" title="1">{
                if ra.Success </span><span class="cov8" title="1">{
                        totalTime += ra.Duration
                        successCount++
                }</span>
        }
        <span class="cov8" title="1">if successCount &gt; 0 </span><span class="cov8" title="1">{
                ei.stats.AverageRecoveryTime = totalTime / time.Duration(successCount)
        }</span>
}

// GetStats returns error injection statistics
func (ei *ErrorInjector) GetStats() ErrorInjectionStats <span class="cov8" title="1">{
        ei.mu.RLock()
        defer ei.mu.RUnlock()
        return ei.stats
}</span>

// GetPropagationTraces returns all propagation traces
func (ei *ErrorInjector) GetPropagationTraces() map[string]*ErrorPropagationTrace <span class="cov8" title="1">{
        ei.mu.RLock()
        defer ei.mu.RUnlock()

        traces := make(map[string]*ErrorPropagationTrace)
        for k, v := range ei.propagationTraces </span><span class="cov8" title="1">{
                traces[k] = v
        }</span>
        <span class="cov8" title="1">return traces</span>
}

// GetRecoveryAttempts returns all recovery attempts
func (ei *ErrorInjector) GetRecoveryAttempts() []ErrorRecoveryAttempt <span class="cov8" title="1">{
        ei.mu.RLock()
        defer ei.mu.RUnlock()

        attempts := make([]ErrorRecoveryAttempt, len(ei.recoveryAttempts))
        copy(attempts, ei.recoveryAttempts)
        return attempts
}</span>

// Enable enables or disables error injection
func (ei *ErrorInjector) Enable(enabled bool) <span class="cov8" title="1">{
        ei.mu.Lock()
        defer ei.mu.Unlock()
        ei.isEnabled = enabled
}</span>

// IsEnabled returns whether error injection is enabled
func (ei *ErrorInjector) IsEnabled() bool <span class="cov8" title="1">{
        ei.mu.RLock()
        defer ei.mu.RUnlock()
        return ei.isEnabled
}</span>

// Reset clears all injection points and statistics
func (ei *ErrorInjector) Reset() <span class="cov8" title="1">{
        ei.mu.Lock()
        defer ei.mu.Unlock()

        ei.injectionPoints = make(map[string]*ErrorInjectionPoint)
        ei.operationCounts = make(map[string]int)
        ei.injectionCounts = make(map[string]int)
        ei.propagationTraces = make(map[string]*ErrorPropagationTrace)
        ei.recoveryAttempts = make([]ErrorRecoveryAttempt, 0)
        ei.stats = ErrorInjectionStats{
                InjectionsByType:     make(map[ErrorType]int),
                InjectionsByCategory: make(map[ErrorCategory]int),
                OperationsAffected:   make(map[string]int),
        }
}</span>

// Helper methods

func (ei *ErrorInjector) matchesInjectionPoint(point *ErrorInjectionPoint, operation, path string) bool <span class="cov8" title="1">{
        // Check operation pattern
        if point.Operation != "" &amp;&amp; point.Operation != "*" </span><span class="cov8" title="1">{
                if !strings.Contains(operation, point.Operation) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Check path pattern
        <span class="cov8" title="1">if point.Path != "" &amp;&amp; point.Path != "*" </span><span class="cov8" title="1">{
                if !strings.Contains(path, point.Path) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // Check custom condition
        <span class="cov8" title="1">if point.ConditionalFunc != nil </span><span class="cov8" title="1">{
                return point.ConditionalFunc(operation, path)
        }</span>

        <span class="cov8" title="1">return true</span>
}

func (ei *ErrorInjector) shouldInjectBasedOnProbability(probability float64) bool <span class="cov8" title="1">{
        // For testing, we'll use a simple deterministic approach
        // In real usage, this would use proper randomization
        return probability &gt;= 1.0
}</span>

func (ei *ErrorInjector) startPropagationTrace(err *InjectedError) <span class="cov8" title="1">{
        errorID := fmt.Sprintf("err_%d", time.Now().UnixNano())

        trace := &amp;ErrorPropagationTrace{
                ErrorID:        errorID,
                OriginalError:  err,
                PropagationLog: make([]ErrorPropagationEntry, 0),
                StartTime:      time.Now(),
        }

        ei.propagationTraces[errorID] = trace
        ei.stats.PropagationTraces++
}</span>

func (ei *ErrorInjector) getCurrentStackDepth() int <span class="cov8" title="1">{
        // Simplified stack depth calculation
        // In real implementation, would use runtime.Callers
        return 3
}</span>

func getDefaultRetryPolicies() map[ErrorType]RetryPolicy <span class="cov8" title="1">{
        return map[ErrorType]RetryPolicy{
                ErrorTypeTransient: {
                        MaxAttempts:    3,
                        BaseDelay:      100 * time.Millisecond,
                        MaxDelay:       5 * time.Second,
                        BackoffFactor:  2.0,
                        RetryableTypes: []ErrorType{ErrorTypeTransient},
                },
                ErrorTypeRecoverable: {
                        MaxAttempts:    2,
                        BaseDelay:      500 * time.Millisecond,
                        MaxDelay:       10 * time.Second,
                        BackoffFactor:  1.5,
                        RetryableTypes: []ErrorType{ErrorTypeRecoverable},
                },
        }
}</span>

// Pre-defined error creators for common scenarios

// CreateFilesystemError creates a filesystem-related injected error
func CreateFilesystemError(errorType ErrorType, message, operation, path string, cause error) *InjectedError <span class="cov8" title="1">{
        return &amp;InjectedError{
                Type:      errorType,
                Category:  ErrorCategoryFilesystem,
                Message:   message,
                Operation: operation,
                Path:      path,
                Cause:     cause,
                Retryable: errorType == ErrorTypeTransient || errorType == ErrorTypeRecoverable,
        }
}</span>

// CreateGitError creates a Git-related injected error
func CreateGitError(errorType ErrorType, message, operation, path string, cause error) *InjectedError <span class="cov8" title="1">{
        return &amp;InjectedError{
                Type:      errorType,
                Category:  ErrorCategoryGit,
                Message:   message,
                Operation: operation,
                Path:      path,
                Cause:     cause,
                Retryable: errorType == ErrorTypeTransient,
        }
}</span>

// CreatePermissionError creates a permission-related injected error
func CreatePermissionError(errorType ErrorType, message, operation, path string) *InjectedError <span class="cov8" title="1">{
        return &amp;InjectedError{
                Type:      errorType,
                Category:  ErrorCategoryPermission,
                Message:   message,
                Operation: operation,
                Path:      path,
                Cause:     syscall.EACCES,
                Retryable: false, // Permission errors typically aren't retryable
        }
}</span>

// CreateResourceError creates a resource exhaustion injected error
func CreateResourceError(errorType ErrorType, message, operation, path string) *InjectedError <span class="cov8" title="1">{
        return &amp;InjectedError{
                Type:      errorType,
                Category:  ErrorCategoryResource,
                Message:   message,
                Operation: operation,
                Path:      path,
                Cause:     syscall.ENOSPC,
                Retryable: errorType == ErrorTypeTransient,
        }
}</span>

// CreateNetworkError creates a network-related injected error
func CreateNetworkError(errorType ErrorType, message, operation, path string, cause error) *InjectedError <span class="cov8" title="1">{
        return &amp;InjectedError{
                Type:      errorType,
                Category:  ErrorCategoryNetwork,
                Message:   message,
                Operation: operation,
                Path:      path,
                Cause:     cause,
                Retryable: errorType == ErrorTypeTransient,
        }
}</span>

// ErrorInjectionScenario defines complete error injection test scenarios
type ErrorInjectionScenario struct {
        Name            string
        Description     string
        InjectionPoints map[string]*ErrorInjectionPoint
        ExpectedResults ScenarioExpectedResults
        SetupFunc       func(*ErrorInjector) error
        CleanupFunc     func(*ErrorInjector) error
}

// ScenarioExpectedResults defines what to expect from a scenario
type ScenarioExpectedResults struct {
        ShouldInjectErrors       bool
        ExpectedInjectionCount   int
        ExpectedRecoveryCount    int
        ExpectedPropagationDepth int
        AllowedErrorTypes        []ErrorType
        RequiredErrorCategories  []ErrorCategory
}

// Built-in scenarios for common testing patterns

func GetFilesystemErrorScenario() ErrorInjectionScenario <span class="cov8" title="1">{
        return ErrorInjectionScenario{
                Name:        "filesystem_errors",
                Description: "Comprehensive filesystem error injection testing",
                InjectionPoints: map[string]*ErrorInjectionPoint{
                        "write_permission_denied": {
                                Operation:    "WriteFile",
                                Path:         "*",
                                TriggerCount: 1,
                                Error:        CreatePermissionError(ErrorTypePermanent, "write permission denied", "WriteFile", ""),
                                Probability:  1.0,
                        },
                        "disk_full": {
                                Operation:    "WriteFile",
                                Path:         "*",
                                TriggerCount: 2,
                                Error:        CreateResourceError(ErrorTypeTransient, "disk full", "WriteFile", ""),
                                Probability:  1.0,
                        },
                },
                ExpectedResults: ScenarioExpectedResults{
                        ShouldInjectErrors:      true,
                        ExpectedInjectionCount:  2,
                        ExpectedRecoveryCount:   1, // Only transient disk full should be retryable
                        AllowedErrorTypes:       []ErrorType{ErrorTypePermanent, ErrorTypeTransient},
                        RequiredErrorCategories: []ErrorCategory{ErrorCategoryPermission, ErrorCategoryResource},
                },
        }
}</span>

func GetGitErrorScenario() ErrorInjectionScenario <span class="cov8" title="1">{
        return ErrorInjectionScenario{
                Name:        "git_errors",
                Description: "Git operation error injection testing",
                InjectionPoints: map[string]*ErrorInjectionPoint{
                        "git_command_failed": {
                                Operation:    "ExecuteCommand",
                                Path:         "*",
                                TriggerCount: 1,
                                Error:        CreateGitError(ErrorTypeTransient, "git command failed", "ExecuteCommand", "", fmt.Errorf("command execution failed")),
                                Probability:  1.0,
                        },
                        "repository_not_found": {
                                Operation:    "IsRepository",
                                Path:         "*",
                                TriggerCount: 1,
                                Error:        CreateGitError(ErrorTypePermanent, "not a git repository", "IsRepository", "", fmt.Errorf("fatal: not a git repository")),
                                Probability:  1.0,
                        },
                },
                ExpectedResults: ScenarioExpectedResults{
                        ShouldInjectErrors:      true,
                        ExpectedInjectionCount:  2,
                        ExpectedRecoveryCount:   1, // Only transient command failure should be retryable
                        AllowedErrorTypes:       []ErrorType{ErrorTypePermanent, ErrorTypeTransient},
                        RequiredErrorCategories: []ErrorCategory{ErrorCategoryGit},
                },
        }
}</span>

// RunErrorInjectionScenario executes a complete error injection scenario
func RunErrorInjectionScenario(injector *ErrorInjector, scenario ErrorInjectionScenario) error <span class="cov8" title="1">{
        // Setup scenario
        if scenario.SetupFunc != nil </span><span class="cov0" title="0">{
                if err := scenario.SetupFunc(injector); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("scenario setup failed: %w", err)
                }</span>
        }

        // Add injection points
        <span class="cov8" title="1">for id, point := range scenario.InjectionPoints </span><span class="cov8" title="1">{
                injector.AddInjectionPoint(id, point)
        }</span>

        // Cleanup on exit
        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if scenario.CleanupFunc != nil </span><span class="cov0" title="0">{
                        scenario.CleanupFunc(injector)
                }</span>
        }()

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">// This file is part of bkpdir
//
// Package testutil provides testing infrastructure for complex scenarios,
// specifically permission simulation utilities for controlled testing.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License

// TEST-INFRA-001-C: Permission testing framework
// DECISION-REF: DEC-004 (Error handling)
// IMPLEMENTATION-NOTES: Uses temporary directories with controlled permissions for safe testing

package testutil

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "runtime"
        "sync"
        "syscall"
        "time"
)

// PermissionSimulator provides controlled permission simulation for testing
type PermissionSimulator struct {
        mu                sync.RWMutex
        tempDir           string
        originalPerms     map[string]os.FileMode
        permissionChanges map[string]PermissionChange
        scenarios         map[string]PermissionScenario
        isEnabled         bool
        stats             PermissionStats
        osType            OSType
        cleanup           []func() error
}

// OSType represents the operating system type for cross-platform permission handling
type OSType int

const (
        OSUnix OSType = iota
        OSWindows
)

// PermissionChange represents a permission change to apply during testing
type PermissionChange struct {
        Path         string
        NewMode      os.FileMode
        OriginalMode os.FileMode
        ChangeTime   time.Time
        Description  string
}

// PermissionScenario defines a complete permission testing scenario
type PermissionScenario struct {
        Name             string
        Description      string
        SetupFiles       []FileSetup
        PermissionSteps  []PermissionStep
        ExpectedErrors   []string
        RestoreOnCleanup bool
}

// FileSetup defines how to create files/directories for testing
type FileSetup struct {
        Path          string
        IsDir         bool
        Content       []byte
        Mode          os.FileMode
        CreateParents bool
}

// PermissionStep defines a permission change during a scenario
type PermissionStep struct {
        Path        string
        NewMode     os.FileMode
        Description string
        DelayAfter  time.Duration
        ExpectError bool
}

// PermissionStats tracks statistics about permission simulation
type PermissionStats struct {
        TotalChanges       int
        SuccessfulChanges  int
        FailedChanges      int
        FilesCreated       int
        DirectoriesCreated int
        PermissionErrors   int
        RestorationErrors  int
        CrossPlatformTests int
        TempDirsCreated    int
}

// PermissionConfig configures permission simulation parameters
type PermissionConfig struct {
        TempDirPrefix       string
        CreateSubDirs       []string
        InitialPermissions  map[string]os.FileMode
        EnableCrossPlatform bool
        AutoCleanup         bool
        MaxTestDuration     time.Duration
}

// NewPermissionSimulator creates a new permission simulator
func NewPermissionSimulator(config PermissionConfig) (*PermissionSimulator, error) <span class="cov8" title="1">{
        // Detect OS type
        osType := OSUnix
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                osType = OSWindows
        }</span>

        // Create temporary directory
        <span class="cov8" title="1">tempDir, err := os.MkdirTemp("", config.TempDirPrefix)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp directory: %w", err)
        }</span>

        <span class="cov8" title="1">ps := &amp;PermissionSimulator{
                tempDir:           tempDir,
                originalPerms:     make(map[string]os.FileMode),
                permissionChanges: make(map[string]PermissionChange),
                scenarios:         getBuiltinScenarios(),
                isEnabled:         true,
                osType:            osType,
                cleanup:           make([]func() error, 0),
                stats: PermissionStats{
                        TempDirsCreated: 1,
                },
        }

        // Create subdirectories if specified
        for _, subdir := range config.CreateSubDirs </span><span class="cov8" title="1">{
                path := filepath.Join(tempDir, subdir)
                if err := os.MkdirAll(path, 0755); err != nil </span><span class="cov0" title="0">{
                        ps.Cleanup()
                        return nil, fmt.Errorf("failed to create subdirectory %s: %w", path, err)
                }</span>
                <span class="cov8" title="1">ps.stats.DirectoriesCreated++</span>
        }

        // Apply initial permissions
        <span class="cov8" title="1">for path, mode := range config.InitialPermissions </span><span class="cov8" title="1">{
                fullPath := filepath.Join(tempDir, path)
                if err := ps.SetPermission(fullPath, mode); err != nil </span><span class="cov0" title="0">{
                        ps.Cleanup()
                        return nil, fmt.Errorf("failed to set initial permission for %s: %w", path, err)
                }</span>
        }

        <span class="cov8" title="1">return ps, nil</span>
}

// GetTempDir returns the temporary directory path
func (ps *PermissionSimulator) GetTempDir() string <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.tempDir
}</span>

// CreateFile creates a file with specified permissions in the temp directory
func (ps *PermissionSimulator) CreateFile(relativePath string, content []byte, mode os.FileMode) (string, error) <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        fullPath := filepath.Join(ps.tempDir, relativePath)

        // Create parent directories if needed
        if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create parent directories: %w", err)
        }</span>

        // Create file
        <span class="cov8" title="1">if err := os.WriteFile(fullPath, content, mode); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create file: %w", err)
        }</span>

        // Store original permissions for restoration
        <span class="cov8" title="1">ps.originalPerms[fullPath] = mode
        ps.stats.FilesCreated++

        return fullPath, nil</span>
}

// CreateDir creates a directory with specified permissions in the temp directory
func (ps *PermissionSimulator) CreateDir(relativePath string, mode os.FileMode) (string, error) <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        fullPath := filepath.Join(ps.tempDir, relativePath)

        if err := os.MkdirAll(fullPath, mode); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create directory: %w", err)
        }</span>

        // Store original permissions for restoration
        <span class="cov8" title="1">ps.originalPerms[fullPath] = mode
        ps.stats.DirectoriesCreated++

        return fullPath, nil</span>
}

// SetPermission changes permissions on a file or directory
func (ps *PermissionSimulator) SetPermission(path string, mode os.FileMode) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        return ps.setPermissionLocked(path, mode)
}</span>

// setPermissionLocked is the internal implementation that assumes the mutex is already held
func (ps *PermissionSimulator) setPermissionLocked(path string, mode os.FileMode) error <span class="cov8" title="1">{
        // Get current permissions if not already stored
        if _, exists := ps.originalPerms[path]; !exists </span><span class="cov8" title="1">{
                if info, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                        ps.originalPerms[path] = info.Mode()
                }</span>
        }

        // Apply permission change
        <span class="cov8" title="1">if err := os.Chmod(path, mode); err != nil </span><span class="cov0" title="0">{
                ps.stats.FailedChanges++
                return fmt.Errorf("failed to change permissions: %w", err)
        }</span>

        // Record the change
        <span class="cov8" title="1">ps.permissionChanges[path] = PermissionChange{
                Path:         path,
                NewMode:      mode,
                OriginalMode: ps.originalPerms[path],
                ChangeTime:   time.Now(),
                Description:  fmt.Sprintf("Changed from %v to %v", ps.originalPerms[path], mode),
        }

        ps.stats.TotalChanges++
        ps.stats.SuccessfulChanges++

        return nil</span>
}

// RestorePermissions restores original permissions for all changed files
func (ps *PermissionSimulator) RestorePermissions() error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()
        return ps.restorePermissionsLocked()
}</span>

// restorePermissionsLocked is the internal implementation that assumes the mutex is already held
func (ps *PermissionSimulator) restorePermissionsLocked() error <span class="cov8" title="1">{
        var errs []error
        restored := 0

        for path, originalMode := range ps.originalPerms </span><span class="cov8" title="1">{
                if err := os.Chmod(path, originalMode); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to restore %s: %w", path, err))
                        ps.stats.RestorationErrors++
                }</span> else<span class="cov8" title="1"> {
                        restored++
                        delete(ps.permissionChanges, path)
                }</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("restoration errors: %v", errs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// SimulatePermissionDenied creates a scenario where permission is denied
func (ps *PermissionSimulator) SimulatePermissionDenied(path string) error <span class="cov8" title="1">{
        var deniedMode os.FileMode

        // Cross-platform permission denial
        if ps.osType == OSWindows </span><span class="cov0" title="0">{
                // On Windows, remove write permission
                deniedMode = 0444 // Read-only
        }</span> else<span class="cov8" title="1"> {
                // On Unix, remove all permissions
                deniedMode = 0000
        }</span>

        <span class="cov8" title="1">return ps.SetPermission(path, deniedMode)</span>
}

// SimulateReadOnlyAccess creates a read-only access scenario
func (ps *PermissionSimulator) SimulateReadOnlyAccess(path string) error <span class="cov0" title="0">{
        return ps.SetPermission(path, 0444)
}</span>

// SimulateWriteOnlyAccess creates a write-only access scenario (Unix only)
func (ps *PermissionSimulator) SimulateWriteOnlyAccess(path string) error <span class="cov0" title="0">{
        if ps.osType == OSWindows </span><span class="cov0" title="0">{
                // Windows doesn't support write-only, fallback to read-write
                return ps.SetPermission(path, 0666)
        }</span>
        <span class="cov0" title="0">return ps.SetPermission(path, 0222)</span>
}

// SimulateExecuteOnlyAccess creates an execute-only access scenario (Unix only)
func (ps *PermissionSimulator) SimulateExecuteOnlyAccess(path string) error <span class="cov0" title="0">{
        if ps.osType == OSWindows </span><span class="cov0" title="0">{
                // Windows doesn't support execute-only, fallback to full access
                return ps.SetPermission(path, 0777)
        }</span>
        <span class="cov0" title="0">return ps.SetPermission(path, 0111)</span>
}

// RunScenario executes a predefined permission scenario
func (ps *PermissionSimulator) RunScenario(scenarioName string) error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        scenario, exists := ps.scenarios[scenarioName]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario %s not found", scenarioName)
        }</span>

        // Setup files and directories
        <span class="cov8" title="1">for _, setup := range scenario.SetupFiles </span><span class="cov8" title="1">{
                fullPath := filepath.Join(ps.tempDir, setup.Path)

                if setup.CreateParents </span><span class="cov0" title="0">{
                        if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create parent directories for %s: %w", setup.Path, err)
                        }</span>
                }

                <span class="cov8" title="1">if setup.IsDir </span><span class="cov0" title="0">{
                        if err := os.MkdirAll(fullPath, setup.Mode); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create directory %s: %w", setup.Path, err)
                        }</span>
                        <span class="cov0" title="0">ps.stats.DirectoriesCreated++</span>
                } else<span class="cov8" title="1"> {
                        if err := os.WriteFile(fullPath, setup.Content, setup.Mode); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create file %s: %w", setup.Path, err)
                        }</span>
                        <span class="cov8" title="1">ps.stats.FilesCreated++</span>
                }

                <span class="cov8" title="1">ps.originalPerms[fullPath] = setup.Mode</span>
        }

        // Execute permission steps
        <span class="cov8" title="1">for _, step := range scenario.PermissionSteps </span><span class="cov8" title="1">{
                fullPath := filepath.Join(ps.tempDir, step.Path)
                err := ps.setPermissionLocked(fullPath, step.NewMode)

                if step.ExpectError &amp;&amp; err == nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("expected error for step %s but none occurred", step.Description)
                }</span> else<span class="cov8" title="1"> if !step.ExpectError &amp;&amp; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("unexpected error for step %s: %w", step.Description, err)
                }</span>

                <span class="cov8" title="1">if step.DelayAfter &gt; 0 </span><span class="cov0" title="0">{
                        time.Sleep(step.DelayAfter)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// DetectPermissionChange monitors a path for permission changes
func (ps *PermissionSimulator) DetectPermissionChange(path string, interval time.Duration, duration time.Duration) (*PermissionChange, error) <span class="cov8" title="1">{
        // Get initial permissions
        initialInfo, err := os.Stat(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get initial permissions: %w", err)
        }</span>
        <span class="cov8" title="1">initialMode := initialInfo.Mode()

        // Monitor for changes
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        timeout := time.After(duration)

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1">
                        currentInfo, err := os.Stat(path)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span> // File might be temporarily inaccessible
                        }

                        <span class="cov8" title="1">currentMode := currentInfo.Mode()
                        if currentMode != initialMode </span><span class="cov8" title="1">{
                                return &amp;PermissionChange{
                                        Path:         path,
                                        NewMode:      currentMode,
                                        OriginalMode: initialMode,
                                        ChangeTime:   time.Now(),
                                        Description:  fmt.Sprintf("Detected change from %v to %v", initialMode, currentMode),
                                }, nil
                        }</span>

                case &lt;-timeout:<span class="cov0" title="0">
                        return nil, fmt.Errorf("no permission change detected within %v", duration)</span>
                }
        }
}

// GetPermissionError creates platform-specific permission errors
func (ps *PermissionSimulator) GetPermissionError(operation, path string) error <span class="cov8" title="1">{
        if ps.osType == OSWindows </span><span class="cov0" title="0">{
                // Use Windows-specific error number for access denied
                return &amp;os.PathError{
                        Op:   operation,
                        Path: path,
                        Err:  syscall.Errno(5), // ERROR_ACCESS_DENIED on Windows
                }
        }</span> else<span class="cov8" title="1"> {
                return &amp;os.PathError{
                        Op:   operation,
                        Path: path,
                        Err:  syscall.EACCES,
                }
        }</span>
}

// IsPermissionError checks if an error is permission-related (cross-platform)
func (ps *PermissionSimulator) IsPermissionError(err error) bool <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">var pathErr *os.PathError
        if errors.As(err, &amp;pathErr) </span><span class="cov8" title="1">{
                if ps.osType == OSWindows </span><span class="cov0" title="0">{
                        // Check for Windows access denied error (errno 5)
                        return pathErr.Err == syscall.Errno(5)
                }</span> else<span class="cov8" title="1"> {
                        return pathErr.Err == syscall.EACCES || pathErr.Err == syscall.EPERM
                }</span>
        }

        // String-based detection as fallback
        <span class="cov8" title="1">errStr := err.Error()
        permissionPatterns := []string{
                "permission denied",
                "access is denied",
                "access denied",
                "operation not permitted",
                "not permitted",
                "EACCES",
                "EPERM",
        }

        for _, pattern := range permissionPatterns </span><span class="cov8" title="1">{
                if containsIgnoreCase(errStr, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// GeneratePermissionScenarios creates systematic permission combinations
func (ps *PermissionSimulator) GeneratePermissionScenarios() []PermissionScenario <span class="cov8" title="1">{
        scenarios := make([]PermissionScenario, 0)

        // File permission scenarios
        fileModes := []os.FileMode{0000, 0400, 0200, 0100, 0600, 0644, 0755, 0777}
        for _, mode := range fileModes </span><span class="cov8" title="1">{
                scenarios = append(scenarios, PermissionScenario{
                        Name:        fmt.Sprintf("file_mode_%04o", mode),
                        Description: fmt.Sprintf("Test file operations with mode %04o", mode),
                        SetupFiles: []FileSetup{
                                {
                                        Path:    "test_file.txt",
                                        IsDir:   false,
                                        Content: []byte("test content"),
                                        Mode:    mode,
                                },
                        },
                })
        }</span>

        // Directory permission scenarios
        <span class="cov8" title="1">dirModes := []os.FileMode{0000, 0400, 0500, 0600, 0700, 0755, 0777}
        for _, mode := range dirModes </span><span class="cov8" title="1">{
                scenarios = append(scenarios, PermissionScenario{
                        Name:        fmt.Sprintf("dir_mode_%04o", mode),
                        Description: fmt.Sprintf("Test directory operations with mode %04o", mode),
                        SetupFiles: []FileSetup{
                                {
                                        Path:  "test_dir",
                                        IsDir: true,
                                        Mode:  mode,
                                },
                        },
                })
        }</span>

        // Nested permission scenarios
        <span class="cov8" title="1">scenarios = append(scenarios, PermissionScenario{
                Name:        "nested_permission_denial",
                Description: "Test nested directory with permission denial",
                SetupFiles: []FileSetup{
                        {
                                Path:  "parent",
                                IsDir: true,
                                Mode:  0755,
                        },
                        {
                                Path:  "parent/restricted",
                                IsDir: true,
                                Mode:  0000,
                        },
                        {
                                Path:    "parent/restricted/file.txt",
                                IsDir:   false,
                                Content: []byte("restricted content"),
                                Mode:    0644,
                        },
                },
        })

        return scenarios</span>
}

// GetStats returns permission simulation statistics
func (ps *PermissionSimulator) GetStats() PermissionStats <span class="cov8" title="1">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()
        return ps.stats
}</span>

// GetPermissionChanges returns all recorded permission changes
func (ps *PermissionSimulator) GetPermissionChanges() map[string]PermissionChange <span class="cov0" title="0">{
        ps.mu.RLock()
        defer ps.mu.RUnlock()

        changes := make(map[string]PermissionChange)
        for k, v := range ps.permissionChanges </span><span class="cov0" title="0">{
                changes[k] = v
        }</span>
        <span class="cov0" title="0">return changes</span>
}

// Cleanup removes temporary files and restores permissions
func (ps *PermissionSimulator) Cleanup() error <span class="cov8" title="1">{
        ps.mu.Lock()
        defer ps.mu.Unlock()

        var errs []error

        // Restore all permissions first
        if err := ps.restorePermissionsLocked(); err != nil </span><span class="cov0" title="0">{
                errs = append(errs, err)
        }</span>

        // Remove temporary directory
        <span class="cov8" title="1">if ps.tempDir != "" </span><span class="cov8" title="1">{
                if err := os.RemoveAll(ps.tempDir); err != nil </span><span class="cov0" title="0">{
                        errs = append(errs, fmt.Errorf("failed to remove temp directory: %w", err))
                }</span>
        }

        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("cleanup errors: %v", errs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Helper functions

func containsIgnoreCase(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp;
                (s == substr ||
                        len(s) &gt; len(substr) &amp;&amp;
                                (s[:len(substr)] == substr ||
                                        s[len(s)-len(substr):] == substr ||
                                        containsSubstring(s, substr)))
}</span>

func containsSubstring(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if s[i:i+len(substr)] == substr </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// getBuiltinScenarios returns predefined permission testing scenarios
func getBuiltinScenarios() map[string]PermissionScenario <span class="cov8" title="1">{
        scenarios := map[string]PermissionScenario{
                "basic_permission_denial": {
                        Name:        "basic_permission_denial",
                        Description: "Basic permission denial scenario",
                        SetupFiles: []FileSetup{
                                {
                                        Path:    "test.txt",
                                        IsDir:   false,
                                        Content: []byte("test content"),
                                        Mode:    0644,
                                },
                        },
                        PermissionSteps: []PermissionStep{
                                {
                                        Path:        "test.txt",
                                        NewMode:     0000,
                                        Description: "Remove all permissions",
                                        ExpectError: false,
                                },
                        },
                        ExpectedErrors:   []string{"permission denied", "access denied"},
                        RestoreOnCleanup: true,
                },
                "directory_access_denied": {
                        Name:        "directory_access_denied",
                        Description: "Directory access denial scenario",
                        SetupFiles: []FileSetup{
                                {
                                        Path:  "testdir",
                                        IsDir: true,
                                        Mode:  0755,
                                },
                                {
                                        Path:    "testdir/file.txt",
                                        IsDir:   false,
                                        Content: []byte("content"),
                                        Mode:    0644,
                                },
                        },
                        PermissionSteps: []PermissionStep{
                                {
                                        Path:        "testdir",
                                        NewMode:     0000,
                                        Description: "Remove directory access",
                                        ExpectError: false,
                                },
                        },
                        ExpectedErrors:   []string{"permission denied"},
                        RestoreOnCleanup: true,
                },
                "mixed_permissions": {
                        Name:        "mixed_permissions",
                        Description: "Mixed file and directory permissions",
                        SetupFiles: []FileSetup{
                                {
                                        Path:  "readable_dir",
                                        IsDir: true,
                                        Mode:  0755,
                                },
                                {
                                        Path:  "restricted_dir",
                                        IsDir: true,
                                        Mode:  0700,
                                },
                                {
                                        Path:    "readable_dir/public.txt",
                                        IsDir:   false,
                                        Content: []byte("public content"),
                                        Mode:    0644,
                                },
                                {
                                        Path:    "restricted_dir/private.txt",
                                        IsDir:   false,
                                        Content: []byte("private content"),
                                        Mode:    0600,
                                },
                        },
                        PermissionSteps: []PermissionStep{
                                {
                                        Path:        "restricted_dir",
                                        NewMode:     0000,
                                        Description: "Restrict directory access",
                                        ExpectError: false,
                                },
                                {
                                        Path:        "readable_dir/public.txt",
                                        NewMode:     0000,
                                        Description: "Remove file access",
                                        ExpectError: false,
                                },
                        },
                        RestoreOnCleanup: true,
                },
        }

        return scenarios
}</span>

// PermissionTestHelper provides high-level testing utilities
type PermissionTestHelper struct {
        simulator *PermissionSimulator
}

// NewPermissionTestHelper creates a new permission test helper
func NewPermissionTestHelper() (*PermissionTestHelper, error) <span class="cov8" title="1">{
        config := PermissionConfig{
                TempDirPrefix:       "bkpdir_perm_test_",
                EnableCrossPlatform: true,
                AutoCleanup:         true,
                MaxTestDuration:     time.Minute * 5,
        }

        simulator, err := NewPermissionSimulator(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;PermissionTestHelper{
                simulator: simulator,
        }, nil</span>
}

// WithPermissionDenied executes a function with permission denied on the specified path
func (pth *PermissionTestHelper) WithPermissionDenied(relativePath string, fn func(path string) error) error <span class="cov8" title="1">{
        fullPath := filepath.Join(pth.simulator.GetTempDir(), relativePath)

        // Create the file/directory if it doesn't exist
        if _, err := os.Stat(fullPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                if err := os.WriteFile(fullPath, []byte("test"), 0644); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to create test file: %w", err)
                }</span>
        }

        // Apply permission denial
        <span class="cov8" title="1">if err := pth.simulator.SimulatePermissionDenied(fullPath); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to simulate permission denial: %w", err)
        }</span>

        // Execute function
        <span class="cov8" title="1">err := fn(fullPath)

        // Restore permissions
        if restoreErr := pth.simulator.RestorePermissions(); restoreErr != nil </span><span class="cov0" title="0">{
                if err == nil </span><span class="cov0" title="0">{
                        err = restoreErr
                }</span>
        }

        <span class="cov8" title="1">return err</span>
}

// Cleanup cleans up the test helper
func (pth *PermissionTestHelper) Cleanup() error <span class="cov8" title="1">{
        return pth.simulator.Cleanup()
}</span>

// GetSimulator returns the underlying simulator for advanced usage
func (pth *PermissionTestHelper) GetSimulator() *PermissionSimulator <span class="cov0" title="0">{
        return pth.simulator
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// This file is part of bkpdir
//
// Package testutil provides testing infrastructure for complex scenarios,
// specifically helper functions for easy integration with existing test patterns.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License

// TEST-INFRA-001-F: Integration testing orchestration helpers
// DECISION-REF: DEC-008 (Testing infrastructure), DEC-004 (Error handling)
// IMPLEMENTATION-NOTES: Convenience functions for common scenario patterns and integration with existing tests

package testutil

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "testing"
        "time"
)

// errorTypeToString converts ErrorType to string representation
func errorTypeToString(errorType ErrorType) string <span class="cov0" title="0">{
        switch errorType </span>{
        case ErrorTypeTransient:<span class="cov0" title="0">
                return "transient"</span>
        case ErrorTypePermanent:<span class="cov0" title="0">
                return "permanent"</span>
        case ErrorTypeRecoverable:<span class="cov0" title="0">
                return "recoverable"</span>
        case ErrorTypeFatal:<span class="cov0" title="0">
                return "fatal"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// CommonScenarioTemplates provides pre-built scenario templates for common testing patterns
type CommonScenarioTemplates struct {
        orchestrator *ScenarioOrchestrator
}

// NewCommonScenarioTemplates creates a new common scenario templates helper
func NewCommonScenarioTemplates() *CommonScenarioTemplates <span class="cov0" title="0">{
        return &amp;CommonScenarioTemplates{
                orchestrator: NewScenarioOrchestrator(),
        }
}</span>

// CreateBasicArchiveScenario creates a basic archive testing scenario
func (cst *CommonScenarioTemplates) CreateBasicArchiveScenario(scenarioID, description string) *TestScenario <span class="cov0" title="0">{
        return NewScenarioBuilder(scenarioID, "Basic Archive Test").
                WithDescription(description).
                WithTags("archive", "basic").
                AddSetupStep("setup-env", "Setup test environment", func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                        // Create test files
                        if err := runtime.CreateTestFile("test.txt", []byte("test content")); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">if err := runtime.CreateTestFile("config.yml", []byte("test: true")); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">return runtime.CreateTestDirectory("subdir")</span>
                }).
                AddExecutionStep("create-archive", "Create archive", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        // Simulate archive creation
                        runtime.SetSharedData("archive_created", true)
                        runtime.SetSharedData("archive_path", filepath.Join(runtime.ArchiveDirectory, "test-archive.tar.gz"))
                        return nil
                }</span>).
                AddVerificationStep("verify-archive", "Verify archive", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        created, exists := runtime.GetSharedData("archive_created")
                        if !exists || created != true </span><span class="cov0" title="0">{
                                return fmt.Errorf("archive was not created")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }).
                AddCleanupStep("cleanup", "Clean up", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        return nil
                }</span>).
                Build()
}

// CreateErrorInjectionScenario creates a scenario with error injection
func (cst *CommonScenarioTemplates) CreateErrorInjectionScenario(scenarioID, operation string, errorType ErrorType) *TestScenario <span class="cov0" title="0">{
        return NewScenarioBuilder(scenarioID, "Error Injection Test").
                WithDescription(fmt.Sprintf("Tests error injection for %s operation", operation)).
                WithTags("error-injection", "testing").
                AddSetupStep("setup-error-injection", "Setup error injection", func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                        runtime.ErrorInjector.Enable(true)
                        point := &amp;ErrorInjectionPoint{
                                Operation:     operation,
                                TriggerCount:  1,
                                MaxInjections: 1,
                                Error: &amp;InjectedError{
                                        Type:     errorType,
                                        Category: ErrorCategoryFilesystem,
                                        Message:  fmt.Sprintf("Simulated %s error for %s", errorTypeToString(errorType), operation),
                                },
                        }
                        runtime.ErrorInjector.AddInjectionPoint("test-error", point)
                        return nil
                }</span>).
                AddExecutionStep("trigger-operation", "Trigger operation with error", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        if injectedErr, shouldInject := runtime.ErrorInjector.ShouldInjectError(operation, "/test/path"); shouldInject </span><span class="cov0" title="0">{
                                return injectedErr
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }).
                AddVerificationStep("verify-error-stats", "Verify error injection occurred", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        stats := runtime.ErrorInjector.GetStats()
                        if stats.TotalInjections == 0 </span><span class="cov0" title="0">{
                                return fmt.Errorf("expected error injection to occur")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }).
                WithExpectation(ScenarioExpectation{
                        ShouldSucceed:    false,
                        ExpectedFailures: []string{"trigger-operation"},
                        ResourceCleanup:  true,
                }).
                Build()
}

// CreatePermissionScenario creates a scenario that tests permission handling
func (cst *CommonScenarioTemplates) CreatePermissionScenario(scenarioID, testPath string, deniedMode os.FileMode) *TestScenario <span class="cov0" title="0">{
        return NewScenarioBuilder(scenarioID, "Permission Test").
                WithDescription(fmt.Sprintf("Tests permission handling for %s", testPath)).
                WithTags("permissions", "filesystem").
                AddSetupStep("setup-permissions", "Setup permission test", func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                        // Create test file/directory
                        fullPath := filepath.Join(runtime.WorkingDirectory, testPath)
                        if err := runtime.CreateTestFile(testPath, []byte("permission test")); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Store original permissions
                        <span class="cov0" title="0">info, err := os.Stat(fullPath)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">runtime.SetSharedData("original_mode", info.Mode())

                        // Set restricted permissions
                        if err := os.Chmod(fullPath, deniedMode); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">runtime.SetSharedData("restricted_mode", deniedMode)

                        return nil</span>
                }).
                AddExecutionStep("test-operation", "Test operation with restricted permissions", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        fullPath := filepath.Join(runtime.WorkingDirectory, testPath)

                        // Try to read the file (should fail with restricted permissions)
                        _, err := os.ReadFile(fullPath)
                        runtime.SetSharedData("operation_error", err)

                        if err != nil </span><span class="cov0" title="0">{
                                return err // Expected to fail
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }).
                AddVerificationStep("verify-permission-error", "Verify permission error occurred", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        opError, exists := runtime.GetSharedData("operation_error")
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("expected operation to fail with permission error")
                        }</span>
                        <span class="cov0" title="0">if opError == nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("expected permission error, but operation succeeded")
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }).
                AddCleanupStep("restore-permissions", "Restore original permissions", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        fullPath := filepath.Join(runtime.WorkingDirectory, testPath)
                        originalMode, exists := runtime.GetSharedData("original_mode")
                        if exists </span><span class="cov0" title="0">{
                                return os.Chmod(fullPath, originalMode.(os.FileMode))
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }).
                WithExpectation(ScenarioExpectation{
                        ShouldSucceed:    false,
                        ExpectedFailures: []string{"test-operation"},
                        ResourceCleanup:  true,
                }).
                Build()
}

// CreateConcurrentScenario creates a scenario that tests concurrent operations
func (cst *CommonScenarioTemplates) CreateConcurrentScenario(scenarioID string, numSteps int) *TestScenario <span class="cov0" title="0">{
        builder := NewScenarioBuilder(scenarioID, "Concurrent Operations Test").
                WithDescription(fmt.Sprintf("Tests %d concurrent operations", numSteps)).
                WithTags("concurrent", "performance")

        // Add concurrent execution steps
        stepIDs := make([]string, numSteps)
        for i := 0; i &lt; numSteps; i++ </span><span class="cov0" title="0">{
                stepID := fmt.Sprintf("concurrent-step-%d", i+1)
                stepIDs[i] = stepID

                builder.AddExecutionStep(stepID, fmt.Sprintf("Concurrent Step %d", i+1),
                        func(stepNum int) ScenarioStepFunc </span><span class="cov0" title="0">{
                                return func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                                        // Create unique file for this step
                                        filename := fmt.Sprintf("concurrent-%d.txt", stepNum)
                                        content := fmt.Sprintf("content from step %d", stepNum)

                                        if err := runtime.CreateTestFile(filename, []byte(content)); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        // Simulate some work
                                        <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)

                                        runtime.SetSharedData(fmt.Sprintf("step_%d_complete", stepNum), true)
                                        return nil</span>
                                }
                        }(i+1))
        }

        // Enable parallel execution for all steps
        <span class="cov0" title="0">builder.EnableParallelExecution(PhaseExecution, stepIDs...)

        // Add verification step
        builder.AddVerificationStep("verify-concurrent-results", "Verify all concurrent operations completed",
                func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                        for i := 1; i &lt;= numSteps; i++ </span><span class="cov0" title="0">{
                                key := fmt.Sprintf("step_%d_complete", i)
                                completed, exists := runtime.GetSharedData(key)
                                if !exists || completed != true </span><span class="cov0" title="0">{
                                        return fmt.Errorf("step %d did not complete", i)
                                }</span>
                        }

                        // Verify all files were created
                        <span class="cov0" title="0">files := runtime.GetCreatedFiles()
                        if len(files) &lt; numSteps </span><span class="cov0" title="0">{
                                return fmt.Errorf("expected at least %d files, got %d", numSteps, len(files))
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                })

        <span class="cov0" title="0">return builder.Build()</span>
}

// TestingHelpers provides utility functions for integrating scenarios with Go testing
type TestingHelpers struct {
        orchestrator *ScenarioOrchestrator
}

// NewTestingHelpers creates a new testing helpers instance
func NewTestingHelpers() *TestingHelpers <span class="cov0" title="0">{
        return &amp;TestingHelpers{
                orchestrator: NewScenarioOrchestrator(),
        }
}</span>

// RunScenarioTest runs a scenario as a test and reports results
func (th *TestingHelpers) RunScenarioTest(t *testing.T, scenario *TestScenario) *ScenarioExecution <span class="cov0" title="0">{
        t.Helper()

        // Register scenario
        if err := th.orchestrator.RegisterScenario(scenario); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to register scenario %s: %v", scenario.ID, err)
        }</span>

        // Execute scenario
        <span class="cov0" title="0">ctx := context.Background()
        execution, err := th.orchestrator.ExecuteScenario(ctx, scenario.ID)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("Failed to execute scenario %s: %v", scenario.ID, err)
        }</span>

        // Report results
        <span class="cov0" title="0">t.Logf("Scenario %s completed in %v", scenario.ID, execution.Duration)
        t.Logf("Steps executed: %d, failed: %d, skipped: %d",
                execution.StepsExecuted, execution.StepsFailed, execution.StepsSkipped)

        // Check expectations
        expectation := scenario.ExpectedResults
        if expectation.ShouldSucceed &amp;&amp; !execution.Success </span><span class="cov0" title="0">{
                t.Errorf("Expected scenario %s to succeed, but it failed", scenario.ID)
        }</span>
        <span class="cov0" title="0">if !expectation.ShouldSucceed &amp;&amp; execution.Success </span><span class="cov0" title="0">{
                t.Errorf("Expected scenario %s to fail, but it succeeded", scenario.ID)
        }</span>

        <span class="cov0" title="0">if expectation.MinSuccessfulSteps &gt; 0 </span><span class="cov0" title="0">{
                successfulSteps := execution.StepsExecuted - execution.StepsFailed
                if successfulSteps &lt; expectation.MinSuccessfulSteps </span><span class="cov0" title="0">{
                        t.Errorf("Expected at least %d successful steps, got %d",
                                expectation.MinSuccessfulSteps, successfulSteps)
                }</span>
        }

        <span class="cov0" title="0">if expectation.MaxExecutionTime &gt; 0 &amp;&amp; execution.Duration &gt; expectation.MaxExecutionTime </span><span class="cov0" title="0">{
                t.Errorf("Expected execution time under %v, got %v",
                        expectation.MaxExecutionTime, execution.Duration)
        }</span>

        <span class="cov0" title="0">return execution</span>
}

// RunScenarioSubtest runs a scenario as a subtest
func (th *TestingHelpers) RunScenarioSubtest(t *testing.T, scenario *TestScenario) <span class="cov0" title="0">{
        t.Helper()

        t.Run(scenario.Name, func(t *testing.T) </span><span class="cov0" title="0">{
                th.RunScenarioTest(t, scenario)
        }</span>)
}

// CreateQuickScenario creates a simple scenario for quick testing
func CreateQuickScenario(id, name string, testFunc ScenarioStepFunc) *TestScenario <span class="cov0" title="0">{
        return NewScenarioBuilder(id, name).
                WithDescription("Quick test scenario").
                WithTags("quick", "simple").
                AddExecutionStep("test", "Execute test", testFunc).
                AddVerificationStep("verify", "Verify results", func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                        // Basic verification - check that no errors occurred
                        return nil
                }</span>).
                Build()
}

// CreateFileOperationScenario creates a scenario for testing file operations
func CreateFileOperationScenario(id, operation string, files map[string][]byte) *TestScenario <span class="cov0" title="0">{
        return NewScenarioBuilder(id, fmt.Sprintf("File Operation: %s", operation)).
                WithDescription(fmt.Sprintf("Tests file operation: %s", operation)).
                WithTags("file-operations", operation).
                AddSetupStep("create-files", "Create test files", func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                        for filename, content := range files </span><span class="cov0" title="0">{
                                if err := runtime.CreateTestFile(filename, content); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to create file %s: %w", filename, err)
                                }</span>
                        }
                        <span class="cov0" title="0">runtime.SetSharedData("files_created", len(files))
                        return nil</span>
                }).
                AddExecutionStep("perform-operation", fmt.Sprintf("Perform %s operation", operation),
                        func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                                // Store file list for verification
                                createdFiles := runtime.GetCreatedFiles()
                                runtime.SetSharedData("operation_files", createdFiles)
                                runtime.SetSharedData("operation_completed", true)
                                return nil
                        }</span>).
                AddVerificationStep("verify-files", "Verify file operation results", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        completed, exists := runtime.GetSharedData("operation_completed")
                        if !exists || completed != true </span><span class="cov0" title="0">{
                                return fmt.Errorf("operation was not completed")
                        }</span>

                        <span class="cov0" title="0">filesCreated, exists := runtime.GetSharedData("files_created")
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("files_created not found")
                        }</span>

                        <span class="cov0" title="0">if filesCreated != len(files) </span><span class="cov0" title="0">{
                                return fmt.Errorf("expected %d files, operation indicates %v", len(files), filesCreated)
                        }</span>

                        <span class="cov0" title="0">return nil</span>
                }).
                Build()
}

// CreateBenchmarkScenario creates a scenario optimized for benchmarking
func CreateBenchmarkScenario(id, operation string, iterations int) *TestScenario <span class="cov0" title="0">{
        return NewScenarioBuilder(id, fmt.Sprintf("Benchmark: %s", operation)).
                WithDescription(fmt.Sprintf("Benchmarks %s operation with %d iterations", operation, iterations)).
                WithTags("benchmark", "performance").
                WithTimeout(10*time.Minute). // Longer timeout for benchmarks
                AddSetupStep("benchmark-setup", "Setup benchmark environment", func(ctx context.Context, runtime *ScenarioRuntime) error </span><span class="cov0" title="0">{
                        runtime.SetSharedData("iterations", iterations)
                        runtime.SetSharedData("start_time", time.Now())
                        return nil
                }</span>).
                AddExecutionStep("benchmark-execution", fmt.Sprintf("Execute %s benchmark", operation),
                        func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                                startTime := time.Now()

                                // Perform iterations
                                for i := 0; i &lt; iterations; i++ </span><span class="cov0" title="0">{
                                        // Simulate work
                                        runtime.SetSharedData(fmt.Sprintf("iteration_%d", i), time.Now())
                                }</span>

                                <span class="cov0" title="0">endTime := time.Now()
                                duration := endTime.Sub(startTime)

                                runtime.SetSharedData("execution_duration", duration)
                                runtime.SetSharedData("iterations_completed", iterations)

                                return nil</span>
                        }).
                AddVerificationStep("benchmark-results", "Calculate benchmark results", func(ctx context.Context, runtime *ScenarioRuntime) error <span class="cov0" title="0">{
                        duration, exists := runtime.GetSharedData("execution_duration")
                        if !exists </span><span class="cov0" title="0">{
                                return fmt.Errorf("execution duration not recorded")
                        }</span>

                        <span class="cov0" title="0">completed, exists := runtime.GetSharedData("iterations_completed")
                        if !exists || completed != iterations </span><span class="cov0" title="0">{
                                return fmt.Errorf("not all iterations completed")
                        }</span>

                        <span class="cov0" title="0">avgDuration := duration.(time.Duration) / time.Duration(iterations)
                        runtime.SetSharedData("average_duration", avgDuration)

                        // Store results for external access
                        runtime.SetSharedData("benchmark_results", map[string]interface{}{
                                "total_duration":   duration,
                                "iterations":       iterations,
                                "average_duration": avgDuration,
                                "ops_per_second":   float64(iterations) / duration.(time.Duration).Seconds(),
                        })

                        return nil</span>
                }).
                Build()
}

// ValidateScenarioIntegration validates that a scenario integrates properly with existing test patterns
func ValidateScenarioIntegration(scenario *TestScenario) error <span class="cov0" title="0">{
        if scenario.ID == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario must have an ID")
        }</span>

        <span class="cov0" title="0">if scenario.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario must have a name")
        }</span>

        <span class="cov0" title="0">if len(scenario.Steps) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario must have at least one step")
        }</span>

        // Check that phases are properly used
        <span class="cov0" title="0">phases := make(map[ScenarioPhase]bool)
        for _, step := range scenario.Steps </span><span class="cov0" title="0">{
                phases[step.Phase] = true
        }</span>

        // Recommend having at least setup and execution phases
        <span class="cov0" title="0">if !phases[PhaseSetup] </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario should have at least one setup step")
        }</span>

        <span class="cov0" title="0">if !phases[PhaseExecution] </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario should have at least one execution step")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// This file is part of bkpdir
//
// Package testutil provides testing infrastructure for complex scenarios,
// specifically integration testing orchestration for combining multiple
// error conditions and operations in realistic test scenarios.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License

// TEST-INFRA-001-F: Integration testing orchestration
// DECISION-REF: DEC-008 (Testing infrastructure), DEC-004 (Error handling)
// IMPLEMENTATION-NOTES: Uses builder pattern for scenario composition with clear separation between setup, execution, and verification

package testutil

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"
)

// ScenarioPhase represents different phases of scenario execution
type ScenarioPhase int

const (
        // PhaseSetup - initial setup phase
        PhaseSetup ScenarioPhase = iota
        // PhaseExecution - main execution phase
        PhaseExecution
        // PhaseVerification - verification and validation phase
        PhaseVerification
        // PhaseCleanup - cleanup and teardown phase
        PhaseCleanup
)

// ScenarioStep represents a single step in a test scenario
type ScenarioStep struct {
        ID            string
        Name          string
        Description   string
        Phase         ScenarioPhase
        Timeout       time.Duration
        Retryable     bool
        MaxRetries    int
        Prerequisites []string // IDs of steps that must complete first
        Function      ScenarioStepFunc
        Validation    ScenarioValidationFunc
        OnSuccess     ScenarioCallbackFunc
        OnFailure     ScenarioCallbackFunc
        OnTimeout     ScenarioCallbackFunc
}

// ScenarioStepFunc defines the function signature for scenario steps
type ScenarioStepFunc func(ctx context.Context, runtime *ScenarioRuntime) error

// ScenarioValidationFunc defines the function signature for step validation
type ScenarioValidationFunc func(ctx context.Context, runtime *ScenarioRuntime) error

// ScenarioCallbackFunc defines the function signature for step callbacks
type ScenarioCallbackFunc func(ctx context.Context, runtime *ScenarioRuntime, err error)

// ScenarioRuntime provides runtime context and utilities for scenario execution
type ScenarioRuntime struct {
        mu                  sync.RWMutex
        ScenarioID          string
        StartTime           time.Time
        WorkingDirectory    string
        ArchiveDirectory    string
        TempDirectory       string
        ConfigFile          string
        ErrorInjector       *ErrorInjector
        CorruptionManager   *ArchiveCorruptor
        PermissionSimulator *PermissionSimulator
        DiskSpaceSimulator  *DiskSpaceSimulator
        ContextController   *ContextController
        ExecutionLog        []ScenarioEvent
        StepResults         map[string]*StepResult
        SharedData          map[string]interface{}
        ResourcesAllocated  []string
        filesCreated        []string
        dirsCreated         []string
}

// ScenarioEvent represents an event during scenario execution
type ScenarioEvent struct {
        Timestamp time.Time
        Type      ScenarioEventType
        StepID    string
        Phase     ScenarioPhase
        Message   string
        Error     error
        Duration  time.Duration
        Data      map[string]interface{}
}

// ScenarioEventType defines types of scenario events
type ScenarioEventType int

const (
        // EventStepStarted indicates a step has started
        EventStepStarted ScenarioEventType = iota
        // EventStepCompleted indicates a step completed successfully
        EventStepCompleted
        // EventStepFailed indicates a step failed
        EventStepFailed
        // EventStepRetried indicates a step was retried
        EventStepRetried
        // EventStepSkipped indicates a step was skipped due to prerequisites
        EventStepSkipped
        // EventScenarioStarted indicates the scenario started
        EventScenarioStarted
        // EventScenarioCompleted indicates the scenario completed
        EventScenarioCompleted
        // EventScenarioFailed indicates the scenario failed
        EventScenarioFailed
        // EventResourceAllocated indicates a resource was allocated
        EventResourceAllocated
        // EventResourceReleased indicates a resource was released
        EventResourceReleased
        // EventPhaseStarted indicates a new phase started
        EventPhaseStarted
        // EventPhaseCompleted indicates a phase completed
        EventPhaseCompleted
)

// StepResult contains the result of executing a scenario step
type StepResult struct {
        StepID       string
        StartTime    time.Time
        EndTime      time.Time
        Duration     time.Duration
        Success      bool
        Error        error
        RetryCount   int
        Phase        ScenarioPhase
        ValidationOK bool
        Data         map[string]interface{}
}

// ScenarioBuilder provides a fluent interface for building test scenarios
type ScenarioBuilder struct {
        scenario *TestScenario
}

// TestScenario represents a complete test scenario with multiple steps
type TestScenario struct {
        ID               string
        Name             string
        Description      string
        Tags             []string
        Timeout          time.Duration
        Steps            []*ScenarioStep
        SetupTimeout     time.Duration
        ExecutionTimeout time.Duration
        CleanupTimeout   time.Duration
        RequiredFeatures []string
        FailFast         bool
        ParallelSteps    map[string][]string // phase -&gt; step IDs that can run in parallel
        Dependencies     []string            // Other scenario IDs this depends on
        ExpectedResults  ScenarioExpectation
}

// ScenarioExpectation defines what to expect from scenario execution
type ScenarioExpectation struct {
        ShouldSucceed       bool
        ExpectedFailures    []string // Step IDs expected to fail
        MinSuccessfulSteps  int
        MaxExecutionTime    time.Duration
        RequiredEvents      []ScenarioEventType
        RequiredArtifacts   []string // Files/directories that should be created
        ForbiddenArtifacts  []string // Files/directories that should NOT be created
        MemoryLeakThreshold int64    // Bytes
        ResourceCleanup     bool     // Whether all resources should be cleaned up
}

// TimingCoordinator handles timing and synchronization across scenario steps
type TimingCoordinator struct {
        mu           sync.RWMutex
        barriers     map[string]*sync.WaitGroup
        signals      map[string]chan struct{}
        delays       map[string]time.Duration
        checkpoints  map[string]time.Time
        synchronized bool
}

// ScenarioOrchestrator manages the execution of complex test scenarios
type ScenarioOrchestrator struct {
        mu               sync.RWMutex
        scenarios        map[string]*TestScenario
        activeRuntimes   map[string]*ScenarioRuntime
        coordinator      *TimingCoordinator
        globalTimeout    time.Duration
        maxConcurrency   int
        retryPolicy      RetryPolicy
        cleanupPolicy    CleanupPolicy
        resourceLimits   ResourceLimits
        executionHistory []ScenarioExecution
}

// ScenarioExecution tracks the execution of a scenario
type ScenarioExecution struct {
        ScenarioID    string
        ExecutionID   string
        StartTime     time.Time
        EndTime       time.Time
        Duration      time.Duration
        Success       bool
        StepsExecuted int
        StepsFailed   int
        StepsSkipped  int
        Events        []ScenarioEvent
        FinalState    map[string]interface{}
        ResourceUsage ResourceUsage
}

// ResourceUsage tracks resource consumption during scenario execution
type ResourceUsage struct {
        MaxMemoryUsed    int64
        TotalDiskUsed    int64
        FilesCreated     int
        DirectoriesUsed  int
        NetworkRequests  int
        ProcessesSpawned int
}

// CleanupPolicy defines how cleanup should be handled
type CleanupPolicy struct {
        AlwaysCleanup      bool
        CleanupOnSuccess   bool
        CleanupOnFailure   bool
        PreserveArtifacts  []string // Patterns for files to preserve
        CleanupTimeout     time.Duration
        ForceCleanupOnExit bool
}

// ResourceLimits defines limits on resource usage
type ResourceLimits struct {
        MaxMemoryMB        int64
        MaxDiskSpaceMB     int64
        MaxFiles           int
        MaxDirectories     int
        MaxExecutionTime   time.Duration
        MaxConcurrentSteps int
}

// NewScenarioBuilder creates a new scenario builder
func NewScenarioBuilder(id, name string) *ScenarioBuilder <span class="cov8" title="1">{
        return &amp;ScenarioBuilder{
                scenario: &amp;TestScenario{
                        ID:               id,
                        Name:             name,
                        Tags:             make([]string, 0),
                        Steps:            make([]*ScenarioStep, 0),
                        ParallelSteps:    make(map[string][]string),
                        Dependencies:     make([]string, 0),
                        RequiredFeatures: make([]string, 0),
                        Timeout:          30 * time.Minute,
                        SetupTimeout:     5 * time.Minute,
                        ExecutionTimeout: 20 * time.Minute,
                        CleanupTimeout:   5 * time.Minute,
                        FailFast:         true,
                },
        }
}</span>

// WithDescription sets the scenario description
func (sb *ScenarioBuilder) WithDescription(description string) *ScenarioBuilder <span class="cov8" title="1">{
        sb.scenario.Description = description
        return sb
}</span>

// WithTags adds tags to the scenario
func (sb *ScenarioBuilder) WithTags(tags ...string) *ScenarioBuilder <span class="cov8" title="1">{
        sb.scenario.Tags = append(sb.scenario.Tags, tags...)
        return sb
}</span>

// WithTimeout sets the overall scenario timeout
func (sb *ScenarioBuilder) WithTimeout(timeout time.Duration) *ScenarioBuilder <span class="cov8" title="1">{
        sb.scenario.Timeout = timeout
        return sb
}</span>

// WithFailFast sets whether the scenario should fail fast on first error
func (sb *ScenarioBuilder) WithFailFast(failFast bool) *ScenarioBuilder <span class="cov8" title="1">{
        sb.scenario.FailFast = failFast
        return sb
}</span>

// WithDependencies adds scenario dependencies
func (sb *ScenarioBuilder) WithDependencies(scenarioIDs ...string) *ScenarioBuilder <span class="cov0" title="0">{
        sb.scenario.Dependencies = append(sb.scenario.Dependencies, scenarioIDs...)
        return sb
}</span>

// WithRequiredFeatures adds required features
func (sb *ScenarioBuilder) WithRequiredFeatures(features ...string) *ScenarioBuilder <span class="cov0" title="0">{
        sb.scenario.RequiredFeatures = append(sb.scenario.RequiredFeatures, features...)
        return sb
}</span>

// AddSetupStep adds a setup phase step
func (sb *ScenarioBuilder) AddSetupStep(id, name string, fn ScenarioStepFunc) *ScenarioBuilder <span class="cov8" title="1">{
        step := &amp;ScenarioStep{
                ID:            id,
                Name:          name,
                Phase:         PhaseSetup,
                Function:      fn,
                Timeout:       5 * time.Minute,
                Retryable:     false,
                MaxRetries:    0,
                Prerequisites: make([]string, 0),
        }
        sb.scenario.Steps = append(sb.scenario.Steps, step)
        return sb
}</span>

// AddExecutionStep adds an execution phase step
func (sb *ScenarioBuilder) AddExecutionStep(id, name string, fn ScenarioStepFunc) *ScenarioBuilder <span class="cov8" title="1">{
        step := &amp;ScenarioStep{
                ID:            id,
                Name:          name,
                Phase:         PhaseExecution,
                Function:      fn,
                Timeout:       10 * time.Minute,
                Retryable:     true,
                MaxRetries:    3,
                Prerequisites: make([]string, 0),
        }
        sb.scenario.Steps = append(sb.scenario.Steps, step)
        return sb
}</span>

// AddVerificationStep adds a verification phase step
func (sb *ScenarioBuilder) AddVerificationStep(id, name string, fn ScenarioStepFunc) *ScenarioBuilder <span class="cov8" title="1">{
        step := &amp;ScenarioStep{
                ID:            id,
                Name:          name,
                Phase:         PhaseVerification,
                Function:      fn,
                Timeout:       5 * time.Minute,
                Retryable:     false,
                MaxRetries:    0,
                Prerequisites: make([]string, 0),
        }
        sb.scenario.Steps = append(sb.scenario.Steps, step)
        return sb
}</span>

// AddCleanupStep adds a cleanup phase step
func (sb *ScenarioBuilder) AddCleanupStep(id, name string, fn ScenarioStepFunc) *ScenarioBuilder <span class="cov8" title="1">{
        step := &amp;ScenarioStep{
                ID:            id,
                Name:          name,
                Phase:         PhaseCleanup,
                Function:      fn,
                Timeout:       2 * time.Minute,
                Retryable:     true,
                MaxRetries:    2,
                Prerequisites: make([]string, 0),
        }
        sb.scenario.Steps = append(sb.scenario.Steps, step)
        return sb
}</span>

// WithStepTimeout sets timeout for the last added step
func (sb *ScenarioBuilder) WithStepTimeout(timeout time.Duration) *ScenarioBuilder <span class="cov8" title="1">{
        if len(sb.scenario.Steps) &gt; 0 </span><span class="cov8" title="1">{
                sb.scenario.Steps[len(sb.scenario.Steps)-1].Timeout = timeout
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// WithStepPrerequisites sets prerequisites for the last added step
func (sb *ScenarioBuilder) WithStepPrerequisites(stepIDs ...string) *ScenarioBuilder <span class="cov8" title="1">{
        if len(sb.scenario.Steps) &gt; 0 </span><span class="cov8" title="1">{
                sb.scenario.Steps[len(sb.scenario.Steps)-1].Prerequisites = stepIDs
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// WithStepValidation sets validation function for the last added step
func (sb *ScenarioBuilder) WithStepValidation(validation ScenarioValidationFunc) *ScenarioBuilder <span class="cov8" title="1">{
        if len(sb.scenario.Steps) &gt; 0 </span><span class="cov8" title="1">{
                sb.scenario.Steps[len(sb.scenario.Steps)-1].Validation = validation
        }</span>
        <span class="cov8" title="1">return sb</span>
}

// WithStepCallbacks sets callback functions for the last added step
func (sb *ScenarioBuilder) WithStepCallbacks(onSuccess, onFailure, onTimeout ScenarioCallbackFunc) *ScenarioBuilder <span class="cov0" title="0">{
        if len(sb.scenario.Steps) &gt; 0 </span><span class="cov0" title="0">{
                step := sb.scenario.Steps[len(sb.scenario.Steps)-1]
                step.OnSuccess = onSuccess
                step.OnFailure = onFailure
                step.OnTimeout = onTimeout
        }</span>
        <span class="cov0" title="0">return sb</span>
}

// EnableParallelExecution enables parallel execution for steps in the specified phase
func (sb *ScenarioBuilder) EnableParallelExecution(phase ScenarioPhase, stepIDs ...string) *ScenarioBuilder <span class="cov8" title="1">{
        phaseKey := fmt.Sprintf("phase_%d", int(phase))
        if sb.scenario.ParallelSteps[phaseKey] == nil </span><span class="cov8" title="1">{
                sb.scenario.ParallelSteps[phaseKey] = make([]string, 0)
        }</span>
        <span class="cov8" title="1">sb.scenario.ParallelSteps[phaseKey] = append(sb.scenario.ParallelSteps[phaseKey], stepIDs...)
        return sb</span>
}

// WithExpectation sets the expected results for the scenario
func (sb *ScenarioBuilder) WithExpectation(expectation ScenarioExpectation) *ScenarioBuilder <span class="cov8" title="1">{
        sb.scenario.ExpectedResults = expectation
        return sb
}</span>

// Build finalizes and returns the test scenario
func (sb *ScenarioBuilder) Build() *TestScenario <span class="cov8" title="1">{
        // Validate the scenario before returning
        if err := sb.validateScenario(); err != nil </span><span class="cov8" title="1">{
                panic(fmt.Sprintf("Invalid scenario configuration: %v", err))</span>
        }
        <span class="cov8" title="1">return sb.scenario</span>
}

// validateScenario validates the scenario configuration
func (sb *ScenarioBuilder) validateScenario() error <span class="cov8" title="1">{
        if sb.scenario.ID == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("scenario ID cannot be empty")
        }</span>
        <span class="cov8" title="1">if sb.scenario.Name == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario name cannot be empty")
        }</span>
        <span class="cov8" title="1">if len(sb.scenario.Steps) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario must have at least one step")
        }</span>

        // Validate step prerequisites
        <span class="cov8" title="1">stepIDs := make(map[string]bool)
        for _, step := range sb.scenario.Steps </span><span class="cov8" title="1">{
                stepIDs[step.ID] = true
        }</span>

        <span class="cov8" title="1">for _, step := range sb.scenario.Steps </span><span class="cov8" title="1">{
                for _, prereq := range step.Prerequisites </span><span class="cov8" title="1">{
                        if !stepIDs[prereq] </span><span class="cov8" title="1">{
                                return fmt.Errorf("step %s has invalid prerequisite %s", step.ID, prereq)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// NewScenarioOrchestrator creates a new scenario orchestrator
func NewScenarioOrchestrator() *ScenarioOrchestrator <span class="cov8" title="1">{
        return &amp;ScenarioOrchestrator{
                scenarios:      make(map[string]*TestScenario),
                activeRuntimes: make(map[string]*ScenarioRuntime),
                coordinator:    NewTimingCoordinator(),
                globalTimeout:  60 * time.Minute,
                maxConcurrency: 10,
                retryPolicy: RetryPolicy{
                        MaxAttempts:   3,
                        BaseDelay:     1 * time.Second,
                        MaxDelay:      30 * time.Second,
                        BackoffFactor: 2.0,
                },
                cleanupPolicy: CleanupPolicy{
                        AlwaysCleanup:      true,
                        CleanupOnSuccess:   true,
                        CleanupOnFailure:   false,
                        CleanupTimeout:     5 * time.Minute,
                        ForceCleanupOnExit: true,
                },
                resourceLimits: ResourceLimits{
                        MaxMemoryMB:        1024,
                        MaxDiskSpaceMB:     5120,
                        MaxFiles:           10000,
                        MaxDirectories:     1000,
                        MaxExecutionTime:   120 * time.Minute,
                        MaxConcurrentSteps: 5,
                },
                executionHistory: make([]ScenarioExecution, 0),
        }
}</span>

// RegisterScenario registers a scenario with the orchestrator
func (so *ScenarioOrchestrator) RegisterScenario(scenario *TestScenario) error <span class="cov8" title="1">{
        so.mu.Lock()
        defer so.mu.Unlock()

        if _, exists := so.scenarios[scenario.ID]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("scenario with ID %s already registered", scenario.ID)
        }</span>

        <span class="cov8" title="1">so.scenarios[scenario.ID] = scenario
        return nil</span>
}

// ExecuteScenario executes a registered scenario
func (so *ScenarioOrchestrator) ExecuteScenario(ctx context.Context, scenarioID string) (*ScenarioExecution, error) <span class="cov8" title="1">{
        so.mu.RLock()
        scenario, exists := so.scenarios[scenarioID]
        so.mu.RUnlock()

        if !exists </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("scenario %s not found", scenarioID)
        }</span>

        // Create runtime environment
        <span class="cov8" title="1">runtime, err := so.createScenarioRuntime(scenarioID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create runtime: %w", err)
        }</span>

        // Store active runtime
        <span class="cov8" title="1">so.mu.Lock()
        so.activeRuntimes[scenarioID] = runtime
        so.mu.Unlock()

        // Ensure cleanup
        defer func() </span><span class="cov8" title="1">{
                so.mu.Lock()
                delete(so.activeRuntimes, scenarioID)
                so.mu.Unlock()
                so.cleanupRuntime(runtime)
        }</span>()

        <span class="cov8" title="1">execution := &amp;ScenarioExecution{
                ScenarioID:  scenarioID,
                ExecutionID: fmt.Sprintf("%s_%d", scenarioID, time.Now().Unix()),
                StartTime:   time.Now(),
                Events:      make([]ScenarioEvent, 0),
                FinalState:  make(map[string]interface{}),
        }

        // Set up context with timeout
        execCtx, cancel := context.WithTimeout(ctx, scenario.Timeout)
        defer cancel()

        // Record scenario start
        runtime.recordEvent(EventScenarioStarted, "", PhaseSetup, "Scenario execution started", nil, 0, nil)

        // Execute scenario phases
        success := true
        phases := []ScenarioPhase{PhaseSetup, PhaseExecution, PhaseVerification, PhaseCleanup}

        for _, phase := range phases </span><span class="cov8" title="1">{
                phaseSuccess := so.executePhase(execCtx, scenario, runtime, phase)
                if !phaseSuccess &amp;&amp; scenario.FailFast &amp;&amp; phase != PhaseCleanup </span><span class="cov8" title="1">{
                        success = false
                        break</span>
                }
                <span class="cov8" title="1">if !phaseSuccess </span><span class="cov0" title="0">{
                        success = false
                }</span>
        }

        // Finalize execution
        <span class="cov8" title="1">execution.EndTime = time.Now()
        execution.Duration = execution.EndTime.Sub(execution.StartTime)
        execution.Success = success
        execution.Events = runtime.ExecutionLog
        execution.FinalState = runtime.SharedData

        // Calculate statistics
        execution.StepsExecuted = len(runtime.StepResults)
        for _, result := range runtime.StepResults </span><span class="cov8" title="1">{
                if !result.Success </span><span class="cov8" title="1">{
                        execution.StepsFailed++
                }</span>
        }

        // Record execution in history
        <span class="cov8" title="1">so.mu.Lock()
        so.executionHistory = append(so.executionHistory, *execution)
        so.mu.Unlock()

        // Record scenario completion
        eventType := EventScenarioCompleted
        if !success </span><span class="cov8" title="1">{
                eventType = EventScenarioFailed
        }</span>
        <span class="cov8" title="1">runtime.recordEvent(eventType, "", PhaseCleanup, "Scenario execution completed", nil, execution.Duration, nil)

        return execution, nil</span>
}

// createScenarioRuntime creates a runtime environment for scenario execution
func (so *ScenarioOrchestrator) createScenarioRuntime(scenarioID string) (*ScenarioRuntime, error) <span class="cov8" title="1">{
        // Create temporary directory
        tempDir, err := os.MkdirTemp("", fmt.Sprintf("bkpdir_scenario_%s_", scenarioID))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temp directory: %w", err)
        }</span>

        <span class="cov8" title="1">workingDir := filepath.Join(tempDir, "working")
        archiveDir := filepath.Join(tempDir, "archives")

        // Create directories
        for _, dir := range []string{workingDir, archiveDir} </span><span class="cov8" title="1">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        os.RemoveAll(tempDir)
                        return nil, fmt.Errorf("failed to create directory %s: %w", dir, err)
                }</span>
        }

        // Create config file
        <span class="cov8" title="1">configFile := filepath.Join(workingDir, ".bkpdir.yml")
        configContent := fmt.Sprintf("archive_dir_path: %s\nuse_current_dir_name: true\n", archiveDir)
        if err := os.WriteFile(configFile, []byte(configContent), 0644); err != nil </span><span class="cov0" title="0">{
                os.RemoveAll(tempDir)
                return nil, fmt.Errorf("failed to create config file: %w", err)
        }</span>

        <span class="cov8" title="1">runtime := &amp;ScenarioRuntime{
                ScenarioID:         scenarioID,
                StartTime:          time.Now(),
                WorkingDirectory:   workingDir,
                ArchiveDirectory:   archiveDir,
                TempDirectory:      tempDir,
                ConfigFile:         configFile,
                ErrorInjector:      NewErrorInjector(),
                ContextController:  NewContextController(30 * time.Minute),
                ExecutionLog:       make([]ScenarioEvent, 0),
                StepResults:        make(map[string]*StepResult),
                SharedData:         make(map[string]interface{}),
                ResourcesAllocated: make([]string, 0),
                filesCreated:       make([]string, 0),
                dirsCreated:        make([]string, 0),
        }

        return runtime, nil</span>
}

// executePhase executes all steps in a specific phase
func (so *ScenarioOrchestrator) executePhase(ctx context.Context, scenario *TestScenario, runtime *ScenarioRuntime, phase ScenarioPhase) bool <span class="cov8" title="1">{
        runtime.recordEvent(EventPhaseStarted, "", phase, fmt.Sprintf("Starting phase %d", int(phase)), nil, 0, nil)

        // Get steps for this phase
        phaseSteps := make([]*ScenarioStep, 0)
        for _, step := range scenario.Steps </span><span class="cov8" title="1">{
                if step.Phase == phase </span><span class="cov8" title="1">{
                        phaseSteps = append(phaseSteps, step)
                }</span>
        }

        <span class="cov8" title="1">if len(phaseSteps) == 0 </span><span class="cov8" title="1">{
                runtime.recordEvent(EventPhaseCompleted, "", phase, fmt.Sprintf("Phase %d completed (no steps)", int(phase)), nil, 0, nil)
                return true
        }</span>

        // Check for parallel execution
        <span class="cov8" title="1">phaseKey := fmt.Sprintf("phase_%d", int(phase))
        parallelStepIDs := scenario.ParallelSteps[phaseKey]

        success := true
        if len(parallelStepIDs) &gt; 0 </span><span class="cov8" title="1">{
                // Execute parallel steps
                success = so.executeStepsInParallel(ctx, phaseSteps, parallelStepIDs, runtime)
        }</span> else<span class="cov8" title="1"> {
                // Execute steps sequentially
                success = so.executeStepsSequentially(ctx, phaseSteps, runtime, scenario.FailFast)
        }</span>

        <span class="cov8" title="1">eventType := EventPhaseCompleted
        message := fmt.Sprintf("Phase %d completed successfully", int(phase))
        if !success </span><span class="cov8" title="1">{
                message = fmt.Sprintf("Phase %d failed", int(phase))
        }</span>

        <span class="cov8" title="1">runtime.recordEvent(eventType, "", phase, message, nil, 0, nil)
        return success</span>
}

// executeStepsSequentially executes steps one after another
func (so *ScenarioOrchestrator) executeStepsSequentially(ctx context.Context, steps []*ScenarioStep, runtime *ScenarioRuntime, failFast bool) bool <span class="cov8" title="1">{
        allSuccess := true

        for _, step := range steps </span><span class="cov8" title="1">{
                if !so.arePrerequisitesMet(step, runtime) </span><span class="cov0" title="0">{
                        runtime.recordEvent(EventStepSkipped, step.ID, step.Phase, fmt.Sprintf("Prerequisites not met for step %s", step.ID), nil, 0, nil)
                        continue</span>
                }

                <span class="cov8" title="1">success := so.executeStep(ctx, step, runtime)
                if !success </span><span class="cov8" title="1">{
                        allSuccess = false
                        if failFast </span><span class="cov8" title="1">{
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">return allSuccess</span>
}

// executeStepsInParallel executes specified steps in parallel
func (so *ScenarioOrchestrator) executeStepsInParallel(ctx context.Context, steps []*ScenarioStep, parallelStepIDs []string, runtime *ScenarioRuntime) bool <span class="cov8" title="1">{
        // Separate parallel and sequential steps
        parallelSteps := make([]*ScenarioStep, 0)
        sequentialSteps := make([]*ScenarioStep, 0)

        parallelSet := make(map[string]bool)
        for _, id := range parallelStepIDs </span><span class="cov8" title="1">{
                parallelSet[id] = true
        }</span>

        <span class="cov8" title="1">for _, step := range steps </span><span class="cov8" title="1">{
                if parallelSet[step.ID] </span><span class="cov8" title="1">{
                        parallelSteps = append(parallelSteps, step)
                }</span> else<span class="cov0" title="0"> {
                        sequentialSteps = append(sequentialSteps, step)
                }</span>
        }

        <span class="cov8" title="1">allSuccess := true

        // Execute sequential steps first
        if len(sequentialSteps) &gt; 0 </span><span class="cov0" title="0">{
                if !so.executeStepsSequentially(ctx, sequentialSteps, runtime, false) </span><span class="cov0" title="0">{
                        allSuccess = false
                }</span>
        }

        // Execute parallel steps
        <span class="cov8" title="1">if len(parallelSteps) &gt; 0 </span><span class="cov8" title="1">{
                var wg sync.WaitGroup
                resultChan := make(chan bool, len(parallelSteps))

                for _, step := range parallelSteps </span><span class="cov8" title="1">{
                        if !so.arePrerequisitesMet(step, runtime) </span><span class="cov0" title="0">{
                                runtime.recordEvent(EventStepSkipped, step.ID, step.Phase, fmt.Sprintf("Prerequisites not met for step %s", step.ID), nil, 0, nil)
                                resultChan &lt;- true
                                continue</span>
                        }

                        <span class="cov8" title="1">wg.Add(1)
                        go func(s *ScenarioStep) </span><span class="cov8" title="1">{
                                defer wg.Done()
                                success := so.executeStep(ctx, s, runtime)
                                resultChan &lt;- success
                        }</span>(step)
                }

                <span class="cov8" title="1">wg.Wait()
                close(resultChan)

                // Collect results
                for success := range resultChan </span><span class="cov8" title="1">{
                        if !success </span><span class="cov0" title="0">{
                                allSuccess = false
                        }</span>
                }
        }

        <span class="cov8" title="1">return allSuccess</span>
}

// executeStep executes a single scenario step
func (so *ScenarioOrchestrator) executeStep(ctx context.Context, step *ScenarioStep, runtime *ScenarioRuntime) bool <span class="cov8" title="1">{
        startTime := time.Now()

        runtime.recordEvent(EventStepStarted, step.ID, step.Phase, fmt.Sprintf("Starting step %s", step.Name), nil, 0, nil)

        result := &amp;StepResult{
                StepID:    step.ID,
                StartTime: startTime,
                Phase:     step.Phase,
                Success:   false,
                Data:      make(map[string]interface{}),
        }

        // Set up step context with timeout
        stepCtx, cancel := context.WithTimeout(ctx, step.Timeout)
        defer cancel()

        var stepErr error

        // Execute with retries if enabled
        for attempt := 0; attempt &lt;= step.MaxRetries; attempt++ </span><span class="cov8" title="1">{
                if attempt &gt; 0 </span><span class="cov8" title="1">{
                        runtime.recordEvent(EventStepRetried, step.ID, step.Phase, fmt.Sprintf("Retrying step %s (attempt %d)", step.Name, attempt+1), stepErr, 0, nil)
                }</span>

                <span class="cov8" title="1">stepErr = step.Function(stepCtx, runtime)
                if stepErr == nil </span><span class="cov8" title="1">{
                        result.Success = true
                        break</span>
                }

                <span class="cov8" title="1">result.RetryCount = attempt + 1

                if !step.Retryable || attempt &gt;= step.MaxRetries </span><span class="cov8" title="1">{
                        break</span>
                }

                // Wait before retry
                <span class="cov8" title="1">select </span>{
                case &lt;-time.After(time.Duration(attempt+1) * time.Second):<span class="cov8" title="1"></span>
                case &lt;-stepCtx.Done():<span class="cov8" title="1">
                        stepErr = stepCtx.Err()
                        break</span>
                }
        }

        // Run validation if provided and step succeeded
        <span class="cov8" title="1">if result.Success &amp;&amp; step.Validation != nil </span><span class="cov8" title="1">{
                if validationErr := step.Validation(stepCtx, runtime); validationErr != nil </span><span class="cov8" title="1">{
                        result.Success = false
                        result.ValidationOK = false
                        stepErr = fmt.Errorf("validation failed: %w", validationErr)
                }</span> else<span class="cov0" title="0"> {
                        result.ValidationOK = true
                }</span>
        }

        // Finalize result
        <span class="cov8" title="1">result.EndTime = time.Now()
        result.Duration = result.EndTime.Sub(result.StartTime)
        result.Error = stepErr

        // Store result
        runtime.mu.Lock()
        runtime.StepResults[step.ID] = result
        runtime.mu.Unlock()

        // Execute callbacks
        if result.Success &amp;&amp; step.OnSuccess != nil </span><span class="cov0" title="0">{
                step.OnSuccess(stepCtx, runtime, nil)
        }</span> else<span class="cov8" title="1"> if !result.Success &amp;&amp; step.OnFailure != nil </span><span class="cov0" title="0">{
                step.OnFailure(stepCtx, runtime, stepErr)
        }</span>

        <span class="cov8" title="1">if stepCtx.Err() == context.DeadlineExceeded &amp;&amp; step.OnTimeout != nil </span><span class="cov0" title="0">{
                step.OnTimeout(stepCtx, runtime, stepCtx.Err())
        }</span>

        // Record completion
        <span class="cov8" title="1">eventType := EventStepCompleted
        message := fmt.Sprintf("Step %s completed successfully", step.Name)
        if !result.Success </span><span class="cov8" title="1">{
                eventType = EventStepFailed
                message = fmt.Sprintf("Step %s failed", step.Name)
        }</span>

        <span class="cov8" title="1">runtime.recordEvent(eventType, step.ID, step.Phase, message, stepErr, result.Duration, nil)

        return result.Success</span>
}

// arePrerequisitesMet checks if all prerequisites for a step are met
func (so *ScenarioOrchestrator) arePrerequisitesMet(step *ScenarioStep, runtime *ScenarioRuntime) bool <span class="cov8" title="1">{
        runtime.mu.RLock()
        defer runtime.mu.RUnlock()

        for _, prereqID := range step.Prerequisites </span><span class="cov8" title="1">{
                result, exists := runtime.StepResults[prereqID]
                if !exists || !result.Success </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// cleanupRuntime cleans up scenario runtime resources
func (so *ScenarioOrchestrator) cleanupRuntime(runtime *ScenarioRuntime) <span class="cov8" title="1">{
        if runtime.TempDirectory != "" </span><span class="cov8" title="1">{
                os.RemoveAll(runtime.TempDirectory)
        }</span>

        <span class="cov8" title="1">if runtime.ContextController != nil </span><span class="cov8" title="1">{
                runtime.ContextController.Stop()
        }</span>

        <span class="cov8" title="1">if runtime.ErrorInjector != nil </span><span class="cov8" title="1">{
                runtime.ErrorInjector.Reset()
        }</span>
}

// NewTimingCoordinator creates a new timing coordinator
func NewTimingCoordinator() *TimingCoordinator <span class="cov8" title="1">{
        return &amp;TimingCoordinator{
                barriers:     make(map[string]*sync.WaitGroup),
                signals:      make(map[string]chan struct{}),
                delays:       make(map[string]time.Duration),
                checkpoints:  make(map[string]time.Time),
                synchronized: false,
        }
}</span>

// CreateBarrier creates a synchronization barrier
func (tc *TimingCoordinator) CreateBarrier(name string, count int) <span class="cov8" title="1">{
        tc.mu.Lock()
        defer tc.mu.Unlock()

        wg := &amp;sync.WaitGroup{}
        wg.Add(count)
        tc.barriers[name] = wg
}</span>

// WaitForBarrier waits for a synchronization barrier
func (tc *TimingCoordinator) WaitForBarrier(name string) <span class="cov8" title="1">{
        tc.mu.RLock()
        barrier, exists := tc.barriers[name]
        tc.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                barrier.Done()
                barrier.Wait()
        }</span>
}

// SetDelay sets a delay for a specific operation
func (tc *TimingCoordinator) SetDelay(operation string, delay time.Duration) <span class="cov8" title="1">{
        tc.mu.Lock()
        defer tc.mu.Unlock()
        tc.delays[operation] = delay
}</span>

// ApplyDelay applies any configured delay for an operation
func (tc *TimingCoordinator) ApplyDelay(operation string) <span class="cov8" title="1">{
        tc.mu.RLock()
        delay, exists := tc.delays[operation]
        tc.mu.RUnlock()

        if exists &amp;&amp; delay &gt; 0 </span><span class="cov8" title="1">{
                time.Sleep(delay)
        }</span>
}

// CreateSignal creates a signal channel
func (tc *TimingCoordinator) CreateSignal(name string) <span class="cov8" title="1">{
        tc.mu.Lock()
        defer tc.mu.Unlock()
        tc.signals[name] = make(chan struct{})
}</span>

// WaitForSignal waits for a signal
func (tc *TimingCoordinator) WaitForSignal(name string) <span class="cov8" title="1">{
        tc.mu.RLock()
        signal, exists := tc.signals[name]
        tc.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                &lt;-signal
        }</span>
}

// SendSignal sends a signal
func (tc *TimingCoordinator) SendSignal(name string) <span class="cov8" title="1">{
        tc.mu.RLock()
        signal, exists := tc.signals[name]
        tc.mu.RUnlock()

        if exists </span><span class="cov8" title="1">{
                select </span>{
                case signal &lt;- struct{}{}:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                }
        }
}

// recordEvent records an event in the scenario execution log
func (sr *ScenarioRuntime) recordEvent(eventType ScenarioEventType, stepID string, phase ScenarioPhase, message string, err error, duration time.Duration, data map[string]interface{}) <span class="cov8" title="1">{
        sr.mu.Lock()
        defer sr.mu.Unlock()

        event := ScenarioEvent{
                Timestamp: time.Now(),
                Type:      eventType,
                StepID:    stepID,
                Phase:     phase,
                Message:   message,
                Error:     err,
                Duration:  duration,
                Data:      data,
        }

        sr.ExecutionLog = append(sr.ExecutionLog, event)
}</span>

// SetSharedData sets shared data accessible to all steps
func (sr *ScenarioRuntime) SetSharedData(key string, value interface{}) <span class="cov8" title="1">{
        sr.mu.Lock()
        defer sr.mu.Unlock()
        sr.SharedData[key] = value
}</span>

// GetSharedData gets shared data
func (sr *ScenarioRuntime) GetSharedData(key string) (interface{}, bool) <span class="cov8" title="1">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()
        value, exists := sr.SharedData[key]
        return value, exists
}</span>

// CreateTestFile creates a test file in the working directory
func (sr *ScenarioRuntime) CreateTestFile(filename string, content []byte) error <span class="cov8" title="1">{
        filePath := filepath.Join(sr.WorkingDirectory, filename)

        // Ensure directory exists
        if err := os.MkdirAll(filepath.Dir(filePath), 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(filePath, content, 0644); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sr.mu.Lock()
        sr.filesCreated = append(sr.filesCreated, filePath)
        sr.mu.Unlock()

        return nil</span>
}

// CreateTestDirectory creates a test directory in the working directory
func (sr *ScenarioRuntime) CreateTestDirectory(dirname string) error <span class="cov8" title="1">{
        dirPath := filepath.Join(sr.WorkingDirectory, dirname)

        if err := os.MkdirAll(dirPath, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">sr.mu.Lock()
        sr.dirsCreated = append(sr.dirsCreated, dirPath)
        sr.mu.Unlock()

        return nil</span>
}

// GetCreatedFiles returns list of files created during scenario
func (sr *ScenarioRuntime) GetCreatedFiles() []string <span class="cov8" title="1">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()

        result := make([]string, len(sr.filesCreated))
        copy(result, sr.filesCreated)
        return result
}</span>

// GetExecutionSummary returns a summary of scenario execution
func (sr *ScenarioRuntime) GetExecutionSummary() map[string]interface{} <span class="cov8" title="1">{
        sr.mu.RLock()
        defer sr.mu.RUnlock()

        successful := 0
        failed := 0
        for _, result := range sr.StepResults </span><span class="cov0" title="0">{
                if result.Success </span><span class="cov0" title="0">{
                        successful++
                }</span> else<span class="cov0" title="0"> {
                        failed++
                }</span>
        }

        <span class="cov8" title="1">return map[string]interface{}{
                "scenario_id":      sr.ScenarioID,
                "start_time":       sr.StartTime,
                "duration":         time.Since(sr.StartTime),
                "steps_successful": successful,
                "steps_failed":     failed,
                "total_events":     len(sr.ExecutionLog),
                "files_created":    len(sr.filesCreated),
                "dirs_created":     len(sr.dirsCreated),
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// This file is part of bkpdir
//
// Package main implements the BkpDir CLI application for directory archiving and file backup.
// It provides commands for creating full and incremental directory archives, backing up individual files,
// and managing archive verification and configuration.
package main

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"

        "github.com/spf13/cobra"
        "gopkg.in/yaml.v3"
)

// Version is the current version of bkpdir.
// This is the single source of truth for the version number.
// The Makefile uses this value during build via -ldflags.
const Version = "1.4.0"

var (
        compileDate = "2024-03-20" // This is a placeholder - actual value is set during build via -ldflags
        platform    = "unknown"    // This is a placeholder - actual value is set during build via -ldflags
)

var (
        dryRun     bool
        note       string
        showConfig bool
        listFile   string
)

// Long description for root command
const rootLongDesc = `bkpdir version %s (compiled %s) [%s]

BkpDir is a command-line tool for archiving directories and backing up individual files on macOS and Linux. 
It supports full and incremental directory backups, individual file backups, customizable exclusion patterns, 
Git-aware archive naming, and archive verification.`

func main() <span class="cov0" title="0">{
        // CFG-001: CLI application initialization and command structure
        // DECISION-REF: DEC-002
        rootCmd := &amp;cobra.Command{
                Use:     "bkpdir",
                Short:   "Directory archiving and file backup CLI for macOS and Linux",
                Long:    fmt.Sprintf(rootLongDesc, Version, compileDate, platform),
                Version: fmt.Sprintf("%s (compiled %s) [%s]", Version, compileDate, platform),
                Example: `  # Create a full directory archive
  bkpdir create "Initial backup"
  bkpdir full -n "Initial backup"  # backward compatibility

  # Create an incremental directory archive with verification
  bkpdir create --incremental "Changes after feature X" -v
  bkpdir inc -n "Changes after feature X" -v  # backward compatibility

  # Create a file backup
  bkpdir backup myfile.txt "Before changes"

  # List all directory archives
  bkpdir list

  # List backups for a specific file
  bkpdir --list myfile.txt

  # Verify a specific archive with checksums
  bkpdir verify backup-2024-03-20.zip -c

  # Show configuration
  bkpdir config
  bkpdir --config  # backward compatibility`,
                Run: func(cmd *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        // Handle --config flag when no subcommand is provided (backward compatibility)
                        if showConfig </span><span class="cov0" title="0">{
                                handleConfigCommand()
                                return
                        }</span>
                        // Handle --list flag for file backups
                        <span class="cov0" title="0">if cmd.Flags().Changed("list") </span><span class="cov0" title="0">{
                                handleListFileBackupsCommand(args)
                                return
                        }</span>
                        // If no config flag and no subcommand, show help
                        <span class="cov0" title="0">cmd.Help()</span>
                },
        }

        // Set the version template to show version in help output
        <span class="cov0" title="0">versionTemplate := fmt.Sprintf("bkpdir version %s (compiled %s) [%s]\n",
                Version, compileDate, platform)
        rootCmd.SetVersionTemplate(versionTemplate)

        // Global flags
        rootCmd.PersistentFlags().BoolVarP(&amp;dryRun, "dry-run", "d", false,
                "Show what would be done without creating archives")
        rootCmd.PersistentFlags().BoolVar(&amp;showConfig, "config", false,
                "Display configuration values and exit (backward compatibility)")
        rootCmd.PersistentFlags().StringVar(&amp;listFile, "list", "",
                "List backups for a specific file")

        // Add commands - new specification-compliant commands first
        rootCmd.AddCommand(createCmd())
        rootCmd.AddCommand(configCmd())

        // Add backward compatibility commands
        rootCmd.AddCommand(fullCmd())
        rootCmd.AddCommand(incCmd())

        // Add other commands
        rootCmd.AddCommand(listCmd())
        rootCmd.AddCommand(verifyCmd())
        rootCmd.AddCommand(backupCmd())
        rootCmd.AddCommand(versionCmd())

        if err := rootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Println(err)
                os.Exit(1)
        }</span>
}

func handleConfigCommand() <span class="cov0" title="0">{
        // CFG-001: Configuration display handling
        // CFG-003: Configuration output formatting
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg, err := LoadConfig(cwd)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(cfg.StatusConfigError)
        }</span>

        <span class="cov0" title="0">formatter := NewOutputFormatter(cfg)

        // Display configuration file paths
        configPaths := getConfigSearchPaths()
        expandedPaths := make([]string, len(configPaths))
        for i, path := range configPaths </span><span class="cov0" title="0">{
                expandedPath := expandPath(path)
                if !filepath.IsAbs(expandedPath) </span><span class="cov0" title="0">{
                        expandedPath = filepath.Join(cwd, expandedPath)
                }</span>
                <span class="cov0" title="0">expandedPaths[i] = expandedPath</span>
        }

        <span class="cov0" title="0">configPathsStr := strings.Join(expandedPaths, ":")
        formatter.PrintConfigValue("config", configPathsStr, "default")

        // Get all configuration values with their sources
        configValues := GetConfigValuesWithSources(cfg, cwd)

        // Display each configuration value
        for _, cv := range configValues </span><span class="cov0" title="0">{
                formatter.PrintConfigValue(cv.Name, cv.Value, cv.Source)
        }</span>
}

func handleCreateCommand() {<span class="cov8" title="1">
        // Implementation
}</span>

func handleListCommand() <span class="cov8" title="1">{
        // ARCH-002: Archive listing command implementation
        // CFG-003: Archive listing output formatting
        // Requirement: List Archives - Display all archives in the archive directory
        // Specification: Shows each archive with path and creation time using configurable format
        // Specification: Shows verification status if available: [VERIFIED], [FAILED], or [UNVERIFIED]
        // Specification: Archives are sorted by creation time (most recent first)

        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">cfg, err := LoadConfig(cwd)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(cfg.StatusConfigError)
        }</span>

        <span class="cov8" title="1">formatter := NewOutputFormatter(cfg)

        if err := ListArchivesEnhanced(cfg, formatter); err != nil </span><span class="cov0" title="0">{
                exitCode := HandleArchiveError(err, cfg, formatter)
                os.Exit(exitCode)
        }</span>
}

func handleVerifyCommand() {<span class="cov8" title="1">
        // Implementation
}</span>

func handleVersionCommand() {<span class="cov8" title="1">
        // Implementation
}</span>

func configCmd() *cobra.Command <span class="cov8" title="1">{
        // CFG-001: Configuration command implementation
        // CFG-003: Configuration command interface
        cmd := &amp;cobra.Command{
                Use:   "config [KEY] [VALUE]",
                Short: "Display or modify configuration values",
                Long: `Display configuration values or set a specific configuration value.

Examples:
  # Display all configuration values
  bkpdir config

  # Set a configuration value
  bkpdir config archive_dir_path /custom/archive/path
  bkpdir config include_git_info false`,
                Args: cobra.MaximumNArgs(2),
                Run: func(_ *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        if len(args) == 0 </span><span class="cov0" title="0">{
                                // Display configuration
                                handleConfigCommand()
                        }</span> else<span class="cov0" title="0"> if len(args) == 2 </span><span class="cov0" title="0">{
                                // Set configuration value
                                handleConfigSetCommand(args[0], args[1])
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Fprintf(os.Stderr, "Error: config set requires both KEY and VALUE\n")
                                fmt.Fprintf(os.Stderr, "Usage: bkpdir config [KEY] [VALUE]\n")
                                os.Exit(1)
                        }</span>
                },
        }
        <span class="cov8" title="1">return cmd</span>
}

func createCmd() *cobra.Command <span class="cov8" title="1">{
        // ARCH-002: Archive creation command implementation
        // CFG-003: Command interface for archive creation
        cmd := &amp;cobra.Command{
                Use:   "create",
                Short: "Create a new archive",
                Run: func(*cobra.Command, []string) </span><span class="cov0" title="0">{
                        handleCreateCommand()
                }</span>,
        }
        <span class="cov8" title="1">return cmd</span>
}

func fullCmd() *cobra.Command <span class="cov8" title="1">{
        // ARCH-002: Full archive creation command (backward compatibility)
        // CFG-003: Backward compatibility command interface
        cmd := &amp;cobra.Command{
                Use:   "full [NOTE]",
                Short: "Create a full archive of the current directory",
                Long: `Create a complete ZIP archive of the current directory. The archive will be stored in the 
archive directory with a timestamp. If the directory is identical to the most recent archive, 
no new archive is created.

Before creating an archive, the command compares the directory with its most recent archive.
If the directory is identical to the most recent archive, no new archive is created.`,
                Example: `  # Create a full archive
  bkpdir full

  # Create a full archive with a note
  bkpdir full "Before changes"

  # Show what would be archived without creating archive
  bkpdir full -d`,
                Args: cobra.MaximumNArgs(1),
                Run: func(_ *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        ctx := context.Background()
                        cwd, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov8" title="1">cfg, err := LoadConfig(cwd)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                                os.Exit(cfg.StatusConfigError)
                        }</span>

                        <span class="cov8" title="1">formatter := NewOutputFormatter(cfg)

                        // Use note from flag if provided, otherwise use positional argument
                        archiveNote := note
                        if archiveNote == "" &amp;&amp; len(args) &gt; 0 </span><span class="cov8" title="1">{
                                archiveNote = args[0]
                        }</span>

                        <span class="cov8" title="1">if err := CreateFullArchiveWithContext(ctx, cfg, archiveNote, dryRun, false); err != nil </span><span class="cov0" title="0">{
                                exitCode := HandleArchiveError(err, cfg, formatter)
                                os.Exit(exitCode)
                        }</span>
                },
        }
        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;note, "note", "n", "", "Add a note to the archive name")
        return cmd</span>
}

func incCmd() *cobra.Command <span class="cov8" title="1">{
        // ARCH-003: Incremental archive creation command
        // CFG-003: Incremental command interface
        cmd := &amp;cobra.Command{
                Use:   "inc [NOTE]",
                Short: "Create an incremental archive of the current directory",
                Long: `Create an incremental ZIP archive containing only files changed since the last full archive.
The archive will be stored in the archive directory with a timestamp. If no files have changed,
no new archive is created.

Before creating an archive, the command compares the directory with its most recent archive.
If the directory is identical to the most recent archive, no new archive is created.`,
                Example: `  # Create an incremental archive
  bkpdir inc

  # Create an incremental archive with a note
  bkpdir inc "After changes"

  # Show what would be archived without creating archive
  bkpdir inc -d`,
                Args: cobra.MaximumNArgs(1),
                Run: func(_ *cobra.Command, args []string) </span><span class="cov8" title="1">{
                        ctx := context.Background()
                        cwd, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov8" title="1">cfg, err := LoadConfig(cwd)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                                os.Exit(cfg.StatusConfigError)
                        }</span>

                        <span class="cov8" title="1">formatter := NewOutputFormatter(cfg)

                        // Use note from flag if provided, otherwise use positional argument
                        archiveNote := note
                        if archiveNote == "" &amp;&amp; len(args) &gt; 0 </span><span class="cov8" title="1">{
                                archiveNote = args[0]
                        }</span>

                        <span class="cov8" title="1">if err := CreateIncrementalArchiveWithContext(ctx, cfg, archiveNote, dryRun, false); err != nil </span><span class="cov0" title="0">{
                                exitCode := HandleArchiveError(err, cfg, formatter)
                                os.Exit(exitCode)
                        }</span>
                },
        }
        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;note, "note", "n", "", "Add a note to the archive name")
        return cmd</span>
}

func listCmd() *cobra.Command <span class="cov8" title="1">{
        // ARCH-002: Archive listing command
        // CFG-003: List command interface
        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "List archives",
                Run: func(*cobra.Command, []string) </span><span class="cov8" title="1">{
                        handleListCommand()
                }</span>,
        }
        <span class="cov8" title="1">return cmd</span>
}

func verifyCmd() *cobra.Command <span class="cov8" title="1">{
        // Archive verification command
        // CFG-003: Verify command interface
        cmd := &amp;cobra.Command{
                Use:   "verify",
                Short: "Verify archives",
                Run: func(*cobra.Command, []string) </span><span class="cov0" title="0">{
                        handleVerifyCommand()
                }</span>,
        }
        <span class="cov8" title="1">return cmd</span>
}

func versionCmd() *cobra.Command <span class="cov8" title="1">{
        // Version display command
        // CFG-003: Version command interface
        cmd := &amp;cobra.Command{
                Use:   "version",
                Short: "Display version information",
                Run: func(*cobra.Command, []string) </span><span class="cov0" title="0">{
                        handleVersionCommand()
                }</span>,
        }
        <span class="cov8" title="1">return cmd</span>
}

// ArchiveOptions holds parameters for archive creation functions
type ArchiveOptions struct {
        Context   context.Context
        Config    *Config
        Formatter *OutputFormatter
        Note      string
        DryRun    bool
        Verify    bool
}

// CreateFullArchiveEnhanced creates a full archive of the current directory with enhanced error handling
// and resource management. It supports dry-run mode and optional verification.
func CreateFullArchiveEnhanced(opts ArchiveOptions) error <span class="cov8" title="1">{
        // ARCH-002: Enhanced full archive creation
        // DECISION-REF: DEC-006, DEC-007
        return CreateFullArchive(opts.Config, opts.Note, opts.DryRun, opts.Verify)
}</span>

// CreateIncrementalArchiveEnhanced creates an incremental archive containing only files changed since
// the last full archive. It supports dry-run mode and optional verification.
func CreateIncrementalArchiveEnhanced(opts ArchiveOptions) error <span class="cov8" title="1">{
        // ARCH-003: Enhanced incremental archive creation
        // DECISION-REF: DEC-006, DEC-007
        return CreateIncrementalArchive(opts.Config, opts.Note, opts.DryRun, opts.Verify)
}</span>

// ListArchivesEnhanced displays all archives in the archive directory with enhanced formatting
// and error handling.
func ListArchivesEnhanced(cfg *Config, formatter *OutputFormatter) error <span class="cov8" title="1">{
        // ARCH-002: Enhanced archive listing with formatting
        // CFG-003: Template-based archive listing
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to get current directory", cfg.StatusDirectoryNotFound, err)
        }</span>

        <span class="cov8" title="1">archiveDir := cfg.ArchiveDirPath
        if cfg.UseCurrentDirName </span><span class="cov8" title="1">{
                archiveDir = filepath.Join(archiveDir, filepath.Base(cwd))
        }</span>

        <span class="cov8" title="1">archives, err := ListArchives(archiveDir)
        if err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to list archives", 1, err)
        }</span>

        <span class="cov8" title="1">if len(archives) == 0 </span><span class="cov0" title="0">{
                formatter.PrintNoArchivesFound(archiveDir)
                return nil
        }</span>

        // Requirement: Archives are sorted by creation time (most recent first)
        <span class="cov8" title="1">sort.Slice(archives, func(i, j int) bool </span><span class="cov8" title="1">{
                return archives[i].CreationTime.After(archives[j].CreationTime)
        }</span>)

        <span class="cov8" title="1">for _, a := range archives </span><span class="cov8" title="1">{
                status := ""
                if a.VerificationStatus != nil </span><span class="cov0" title="0">{
                        if a.VerificationStatus.IsVerified </span><span class="cov0" title="0">{
                                status = " [VERIFIED]"
                        }</span> else<span class="cov0" title="0"> {
                                status = " [FAILED]"
                        }</span>
                } else<span class="cov8" title="1"> {
                        status = " [UNVERIFIED]"
                }</span>

                // Use enhanced formatting with extraction if possible
                <span class="cov8" title="1">creationTime := a.CreationTime.Format("2006-01-02 15:04:05")
                output := formatter.FormatListArchiveWithExtraction(a.Name, creationTime)
                // Remove trailing newline from output to add status on same line
                output = strings.TrimSuffix(output, "\n")
                formatter.PrintArchiveListWithStatus(output, status)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// VerifyOptions holds parameters for archive verification functions
type VerifyOptions struct {
        Config       *Config
        Formatter    *OutputFormatter
        ArchiveName  string
        WithChecksum bool
}

// VerifyArchiveEnhanced verifies the integrity of an archive with optional checksum verification.
// It provides enhanced error handling and reporting.
func VerifyArchiveEnhanced(opts VerifyOptions) error <span class="cov8" title="1">{
        // Archive verification implementation
        // CFG-003: Verification output formatting
        archiveDir, err := getArchiveDirectory(opts.Config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if opts.ArchiveName != "" </span><span class="cov0" title="0">{
                return verifySingleArchive(opts, archiveDir)
        }</span>
        <span class="cov8" title="1">return verifyAllArchives(opts, archiveDir)</span>
}

// getArchiveDirectory determines the archive directory path
func getArchiveDirectory(cfg *Config) (string, error) <span class="cov8" title="1">{
        // CFG-001: Archive directory resolution
        // DECISION-REF: DEC-002
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return "", NewArchiveErrorWithCause("Failed to get current directory",
                        cfg.StatusDirectoryNotFound, err)
        }</span>

        <span class="cov8" title="1">archiveDir := cfg.ArchiveDirPath
        if cfg.UseCurrentDirName </span><span class="cov8" title="1">{
                archiveDir = filepath.Join(archiveDir, filepath.Base(cwd))
        }</span>
        <span class="cov8" title="1">return archiveDir, nil</span>
}

// verifySingleArchive verifies a specific archive
func verifySingleArchive(opts VerifyOptions, archiveDir string) error <span class="cov8" title="1">{
        // Single archive verification
        archivePath := filepath.Join(archiveDir, opts.ArchiveName)
        archive := &amp;Archive{
                Name: opts.ArchiveName,
                Path: archivePath,
        }

        status, err := performVerification(archive.Path, opts.WithChecksum)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return handleVerificationResult(archive, status, opts.ArchiveName)</span>
}

// verifyAllArchives verifies all archives in the directory
func verifyAllArchives(opts VerifyOptions, archiveDir string) error <span class="cov8" title="1">{
        // All archives verification
        archives, err := ListArchives(archiveDir)
        if err != nil </span><span class="cov0" title="0">{
                return NewArchiveErrorWithCause("Failed to list archives", 1, err)
        }</span>

        <span class="cov8" title="1">allPassed := true
        for _, archive := range archives </span><span class="cov0" title="0">{
                status, err := performVerification(archive.Path, opts.WithChecksum)
                if err != nil </span><span class="cov0" title="0">{
                        opts.Formatter.PrintVerificationFailed(archive.Name, err)
                        allPassed = false
                        continue</span>
                }

                <span class="cov0" title="0">if err := handleVerificationResult(&amp;archive, status, archive.Name); err != nil </span><span class="cov0" title="0">{
                        allPassed = false
                }</span>
        }

        <span class="cov8" title="1">if !allPassed </span><span class="cov0" title="0">{
                return NewArchiveError("Some archives failed verification", 1)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// performVerification performs the actual verification based on type
func performVerification(archivePath string, withChecksum bool) (*VerificationStatus, error) <span class="cov8" title="1">{
        // Archive verification execution
        if withChecksum </span><span class="cov8" title="1">{
                status, err := VerifyChecksums(archivePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, NewArchiveErrorWithCause("Archive checksum verification failed", 1, err)
                }</span>
                <span class="cov8" title="1">return status, nil</span>
        }

        <span class="cov8" title="1">status, err := VerifyArchive(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, NewArchiveErrorWithCause("Archive verification failed", 1, err)
        }</span>
        <span class="cov8" title="1">return status, nil</span>
}

// handleVerificationResult handles the result of verification
func handleVerificationResult(archive *Archive, status *VerificationStatus, name string) error <span class="cov8" title="1">{
        // Get config and formatter for proper output formatting
        cwd, _ := os.Getwd()
        cfg, _ := LoadConfig(cwd)
        formatter := NewOutputFormatter(cfg)

        // Store verification status
        if err := StoreVerificationStatus(archive, status); err != nil </span><span class="cov0" title="0">{
                // Don't fail if we can't store status, just warn
                formatter.PrintVerificationWarning(name, err)
        }</span>

        <span class="cov8" title="1">if status.IsVerified </span><span class="cov8" title="1">{
                formatter.PrintVerificationSuccess(name)
                return nil
        }</span>

        <span class="cov8" title="1">formatter.PrintVerificationFailed(name, fmt.Errorf("verification failed"))
        for _, errMsg := range status.Errors </span><span class="cov8" title="1">{
                formatter.PrintVerificationErrorDetail(errMsg)
        }</span>
        <span class="cov8" title="1">return NewArchiveError("Archive verification failed", 1)</span>
}

func handleListFileBackupsCommand(args []string) <span class="cov0" title="0">{
        // FILE-002: File backup listing command implementation
        // CFG-003: File backup listing output formatting
        var filePath string
        if listFile != "" </span><span class="cov0" title="0">{
                filePath = listFile
        }</span> else<span class="cov0" title="0"> if len(args) &gt; 0 </span><span class="cov0" title="0">{
                filePath = args[0]
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(os.Stderr, "Error: file path required for --list command\n")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg, err := LoadConfig(cwd)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(cfg.StatusConfigError)
        }</span>

        <span class="cov0" title="0">formatter := NewOutputFormatter(cfg)

        if err := ListFileBackupsEnhanced(cfg, formatter, filePath); err != nil </span><span class="cov0" title="0">{
                exitCode := HandleArchiveError(err, cfg, formatter)
                os.Exit(exitCode)
        }</span>
}

func backupCmd() *cobra.Command <span class="cov8" title="1">{
        // FILE-002: File backup command implementation
        // CFG-003: Backup command interface
        cmd := &amp;cobra.Command{
                Use:   "backup [FILE_PATH] [NOTE]",
                Short: "Create a backup of a single file",
                Long: `Create a backup of the specified file. The backup will be stored in the backup directory
with a timestamp. If the file is identical to the most recent backup, no new backup is created.

Before creating a backup, the command compares the file with its most recent backup.
If the file is identical to the most recent backup, no new backup is created.`,
                Example: `  # Create a file backup
  bkpdir backup myfile.txt

  # Create a file backup with a note
  bkpdir backup myfile.txt -n "Before changes"

  # Show what would be backed up without creating backup
  bkpdir backup -d myfile.txt`,
                Args: cobra.MinimumNArgs(1),
                Run: func(_ *cobra.Command, args []string) </span><span class="cov0" title="0">{
                        ctx := context.Background()
                        cwd, err := os.Getwd()
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">cfg, err := LoadConfig(cwd)
                        if err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                                os.Exit(cfg.StatusConfigError)
                        }</span>

                        <span class="cov0" title="0">formatter := NewOutputFormatter(cfg)

                        filePath := args[0]

                        // Use note from flag if provided, otherwise use positional argument
                        backupNote := note
                        if backupNote == "" &amp;&amp; len(args) &gt; 1 </span><span class="cov0" title="0">{
                                backupNote = args[1]
                        }</span>

                        <span class="cov0" title="0">if err := CreateFileBackupEnhanced(BackupOptions{
                                Context:   ctx,
                                Config:    cfg,
                                Formatter: formatter,
                                FilePath:  filePath,
                                Note:      backupNote,
                                DryRun:    dryRun,
                        }); err != nil </span><span class="cov0" title="0">{
                                exitCode := HandleArchiveError(err, cfg, formatter)
                                os.Exit(exitCode)
                        }</span>
                },
        }
        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;note, "note", "n", "", "Add a note to the backup name")
        return cmd</span>
}

func handleConfigSetCommand(key, value string) <span class="cov0" title="0">{
        // CFG-001: Configuration modification command
        // CFG-002: Configuration value setting
        // DECISION-REF: DEC-002
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error getting current directory: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">cfg, err := LoadConfig(cwd)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(cfg.StatusConfigError)
        }</span>

        <span class="cov0" title="0">formatter := NewOutputFormatter(cfg)
        configPath := filepath.Join(cwd, ".bkpdir.yml")
        configData := loadExistingConfigData(configPath)
        convertedValue := convertConfigValue(key, value)
        updateConfigData(configData, key, convertedValue)
        saveConfigData(configPath, configData)

        formatter.PrintConfigurationUpdated(key, convertedValue)
        formatter.PrintConfigFilePath(configPath)</span>
}

func loadExistingConfigData(configPath string) map[string]interface{} <span class="cov8" title="1">{
        // CFG-001: Configuration file loading
        // DECISION-REF: DEC-002
        var configData map[string]interface{}

        if data, err := os.ReadFile(configPath); err == nil </span><span class="cov8" title="1">{
                if err := yaml.Unmarshal(data, &amp;configData); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Error parsing existing config file: %v\n", err)
                        os.Exit(1)
                }</span>
        } else<span class="cov8" title="1"> {
                configData = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">return configData</span>
}

func convertConfigValue(key, value string) interface{} <span class="cov8" title="1">{
        // CFG-002: Configuration value type conversion
        switch key </span>{
        case "use_current_dir_name", "use_current_dir_name_for_files", "include_git_info", "verify_on_create":<span class="cov8" title="1">
                return convertBooleanValue(key, value)</span>
        case "status_config_error", "status_created_archive", "status_created_backup",
                "status_disk_full", "status_permission_denied":<span class="cov8" title="1">
                return convertIntegerValue(key, value)</span>
        case "archive_dir_path", "backup_dir_path", "checksum_algorithm":<span class="cov8" title="1">
                return value</span>
        default:<span class="cov0" title="0">
                fmt.Fprintf(os.Stderr, "Error: unknown configuration key: %s\n", key)
                fmt.Fprintf(os.Stderr, "Valid keys: archive_dir_path, backup_dir_path, use_current_dir_name, "+
                        "use_current_dir_name_for_files, include_git_info, verify_on_create, checksum_algorithm, "+
                        "status_config_error, status_created_archive, status_created_backup, status_disk_full, "+
                        "status_permission_denied\n")
                os.Exit(1)
                return nil</span>
        }
}

func convertBooleanValue(key, value string) bool <span class="cov8" title="1">{
        // CFG-002: Boolean configuration value conversion
        if value == "true" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">if value == "false" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov0" title="0">fmt.Fprintf(os.Stderr, "Error: %s requires a boolean value (true/false), got: %s\n", key, value)
        os.Exit(1)
        return false</span>
}

func convertIntegerValue(key, value string) int <span class="cov8" title="1">{
        // CFG-002: Integer configuration value conversion
        intVal, err := strconv.Atoi(value)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %s requires an integer value, got: %s\n", key, value)
                os.Exit(1)
        }</span>
        <span class="cov8" title="1">return intVal</span>
}

func updateConfigData(configData map[string]interface{}, key string, convertedValue interface{}) <span class="cov8" title="1">{
        // CFG-001: Configuration data updating
        if key == "verify_on_create" || key == "checksum_algorithm" </span><span class="cov8" title="1">{
                if configData["verification"] == nil </span><span class="cov8" title="1">{
                        configData["verification"] = make(map[string]interface{})
                }</span>
                <span class="cov8" title="1">verificationMap := configData["verification"].(map[string]interface{})
                if key == "verify_on_create" </span><span class="cov8" title="1">{
                        verificationMap["verify_on_create"] = convertedValue
                }</span> else<span class="cov8" title="1"> {
                        verificationMap["checksum_algorithm"] = convertedValue
                }</span>
        } else<span class="cov8" title="1"> {
                configData[key] = convertedValue
        }</span>
}

func saveConfigData(configPath string, configData map[string]interface{}) <span class="cov8" title="1">{
        // CFG-001: Configuration data persistence
        // DECISION-REF: DEC-002, DEC-008
        yamlData, err := yaml.Marshal(configData)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error marshaling config data: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(configPath, yamlData, 0644); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error writing config file: %v\n", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package main

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"
)

// COV-001: Selective coverage reporting tool
// This tool implements coverage exclusion patterns to focus metrics on new development

type CoverageConfig struct {
        BaselineDate             string
        BaselineMainCoverage     float64
        BaselineTestutilCoverage float64
        BuildTags                []string
        FilePatterns             []string
        FunctionPatterns         []string
        NewCodeCutoffDate        string
        AlwaysNew                []string
        AlwaysLegacy             []string
        ShowLegacyCoverage       bool
        ShowNewCodeCoverage      bool
        ShowOverallCoverage      bool
}

type CoverageLine struct {
        File       string
        Function   string
        Line       int
        Statements int
        Hits       int
        IsLegacy   bool
}

func main() <span class="cov0" title="0">{
        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Usage: %s &lt;coverage-profile&gt; [config-file]\n", os.Args[0])
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">coverageFile := os.Args[1]
        configFile := "coverage.toml"
        if len(os.Args) &gt;= 3 </span><span class="cov0" title="0">{
                configFile = os.Args[2]
        }</span>

        <span class="cov0" title="0">config, err := loadConfig(configFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error loading config: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">lines, err := parseCoverageProfile(coverageFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error parsing coverage profile: %v\n", err)
                os.Exit(1)
        }</span>

        // Classify lines as legacy or new code
        <span class="cov0" title="0">classifyLines(lines, config)

        // Generate reports
        generateReports(lines, config)</span>
}

func loadConfig(configFile string) (*CoverageConfig, error) <span class="cov0" title="0">{
        // Simple TOML-like parser for our specific config
        config := &amp;CoverageConfig{
                BaselineDate:        "2025-06-02",
                NewCodeCutoffDate:   "2025-06-02",
                ShowLegacyCoverage:  false,
                ShowNewCodeCoverage: true,
                ShowOverallCoverage: true,
                AlwaysLegacy: []string{
                        "main.go",
                        "config.go",
                        "formatter.go",
                        "backup.go",
                        "archive.go",
                },
                BuildTags:        []string{"legacy", "exclude_coverage"},
                FilePatterns:     []string{"*_legacy.go", "*_deprecated.go"},
                FunctionPatterns: []string{"^.*Legacy.*$", "^.*Deprecated.*$", "^main$"},
        }

        // If config file exists, we would parse it here
        // For now, using defaults from the TOML file we created

        return config, nil
}</span>

func parseCoverageProfile(filename string) ([]*CoverageLine, error) <span class="cov0" title="0">{
        file, err := os.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer file.Close()

        var lines []*CoverageLine
        scanner := bufio.NewScanner(file)

        // Skip the first line (mode: set)
        if scanner.Scan() </span>{<span class="cov0" title="0">
                // Skip mode line
        }</span>

        <span class="cov0" title="0">for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                if line == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">parts := strings.Fields(line)
                if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Parse: filename:startLine.startCol,endLine.endCol numStmt count
                <span class="cov0" title="0">fileAndRange := parts[0]
                numStmt, _ := strconv.Atoi(parts[1])
                count, _ := strconv.Atoi(parts[2])

                // Extract filename
                colonIndex := strings.Index(fileAndRange, ":")
                if colonIndex == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">filename := fileAndRange[:colonIndex]

                // Extract line range
                rangeStr := fileAndRange[colonIndex+1:]
                commaIndex := strings.Index(rangeStr, ",")
                if commaIndex == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">startPart := rangeStr[:commaIndex]
                dotIndex := strings.Index(startPart, ".")
                if dotIndex == -1 </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">lineNum, _ := strconv.Atoi(startPart[:dotIndex])

                coverageLine := &amp;CoverageLine{
                        File:       filename,
                        Line:       lineNum,
                        Statements: numStmt,
                        Hits:       count,
                }

                lines = append(lines, coverageLine)</span>
        }

        <span class="cov0" title="0">return lines, scanner.Err()</span>
}

func classifyLines(lines []*CoverageLine, config *CoverageConfig) <span class="cov0" title="0">{
        for _, line := range lines </span><span class="cov0" title="0">{
                line.IsLegacy = isLegacyFile(line.File, config)
        }</span>
}

func isLegacyFile(filename string, config *CoverageConfig) bool <span class="cov0" title="0">{
        base := filepath.Base(filename)

        // Check always legacy list
        for _, legacy := range config.AlwaysLegacy </span><span class="cov0" title="0">{
                if base == legacy </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Check always new list
        <span class="cov0" title="0">for _, new := range config.AlwaysNew </span><span class="cov0" title="0">{
                if base == new </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        // Check file patterns
        <span class="cov0" title="0">for _, pattern := range config.FilePatterns </span><span class="cov0" title="0">{
                matched, _ := filepath.Match(pattern, base)
                if matched </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // For now, consider all existing files as legacy based on our cutoff date
        // In a real implementation, we would check file modification times
        <span class="cov0" title="0">return true</span>
}

func generateReports(lines []*CoverageLine, config *CoverageConfig) <span class="cov0" title="0">{
        var totalStmts, totalHits int
        var legacyStmts, legacyHits int
        var newStmts, newHits int

        for _, line := range lines </span><span class="cov0" title="0">{
                totalStmts += line.Statements
                totalHits += line.Hits

                if line.IsLegacy </span><span class="cov0" title="0">{
                        legacyStmts += line.Statements
                        legacyHits += line.Hits
                }</span> else<span class="cov0" title="0"> {
                        newStmts += line.Statements
                        newHits += line.Hits
                }</span>
        }

        // Calculate coverage percentages
        <span class="cov0" title="0">totalCoverage := float64(totalHits) / float64(totalStmts) * 100
        legacyCoverage := float64(0)
        if legacyStmts &gt; 0 </span><span class="cov0" title="0">{
                legacyCoverage = float64(legacyHits) / float64(legacyStmts) * 100
        }</span>
        <span class="cov0" title="0">newCoverage := float64(0)
        if newStmts &gt; 0 </span><span class="cov0" title="0">{
                newCoverage = float64(newHits) / float64(newStmts) * 100
        }</span>

        // Print reports based on configuration
        <span class="cov0" title="0">fmt.Println("# Coverage Report (COV-001: Selective Coverage)")
        fmt.Printf("Generated: %s\n\n", time.Now().Format("2006-01-02 15:04:05"))

        if config.ShowOverallCoverage </span><span class="cov0" title="0">{
                fmt.Printf("## Overall Coverage\n")
                fmt.Printf("Total statements: %d\n", totalStmts)
                fmt.Printf("Total covered: %d\n", totalHits)
                fmt.Printf("Coverage: %.1f%%\n\n", totalCoverage)
        }</span>

        <span class="cov0" title="0">if config.ShowLegacyCoverage </span><span class="cov0" title="0">{
                fmt.Printf("## Legacy Code Coverage\n")
                fmt.Printf("Legacy statements: %d\n", legacyStmts)
                fmt.Printf("Legacy covered: %d\n", legacyHits)
                fmt.Printf("Legacy coverage: %.1f%%\n\n", legacyCoverage)
        }</span>

        <span class="cov0" title="0">if config.ShowNewCodeCoverage </span><span class="cov0" title="0">{
                fmt.Printf("## New Code Coverage\n")
                fmt.Printf("New statements: %d\n", newStmts)
                fmt.Printf("New covered: %d\n", newHits)
                if newStmts &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("New code coverage: %.1f%%\n", newCoverage)
                        if newCoverage &lt; 85.0 </span><span class="cov0" title="0">{
                                fmt.Printf("  WARNING: New code coverage below threshold (85.0%%)\n")
                        }</span> else<span class="cov0" title="0"> {
                                fmt.Printf(" New code coverage meets threshold\n")
                        }</span>
                } else<span class="cov0" title="0"> {
                        fmt.Printf("New code coverage: N/A (no new code detected)\n")
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // Coverage quality gates
        <span class="cov0" title="0">fmt.Printf("## Coverage Quality Gates\n")
        fmt.Printf("New code threshold: 85.0%%\n")
        fmt.Printf("Legacy code preservation: Required\n")

        if newStmts &gt; 0 &amp;&amp; newCoverage &lt; 85.0 </span><span class="cov0" title="0">{
                fmt.Printf("\n FAIL: New code coverage below threshold\n")
                os.Exit(1)
        }</span> else<span class="cov0" title="0"> if newStmts &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n PASS: All coverage requirements met\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("\n PASS: No new code to validate\n")
        }</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// This file is part of bkpdir
//
// Package main provides archive verification for BkpDir.
// It handles integrity checking and checksum verification of archives.
//
// Copyright (c) 2024 BkpDir Contributors
// Licensed under the MIT License
package main

import (
        "archive/zip"
        "crypto/sha256"
        "encoding/hex"
        "encoding/json"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "time"
)

// VerificationStatus represents the result of an archive verification
type VerificationStatus struct {
        VerifiedAt   time.Time `json:"verified_at"`
        IsVerified   bool      `json:"is_verified"`
        HasChecksums bool      `json:"has_checksums"`
        Errors       []string  `json:"errors,omitempty"`
}

// VerifyArchive verifies the integrity of an archive
func VerifyArchive(archivePath string) (*VerificationStatus, error) <span class="cov8" title="1">{
        // Archive verification implementation
        // DECISION-REF: DEC-001
        status := &amp;VerificationStatus{
                VerifiedAt: time.Now(),
                IsVerified: true,
        }

        // Open the archive
        reader, err := zip.OpenReader(archivePath)
        if err != nil </span><span class="cov8" title="1">{
                status.IsVerified = false
                status.Errors = append(status.Errors, fmt.Sprintf("Failed to open archive: %v", err))
                return status, nil
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        // Check each file in the archive
        for _, file := range reader.File </span><span class="cov8" title="1">{
                if err := verifyFile(file); err != nil </span><span class="cov0" title="0">{
                        status.IsVerified = false
                        status.Errors = append(status.Errors, err.Error())
                }</span>
        }

        <span class="cov8" title="1">return status, nil</span>
}

// verifyFile verifies a single file in the archive
func verifyFile(file *zip.File) error <span class="cov8" title="1">{
        // Individual file verification
        // DECISION-REF: DEC-001
        rc, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open file %s: %v", file.Name, err)
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        // Read a small portion to verify the file can be read
        buf := make([]byte, 1024)
        _, err = rc.Read(buf)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file %s: %v", file.Name, err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// GenerateChecksums generates checksums for files in the map
func GenerateChecksums(fileMap map[string]string, _ string) (map[string]string, error) <span class="cov8" title="1">{
        // Checksum generation for verification
        // DECISION-REF: DEC-001
        checksums := make(map[string]string)
        for relPath, absPath := range fileMap </span><span class="cov8" title="1">{
                checksum, err := calculateFileChecksum(absPath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to calculate checksum for %s: %w", relPath, err)
                }</span>
                <span class="cov8" title="1">checksums[relPath] = checksum</span>
        }
        <span class="cov8" title="1">return checksums, nil</span>
}

// calculateFileChecksum calculates the SHA-256 checksum of a file
func calculateFileChecksum(filePath string) (string, error) <span class="cov8" title="1">{
        // SHA-256 checksum calculation
        file, err := os.Open(filePath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">defer file.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, file); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return hex.EncodeToString(hash.Sum(nil)), nil</span>
}

// StoreChecksums stores checksums in the archive
func StoreChecksums(archive *Archive, checksums map[string]string) error <span class="cov8" title="1">{
        // Checksum storage in archive
        // DECISION-REF: DEC-001, DEC-008
        // Create a temporary file for checksums
        tmpFile, err := createChecksumsTempFile(checksums)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer os.Remove(tmpFile.Name())

        // Create a new archive with the checksums file
        newPath := archive.Path + ".new"
        if err := createNewArchiveWithChecksums(archive.Path, newPath, tmpFile.Name()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer os.Remove(newPath)

        // Replace the original archive with the new one
        if err := os.Rename(newPath, archive.Path); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to replace original archive: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// createChecksumsTempFile creates a temporary file containing the checksums
func createChecksumsTempFile(checksums map[string]string) (*os.File, error) <span class="cov8" title="1">{
        // Temporary checksum file creation
        // DECISION-REF: DEC-008
        tmpFile, err := os.CreateTemp("", "bkpdir-checksums-*.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create temporary file: %w", err)
        }</span>

        <span class="cov8" title="1">encoder := json.NewEncoder(tmpFile)
        if err := encoder.Encode(checksums); err != nil </span><span class="cov0" title="0">{
                tmpFile.Close()
                os.Remove(tmpFile.Name())
                return nil, fmt.Errorf("failed to encode checksums: %w", err)
        }</span>

        <span class="cov8" title="1">if err := tmpFile.Close(); err != nil </span><span class="cov0" title="0">{
                os.Remove(tmpFile.Name())
                return nil, fmt.Errorf("failed to close temporary file: %w", err)
        }</span>

        <span class="cov8" title="1">return tmpFile, nil</span>
}

// createNewArchiveWithChecksums creates a new archive with the checksums file
func createNewArchiveWithChecksums(archivePath, newPath, checksumsPath string) error <span class="cov8" title="1">{
        // Archive reconstruction with checksums
        // DECISION-REF: DEC-001, DEC-008
        // Open the original archive
        reader, err := zip.OpenReader(archivePath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        // Create the new archive
        writer, err := os.Create(newPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create new archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer writer.Close()

        zipWriter := zip.NewWriter(writer)
        defer zipWriter.Close()

        // Copy all files from the original archive
        if err := copyArchiveFiles(reader, zipWriter); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Add the checksums file
        <span class="cov8" title="1">return addChecksumsFile(zipWriter, checksumsPath)</span>
}

// copyArchiveFiles copies all files from the original archive to the new one
func copyArchiveFiles(reader *zip.ReadCloser, writer *zip.Writer) error <span class="cov8" title="1">{
        // Archive file copying during reconstruction
        for _, file := range reader.File </span><span class="cov8" title="1">{
                if err := copyArchiveFile(file, writer); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// copyArchiveFile copies a single file from the original archive to the new one
func copyArchiveFile(file *zip.File, writer *zip.Writer) error <span class="cov8" title="1">{
        // Individual file copying in archive
        rc, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open file in archive: %w", err)
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        header, err := zip.FileInfoHeader(file.FileInfo())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create header: %w", err)
        }</span>
        <span class="cov8" title="1">header.Name = file.Name

        w, err := writer.CreateHeader(header)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file in new archive: %w", err)
        }</span>

        <span class="cov8" title="1">if _, err := io.Copy(w, rc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to copy file to new archive: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// addChecksumsFile adds the checksums file to the archive
func addChecksumsFile(writer *zip.Writer, checksumsPath string) error <span class="cov8" title="1">{
        // ARCH-002: Checksum file addition to archive
        // DECISION-REF: DEC-001
        checksumFile, err := os.Open(checksumsPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open checksums file: %w", err)
        }</span>
        <span class="cov8" title="1">defer checksumFile.Close()

        header := &amp;zip.FileHeader{
                Name:   ".checksums",
                Method: zip.Deflate,
        }
        w, err := writer.CreateHeader(header)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create checksums file in archive: %w", err)
        }</span>

        <span class="cov8" title="1">if _, err := io.Copy(w, checksumFile); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write checksums to archive: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// ReadChecksums reads checksums from an archive
func ReadChecksums(archive *Archive) (map[string]string, error) <span class="cov0" title="0">{
        // ARCH-002: Checksum reading from archive
        // DECISION-REF: DEC-001
        reader, err := zip.OpenReader(archive.Path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open archive: %w", err)
        }</span>
        <span class="cov0" title="0">defer reader.Close()

        checksumFile, err := findChecksumsFile(reader)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return readChecksumsFromFile(checksumFile)</span>
}

// findChecksumsFile finds the checksums file in the archive
func findChecksumsFile(reader *zip.ReadCloser) (*zip.File, error) <span class="cov8" title="1">{
        // Checksum file location in archive
        for _, file := range reader.File </span><span class="cov8" title="1">{
                if file.Name == ".checksums" </span><span class="cov8" title="1">{
                        return file, nil
                }</span>
        }
        <span class="cov0" title="0">return nil, fmt.Errorf("checksums file not found in archive")</span>
}

// readChecksumsFromFile reads checksums from a file in the archive
func readChecksumsFromFile(file *zip.File) (map[string]string, error) <span class="cov8" title="1">{
        // Checksum data extraction from file
        rc, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open checksums file: %w", err)
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        var checksums map[string]string
        decoder := json.NewDecoder(rc)
        if err := decoder.Decode(&amp;checksums); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode checksums: %w", err)
        }</span>

        <span class="cov8" title="1">return checksums, nil</span>
}

// VerifyChecksums verifies file checksums against stored values
func VerifyChecksums(archivePath string) (*VerificationStatus, error) <span class="cov8" title="1">{
        // ARCH-002: Complete checksum verification process
        // DECISION-REF: DEC-001
        status := &amp;VerificationStatus{
                VerifiedAt: time.Now(),
                IsVerified: true,
        }

        reader, err := zip.OpenReader(archivePath)
        if err != nil </span><span class="cov8" title="1">{
                return handleVerificationError(status, "Failed to open archive: %v", err)
        }</span>
        <span class="cov8" title="1">defer reader.Close()

        checksumFile, err := findChecksumsFile(reader)
        if err != nil </span><span class="cov0" title="0">{
                return handleVerificationError(status, "Checksums file not found in archive")
        }</span>

        <span class="cov8" title="1">storedChecksums, err := readChecksumsFromFile(checksumFile)
        if err != nil </span><span class="cov0" title="0">{
                return handleVerificationError(status, "Failed to read checksums: %v", err)
        }</span>

        <span class="cov8" title="1">if err := verifyArchiveChecksums(reader, storedChecksums, status); err != nil </span><span class="cov0" title="0">{
                return handleVerificationError(status, err.Error())
        }</span>

        <span class="cov8" title="1">status.HasChecksums = true
        return status, nil</span>
}

// handleVerificationError handles verification errors
func handleVerificationError(
        status *VerificationStatus,
        format string,
        args ...interface{},
) (*VerificationStatus, error) <span class="cov8" title="1">{
        // CFG-002: Verification error handling
        // DECISION-REF: DEC-004
        status.IsVerified = false
        status.Errors = append(status.Errors, fmt.Sprintf(format, args...))
        return status, nil
}</span>

// verifyArchiveChecksums verifies checksums for all files in the archive
func verifyArchiveChecksums(
        reader *zip.ReadCloser,
        storedChecksums map[string]string,
        status *VerificationStatus,
) error <span class="cov8" title="1">{
        // Archive-wide checksum verification
        for _, file := range reader.File </span><span class="cov8" title="1">{
                if file.Name == ".checksums" </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if err := verifyFileChecksum(file, storedChecksums, status); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// verifyFileChecksum verifies the checksum of a single file
func verifyFileChecksum(file *zip.File, storedChecksums map[string]string, _ *VerificationStatus) error <span class="cov8" title="1">{
        // Individual file checksum verification
        rc, err := file.Open()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to open file %s: %v", file.Name, err)
        }</span>
        <span class="cov8" title="1">defer rc.Close()

        hash := sha256.New()
        if _, err := io.Copy(hash, rc); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to calculate checksum for %s: %v", file.Name, err)
        }</span>

        <span class="cov8" title="1">calculatedChecksum := hex.EncodeToString(hash.Sum(nil))
        storedChecksum, exists := storedChecksums[file.Name]

        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("no stored checksum for %s", file.Name)
        }</span>
        <span class="cov8" title="1">if calculatedChecksum != storedChecksum </span><span class="cov0" title="0">{
                return fmt.Errorf("checksum mismatch for %s", file.Name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// StoreVerificationStatus stores verification status in a metadata file
func StoreVerificationStatus(archive *Archive, status *VerificationStatus) error <span class="cov8" title="1">{
        // ARCH-002: Verification status persistence
        // DECISION-REF: DEC-008
        metadataDir := filepath.Join(filepath.Dir(archive.Path), ".metadata")
        if err := os.MkdirAll(metadataDir, 0o755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create metadata directory: %w", err)
        }</span>

        <span class="cov8" title="1">metadataPath := filepath.Join(metadataDir, archive.Name+".json")
        file, err := os.Create(metadataPath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create metadata file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        encoder := json.NewEncoder(file)
        if err := encoder.Encode(status); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode verification status: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// LoadVerificationStatus loads verification status from a metadata file
func LoadVerificationStatus(archive *Archive) (*VerificationStatus, error) <span class="cov8" title="1">{
        // ARCH-002: Verification status loading
        metadataDir := filepath.Join(filepath.Dir(archive.Path), ".metadata")
        metadataPath := filepath.Join(metadataDir, archive.Name+".json")

        if _, err := os.Stat(metadataPath); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">file, err := os.Open(metadataPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open metadata file: %w", err)
        }</span>
        <span class="cov8" title="1">defer file.Close()

        var status VerificationStatus
        decoder := json.NewDecoder(file)
        if err := decoder.Decode(&amp;status); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode verification status: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;status, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
